<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>C++ course notes</title>
        
        <meta name="robots" content="noindex" />
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> About &amp; Links</a></li><li class="chapter-item expanded "><a href="01_asm.html"><strong aria-hidden="true">2.</strong> Введение в ассемблер</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="01_asm.html"><strong aria-hidden="true">2.1.</strong> Конспект</a></li></ol></li><li class="chapter-item expanded "><a href="02_os_cpu.html"><strong aria-hidden="true">3.</strong> Прерывания, страничная адресация и т.д.</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="02_os_cpu.html"><strong aria-hidden="true">3.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=bTgtesThdSg.html"><strong aria-hidden="true">3.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=XY8xN1Ug1_k.html"><strong aria-hidden="true">3.3.</strong> Запись №2</a></li></ol></li><li class="chapter-item expanded "><a href="03_cache_pipelines.html"><strong aria-hidden="true">4.</strong> Кэши, конвейер</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="03_cache_pipelines.html"><strong aria-hidden="true">4.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=6vlNFxpSENs.html"><strong aria-hidden="true">4.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=DddjrdCrCF8.html"><strong aria-hidden="true">4.3.</strong> Запись №2</a></li></ol></li><li class="chapter-item expanded "><a href="04_syntax_types.html"><strong aria-hidden="true">5.</strong> Пересечение синтаксиса C/C++, типы данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="04_syntax_types.html"><strong aria-hidden="true">5.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=rGfQ5vWUS14.html"><strong aria-hidden="true">5.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=kf2zVHBEfy8.html"><strong aria-hidden="true">5.3.</strong> Запись №2</a></li></ol></li><li class="chapter-item expanded "><a href="05_compilation.html"><strong aria-hidden="true">6.</strong> Этапы компиляции</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="05_compilation.html"><strong aria-hidden="true">6.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=Fm-EmbQVrLE.html"><strong aria-hidden="true">6.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=w0G66pR3JuY.html"><strong aria-hidden="true">6.3.</strong> Запись №2</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=gsFYkmckcZs.html"><strong aria-hidden="true">6.4.</strong> Запись №3</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=jZAWVxcHLKA.html"><strong aria-hidden="true">6.5.</strong> Практика</a></li></ol></li><li class="chapter-item expanded "><a href="06_classes.html"><strong aria-hidden="true">7.</strong> Классы, абстракция данных</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="06_classes.html"><strong aria-hidden="true">7.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=4LkTiNYQYBU.html"><strong aria-hidden="true">7.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=kjJ-1-VsNRo.html"><strong aria-hidden="true">7.3.</strong> Запись №2</a></li></ol></li><li class="chapter-item expanded "><a href="07_classes_memory_preprocessor.html"><strong aria-hidden="true">8.</strong> Ещё про классы, выделение памяти, препроцессор</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="07_classes_memory_preprocessor.html"><strong aria-hidden="true">8.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=nI6NEPYPRXU.html"><strong aria-hidden="true">8.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=8JAp3tG6IrA.html"><strong aria-hidden="true">8.3.</strong> Запись №2</a></li></ol></li><li class="chapter-item expanded "><a href="08_inheritance.html"><strong aria-hidden="true">9.</strong> Наследование, виртуальные функции</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="08_inheritance.html"><strong aria-hidden="true">9.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=IcAaaX888xc.html"><strong aria-hidden="true">9.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=11MKhMYAmnE.html"><strong aria-hidden="true">9.3.</strong> Запись №2</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=oMkF60mU8ig.html"><strong aria-hidden="true">9.4.</strong> Запись №3</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=0-92_jC7YMU.html"><strong aria-hidden="true">9.5.</strong> Запись №4</a></li></ol></li><li class="chapter-item expanded "><a href="09_exceptions.html"><strong aria-hidden="true">10.</strong> Исключения, гарантии безопасности исключений, RAII</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="09_exceptions.html"><strong aria-hidden="true">10.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=R0tVZ1px5-Q.html"><strong aria-hidden="true">10.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=8PpW8qS2tEg.html"><strong aria-hidden="true">10.3.</strong> Запись №2</a></li></ol></li><li class="chapter-item expanded "><a href="10_memory_allocation.html"><strong aria-hidden="true">11.</strong> Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации, статические и динамические библиотеки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="10_memory_allocation.html"><strong aria-hidden="true">11.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=oDPaXS9tKlw.html"><strong aria-hidden="true">11.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=i8uYAe0E4PU.html"><strong aria-hidden="true">11.3.</strong> Запись №2</a></li></ol></li><li class="chapter-item expanded "><a href="11_templates.html"><strong aria-hidden="true">12.</strong> Шаблоны (templates)</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="11_templates.html"><strong aria-hidden="true">12.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=AXl4_eZ1eis.html"><strong aria-hidden="true">12.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=DwDbH7pxzRA.html"><strong aria-hidden="true">12.3.</strong> Запись №2</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=CY7vxMSBork.html"><strong aria-hidden="true">12.4.</strong> Практика №3</a></li></ol></li><li class="chapter-item expanded "><a href=".12_stl_sfinae.html"><strong aria-hidden="true">13.</strong> Обзор STL, tag-dispatching, SFINAE, пространства имён</a></li><li><ol class="section"><li class="chapter-item expanded "><a href=".12_stl_sfinae.html"><strong aria-hidden="true">13.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=RidP1GbfFEA.html"><strong aria-hidden="true">13.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=HQdf43h3B2o.html"><strong aria-hidden="true">13.3.</strong> Запись №2</a></li></ol></li><li class="chapter-item expanded "><a href="13_namespaces_using_adl.html"><strong aria-hidden="true">14.</strong> Пространства имён, using-декларации, using-директивы, ADL</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="13_namespaces_using_adl.html"><strong aria-hidden="true">14.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=fgD5itE5pCQ.html"><strong aria-hidden="true">14.2.</strong> Запись №1</a></li></ol></li><li class="chapter-item expanded "><a href="14_move_rvalue.html"><strong aria-hidden="true">15.</strong> Move-семантика, rvalue-ссылки</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="14_move_rvalue.html"><strong aria-hidden="true">15.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=KcNJbEmbqB4.html"><strong aria-hidden="true">15.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=p4LQfPJb9Q0.html"><strong aria-hidden="true">15.3.</strong> Запись №2</a></li></ol></li><li class="chapter-item expanded "><a href="15_intrusive_containers.html"><strong aria-hidden="true">16.</strong> Интрузивные контейнеры</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="15_intrusive_containers.html"><strong aria-hidden="true">16.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=Kf7qkcaWetc.html"><strong aria-hidden="true">16.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=fwPUzKDsQTA.html"><strong aria-hidden="true">16.3.</strong> Разбор практики по intrusive_list</a></li><li class="chapter-item expanded "><a href="https://github.com/sorokin/intrusive_list.html"><strong aria-hidden="true">16.4.</strong> Код intrusive_list</a></li></ol></li><li class="chapter-item expanded "><a href=".16_smart_pointers.html"><strong aria-hidden="true">17.</strong> Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></li><li><ol class="section"><li class="chapter-item expanded "><a href=".16_smart_pointers.html"><strong aria-hidden="true">17.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=L9ohcGR0yFE.html"><strong aria-hidden="true">17.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=M9h0_xBM7_8.html"><strong aria-hidden="true">17.3.</strong> Запись №2</a></li></ol></li><li class="chapter-item expanded "><a href="17_perfect_forwarding.html"><strong aria-hidden="true">18.</strong> Perfect forwarding, variadic templates</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="17_perfect_forwarding.html"><strong aria-hidden="true">18.1.</strong> Конспект</a></li><li class="chapter-item expanded "><a href="https://youtu.be/M9h0_xBM7_8?t=1786.html"><strong aria-hidden="true">18.2.</strong> Запись №1</a></li><li class="chapter-item expanded "><a href="https://www.youtube.com/watch?v=ydQD7-XSSt4.html"><strong aria-hidden="true">18.3.</strong> Запись №2</a></li></ol></li><li class="chapter-item expanded "><a href="CONTRIBUTING.html"><strong aria-hidden="true">19.</strong> CONTRIBUTING</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">C++ course notes</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        <a href="https://github.com/lejabque/cpp-notes" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#about--links" id="about--links">About &amp; Links</a></h1>
<h1><a class="header" href="#Введение-в-ассемблер" id="Введение-в-ассемблер">Введение в ассемблер</a></h1>
<p>Презентация - http://sorokin.github.io/cpp-course/lecture-1e.odp</p>
<p>Регистр <code>IP</code> (instruction pointer) содержит адрес команды.</p>
<ul>
<li><strong>16-битные регистры</strong> (8 штук): AX, CX, DX, BX, SP, BP, SI, DI </li>
<li><strong>8-битные регистры</strong> (тоже 8): AL, AH, BL, BH, CL, CH, DL, DH. AL + AH = AX, аналогично другие.</li>
<li><strong>32-битные регистры:</strong> EAX, и другие обычные с приставкой E - extended
<img src="./images/02.08_memory_cell.png" alt="Memory Cell" /></li>
</ul>
<h3><a class="header" href="#Команды-read-write" id="Команды-read-write">Команды read, write</a></h3>
<pre><code class="language-nasm">read (address)
write (address, value)
</code></pre>
<h3><a class="header" href="#Команда-mov" id="Команда-mov">Команда mov</a></h3>
<p>Команды для хранения в памяти кодируются:</p>
<pre><code class="language-nasm">89 C2			mov		edx, eax	; EDX = EAX
B8 05 00 00 00		mov		eax, 5		; EAX = 5
</code></pre>
<p><code>mov</code> может копировать содержимое памяти по адресу:</p>
<pre><code class="language-nasm">	mov		ax, [10]	; Переместить в регистр из памяти по адресу 10
	mov		ax, [bx]	; Переместить в регистр из памяти по адресу в BX
	mov		[bx], ax	; Переместить в память по адресу BX содержимое AX
	mov		[bx], [ax]	; WRONG! из памяти в память нельзя. Оно даже не скомпилируется
</code></pre>
<p><em>Забавный факт: <code>[ax]</code> невалидный адрес, больше можно почитать <a href="https://stackoverflow.com/questions/46771338/assembler-x86-code-doesnt-work">здесь</a></em></p>
<p>Команда <code>mov ax,[bx]</code> читает из ячейки с адресом BX и BX + 1:</p>
<p><code>AX = mem[BX + 1] * 256 + mem[BX]</code></p>
<h3><a class="header" href="#Команды-арифметики" id="Команды-арифметики">Команды арифметики</a></h3>
<pre><code class="language-nasm">	cmd		dst, src

	add		ax, cx		; AX = AX + CX
	sub		ax, cx		; AX = AX - CX, аналогично AND, OR, XOR
	inc		ax		; AX += 1
	inc		BYTE [bx]	; INC одного байта
	inc		WORD [bx]	; INC числа из двух байт (дальше DWORD и т.д.)
	dec		ax		; AX -= 1

	neg		ax		; AX = -AX
	not		ax		; AX = ~AX(побитово)

	mul		src		; unsigned, в пару DX:AX = src*AX, DX - старшая часть, AX - младшая
	imul		src		; signed
	div		src		; unsigned, AX = DX:AX / src, DX = DX:AX % src
	idiv		src		; signed
</code></pre>
<p>Перед делением 16-битного зануляем регистр DX:</p>
<pre><code class="language-nasm">	xor		dx, dx		; не &quot;mov dx,0&quot;, так как кодируется короче
	div		bx
</code></pre>
<pre><code class="language-nasm">	cwd				; сохраняет знак: берёт старший бит из AX, заполняет им DX
	idiv		bx
</code></pre>
<p>При этом в команде <code>DIV</code> если частное не помещается в <code>AX</code>, то это такая же ошибка, как деление на 0</p>
<h3><a class="header" href="#Команды-сдвигов" id="Команды-сдвигов">Команды сдвигов</a></h3>
<pre><code class="language-nasm">shl - Сдвиг влево
shr - Логический сдвиг вправо (бит знака теряется)
sar - Арифметический сдвиг вправо (сохранение знака)
</code></pre>
<h2><a class="header" href="#Оптимизации-компилятора" id="Оптимизации-компилятора">Оптимизации компилятора:</a></h2>
<p><code>g++ -O2 -S -masm=intel s.cpp</code> -- посмотреть ассемблированный код с оптимизацией.</p>
<p>Онлайн компилятор-дизассемблер: https://godbolt.org/. Можно поиграться с такой функцией и посмотреть на оптимизации компилятора:</p>
<pre><code class="language-c++">int foo(int a, int b)
{
    return a + b; // a-b компилится по-другому
}
</code></pre>
<h3><a class="header" href="#Команда-lea" id="Команда-lea">Команда <code>LEA</code></a></h3>
<pre><code class="language-nasm">	lea		ax, [bx] 	
	; в [] не только регистр, мб арифметическое выражение из них
</code></pre>
<p><code>LEA</code> записывает в dst выражение из [ ] (как &quot;mov src,[dst + ...]&quot;, но пишутся не данные по адресу, а сам адрес).</p>
<p>Также <code>LEA</code> может использоваться вместо <code>ADD</code>:</p>
<pre><code class="language-nasm">	lea		ax, [ax + 8]
	add		ax, 8
</code></pre>
<p>Эти две строки делают одно и тоже, только выполняются на разных блоках конвейера, а еще <code>lea</code> не трогает флаги, в отличие от <code>add</code>.</p>
<p>Подробнее <a href="https://stackoverflow.com/questions/1658294/whats-the-purpose-of-the-lea-instruction">здесь</a> (первые 2 отаета).</p>
<h3><a class="header" href="#Как-delизбегаетсяdel-оптимизируется-деление" id="Как-delизбегаетсяdel-оптимизируется-деление">Как <del>избегается</del> оптимизируется деление:</a></h3>
<p>Деление занимает много больше тактов, чем другие арифметические операции, а во время его вычисления весь конвейер стоит. Компиляторы стараются избегать операции деления, если это возможно.</p>
<p>Следующий код на C++:</p>
<pre><code class="language-c++">unsigned foo(unsigned a) // беззнаковый тип
{
    return a / 2;
}
</code></pre>
<p>Может быть оптимизирован компилятором до</p>
<pre><code class="language-nasm">	mov		eax, edi	; Аргумент находится в edi
	shr		eax		; Логический сдвиг вправо, второй аргумент по умолчанию 1
	ret
</code></pre>
<p>Со знаковым аргументом деление скомпилится так:</p>
<pre><code class="language-nasm">	mov		eax, edi
	shr		eax, 31		; Оставляем старший бит (знак)
	add		eax, edi	; Если число отрицательное, то добавляем 1 (чтобы при a=-1 всё работало)
	sar		eax		; Арифметический сдвиг вправо на 1 бит
</code></pre>
<p>А что будет с <code>unsigned</code> делением на 3? А оно скомпилится вот так:</p>
<pre><code class="language-nasm">	mov		eax, edi
	mov		edi, 2863311531	; 0xAAAAAAAB или 2^33/3
	imul		rax, rdi
	shr		rax, 33
</code></pre>
<p>Почему это лучше? Деление дорогое, а константу можем посчитать при компиляции, получая выигрыш в эффективности.</p>
<p>Почему это работает? Потому что при арифметике с переполнением деление на константу можно выполнить через умножение:</p>
<p><code>a / 3 = (a * 2^33) / (3 * 2^33) = (a &gt;&gt; 33) * 2863311531</code></p>
<h2><a class="header" href="#Команды-перехода-jmp-и-прочие" id="Команды-перехода-jmp-и-прочие">Команды перехода <code>JMP</code> и прочие</a></h2>
<pre><code class="language-nasm">.loop: ; метка
	inc		ax
	jmp		loop ; как присваивание в регистр IP
</code></pre>
<p><code>JMP</code> позволяет сделать бесконечный цикл</p>
<p>Основные условные переходы:</p>
<pre><code class="language-nasm">	cmp		ax, bx ; сравнить меняет регистр флага
	je, jne - jump if (not) equal
	jg, jng - jump if (not) greater (signed)
	jl, jnl - jump if (not) less (signed)
	ja, jna - jump if (not) above (unsigned)
	jb, jnb - jump if (not) below (unsigned)
</code></pre>
<h2><a class="header" href="#Регистры-флагов-flags-registers" id="Регистры-флагов-flags-registers">Регистры флагов (FLAGS Registers)</a></h2>
<p>Большой (до 64 бит) регистр, каждый бит - какой-то флаг.
Выставляются после инструкций (<code>CMP</code>, арифметика и пр.)</p>
<pre><code class="language-nasm">	ZF - zero flag 		; если рез. 0
	SF - sign flag 		; если рез. отрицательный
	CF - carry flag		; если рез. с битом переноса (для unsigned)
	OF - overflow flag 	; если рез. переполнился (для signed)
</code></pre>
<p>Есть команда <code>ADC</code>:  <code>dst = dst + src + CF</code></p>
<p>Отсюда другие <strong>команды перехода</strong>:</p>
<pre><code class="language-nasm">	jc, jnc - jump if (not) carry flag
	jz, jnz - jump if (not) zero flag
	js, jns - jump if (not) sign flag
	jo, jno - jump if (not) overflow flag
	jb, jc  - jump if carry flag
	ja      - jump if not carry flag &amp;&amp; not zero flag
	jl      - OF != SF
	jg      - OF == SF &amp;&amp; !ZF
</code></pre>
<p>Флаги для <code>cmp a,b</code>:</p>
<p><img src="./images/02.08_flags.png" alt="Flags scheme" /></p>
<p>Многие команды расставляют флаги, выполняя операцию:</p>
<ul>
<li><code>cmp</code> - сделать вычитание, но не записывать результат</li>
<li><code>test</code> - побитовый &amp;, но не записывает результат</li>
</ul>
<pre><code class="language-nasm">	test		ax, ax ; проверка на 0
	jz		L2
</code></pre>
<p>Пример программы с метками и прыжками:</p>
<pre><code class="language-nasm">.loop:
	mov		dx, ax
	add		ax, bx
	mov		bx, dx
	dec		cx
	jnz		loop
</code></pre>
<h2><a class="header" href="#Вызов-функций-и-выход-из-них" id="Вызов-функций-и-выход-из-них">Вызов функций и выход из них</a></h2>
<p>Заходим в функции и выходим из них в порядке стека.
Есть специальный регистр <code>SP</code>, который указывает на вершину стека.
Стек - от старших адресов к младшим. </p>
<pre><code class="language-nasm">	push		src		; SP -= 2, так как 2 байта. mem[SP] = src
	pop		src		; tmp = mem[SP], SP += 2, dst = tmp
</code></pre>
<p>Команды работы со стеком. Стек позволяет сохранять старые значения, которые необходимо вернуть:</p>
<pre><code class="language-nasm">	call	label			; вызов ф-иии
	ret				; выход из ф-ии
	; по своей сути эти строки равносильны:
	push		next_instr
	jmp		label
	...
	pop		tmp		; return к следующей инструкции
	jmp		tmp
</code></pre>
<h2><a class="header" href="#abi" id="abi">ABI</a></h2>
<p><strong>ABI</strong> - application binary interface.</p>
<p>Программе нужно вызывать какие-то функции операционной системы. ABI - набор соглашений для доступа приложений к операционной системе, там прописано всё про функции и прочее, в том числе размеры типов данных.</p>
<h2><a class="header" href="#Выделение-памяти" id="Выделение-памяти">Выделение памяти:</a></h2>
<pre><code class="language-c++">void f(char const*);

void g()
{
    char arr[113];
    f(arr);
}
</code></pre>
<p>Компилируется в:</p>
<pre><code class="language-nasm">g():
        sub             rsp, 136
        mov             rdi, rsp
        call            f(char const*)
        add             rsp, 136
        ret
</code></pre>
<p>К локальным переменным обращаемся через <code>rsp</code>, лежат на стеке. Размер стека - переменная на уровне операционной системы (вроде).</p>
<p>Обратим внимание на то, что если изменить размер массива на <strong>112</strong>, то этот код скомпилируется в:</p>
<pre><code class="language-nasm">g():
        sub             rsp, 120
        mov             rdi, rsp
        call            f(char const*)
        add             rsp, 120
        ret
</code></pre>
<p>Почему 136 изменилось на 120? Этот эффект называется выравниванием (alignment).
В качестве основной единицы работы с памятью используется <strong>машинное слово</strong>, размер которого обычно составляет несколько байт. Так называемый &quot;unaligned access&quot; сложен в реализации на аппаратном уровне, поэтому обращения по произвольному адресу либо не поддерживаются (и вызывают исключение процессора), либо поддерживаются, но работают медленно. Обычно компилятор выравнивает данные по границам машинных слов, в нашем случае <code>8 + 16 * k</code>.</p>
<h1><a class="header" href="#Введение-в-ассемблер-1" id="Введение-в-ассемблер-1">Введение в ассемблер</a></h1>
<p>Презентация - http://sorokin.github.io/cpp-course/lecture-1e.odp</p>
<p>Регистр <code>IP</code> (instruction pointer) содержит адрес команды.</p>
<ul>
<li><strong>16-битные регистры</strong> (8 штук): AX, CX, DX, BX, SP, BP, SI, DI </li>
<li><strong>8-битные регистры</strong> (тоже 8): AL, AH, BL, BH, CL, CH, DL, DH. AL + AH = AX, аналогично другие.</li>
<li><strong>32-битные регистры:</strong> EAX, и другие обычные с приставкой E - extended
<img src="./images/02.08_memory_cell.png" alt="Memory Cell" /></li>
</ul>
<h3><a class="header" href="#Команды-read-write-1" id="Команды-read-write-1">Команды read, write</a></h3>
<pre><code class="language-nasm">read (address)
write (address, value)
</code></pre>
<h3><a class="header" href="#Команда-mov-1" id="Команда-mov-1">Команда mov</a></h3>
<p>Команды для хранения в памяти кодируются:</p>
<pre><code class="language-nasm">89 C2			mov		edx, eax	; EDX = EAX
B8 05 00 00 00		mov		eax, 5		; EAX = 5
</code></pre>
<p><code>mov</code> может копировать содержимое памяти по адресу:</p>
<pre><code class="language-nasm">	mov		ax, [10]	; Переместить в регистр из памяти по адресу 10
	mov		ax, [bx]	; Переместить в регистр из памяти по адресу в BX
	mov		[bx], ax	; Переместить в память по адресу BX содержимое AX
	mov		[bx], [ax]	; WRONG! из памяти в память нельзя. Оно даже не скомпилируется
</code></pre>
<p><em>Забавный факт: <code>[ax]</code> невалидный адрес, больше можно почитать <a href="https://stackoverflow.com/questions/46771338/assembler-x86-code-doesnt-work">здесь</a></em></p>
<p>Команда <code>mov ax,[bx]</code> читает из ячейки с адресом BX и BX + 1:</p>
<p><code>AX = mem[BX + 1] * 256 + mem[BX]</code></p>
<h3><a class="header" href="#Команды-арифметики-1" id="Команды-арифметики-1">Команды арифметики</a></h3>
<pre><code class="language-nasm">	cmd		dst, src

	add		ax, cx		; AX = AX + CX
	sub		ax, cx		; AX = AX - CX, аналогично AND, OR, XOR
	inc		ax		; AX += 1
	inc		BYTE [bx]	; INC одного байта
	inc		WORD [bx]	; INC числа из двух байт (дальше DWORD и т.д.)
	dec		ax		; AX -= 1

	neg		ax		; AX = -AX
	not		ax		; AX = ~AX(побитово)

	mul		src		; unsigned, в пару DX:AX = src*AX, DX - старшая часть, AX - младшая
	imul		src		; signed
	div		src		; unsigned, AX = DX:AX / src, DX = DX:AX % src
	idiv		src		; signed
</code></pre>
<p>Перед делением 16-битного зануляем регистр DX:</p>
<pre><code class="language-nasm">	xor		dx, dx		; не &quot;mov dx,0&quot;, так как кодируется короче
	div		bx
</code></pre>
<pre><code class="language-nasm">	cwd				; сохраняет знак: берёт старший бит из AX, заполняет им DX
	idiv		bx
</code></pre>
<p>При этом в команде <code>DIV</code> если частное не помещается в <code>AX</code>, то это такая же ошибка, как деление на 0</p>
<h3><a class="header" href="#Команды-сдвигов-1" id="Команды-сдвигов-1">Команды сдвигов</a></h3>
<pre><code class="language-nasm">shl - Сдвиг влево
shr - Логический сдвиг вправо (бит знака теряется)
sar - Арифметический сдвиг вправо (сохранение знака)
</code></pre>
<h2><a class="header" href="#Оптимизации-компилятора-1" id="Оптимизации-компилятора-1">Оптимизации компилятора:</a></h2>
<p><code>g++ -O2 -S -masm=intel s.cpp</code> -- посмотреть ассемблированный код с оптимизацией.</p>
<p>Онлайн компилятор-дизассемблер: https://godbolt.org/. Можно поиграться с такой функцией и посмотреть на оптимизации компилятора:</p>
<pre><code class="language-c++">int foo(int a, int b)
{
    return a + b; // a-b компилится по-другому
}
</code></pre>
<h3><a class="header" href="#Команда-lea-1" id="Команда-lea-1">Команда <code>LEA</code></a></h3>
<pre><code class="language-nasm">	lea		ax, [bx] 	
	; в [] не только регистр, мб арифметическое выражение из них
</code></pre>
<p><code>LEA</code> записывает в dst выражение из [ ] (как &quot;mov src,[dst + ...]&quot;, но пишутся не данные по адресу, а сам адрес).</p>
<p>Также <code>LEA</code> может использоваться вместо <code>ADD</code>:</p>
<pre><code class="language-nasm">	lea		ax, [ax + 8]
	add		ax, 8
</code></pre>
<p>Эти две строки делают одно и тоже, только выполняются на разных блоках конвейера, а еще <code>lea</code> не трогает флаги, в отличие от <code>add</code>.</p>
<p>Подробнее <a href="https://stackoverflow.com/questions/1658294/whats-the-purpose-of-the-lea-instruction">здесь</a> (первые 2 отаета).</p>
<h3><a class="header" href="#Как-delизбегаетсяdel-оптимизируется-деление-1" id="Как-delизбегаетсяdel-оптимизируется-деление-1">Как <del>избегается</del> оптимизируется деление:</a></h3>
<p>Деление занимает много больше тактов, чем другие арифметические операции, а во время его вычисления весь конвейер стоит. Компиляторы стараются избегать операции деления, если это возможно.</p>
<p>Следующий код на C++:</p>
<pre><code class="language-c++">unsigned foo(unsigned a) // беззнаковый тип
{
    return a / 2;
}
</code></pre>
<p>Может быть оптимизирован компилятором до</p>
<pre><code class="language-nasm">	mov		eax, edi	; Аргумент находится в edi
	shr		eax		; Логический сдвиг вправо, второй аргумент по умолчанию 1
	ret
</code></pre>
<p>Со знаковым аргументом деление скомпилится так:</p>
<pre><code class="language-nasm">	mov		eax, edi
	shr		eax, 31		; Оставляем старший бит (знак)
	add		eax, edi	; Если число отрицательное, то добавляем 1 (чтобы при a=-1 всё работало)
	sar		eax		; Арифметический сдвиг вправо на 1 бит
</code></pre>
<p>А что будет с <code>unsigned</code> делением на 3? А оно скомпилится вот так:</p>
<pre><code class="language-nasm">	mov		eax, edi
	mov		edi, 2863311531	; 0xAAAAAAAB или 2^33/3
	imul		rax, rdi
	shr		rax, 33
</code></pre>
<p>Почему это лучше? Деление дорогое, а константу можем посчитать при компиляции, получая выигрыш в эффективности.</p>
<p>Почему это работает? Потому что при арифметике с переполнением деление на константу можно выполнить через умножение:</p>
<p><code>a / 3 = (a * 2^33) / (3 * 2^33) = (a &gt;&gt; 33) * 2863311531</code></p>
<h2><a class="header" href="#Команды-перехода-jmp-и-прочие-1" id="Команды-перехода-jmp-и-прочие-1">Команды перехода <code>JMP</code> и прочие</a></h2>
<pre><code class="language-nasm">.loop: ; метка
	inc		ax
	jmp		loop ; как присваивание в регистр IP
</code></pre>
<p><code>JMP</code> позволяет сделать бесконечный цикл</p>
<p>Основные условные переходы:</p>
<pre><code class="language-nasm">	cmp		ax, bx ; сравнить меняет регистр флага
	je, jne - jump if (not) equal
	jg, jng - jump if (not) greater (signed)
	jl, jnl - jump if (not) less (signed)
	ja, jna - jump if (not) above (unsigned)
	jb, jnb - jump if (not) below (unsigned)
</code></pre>
<h2><a class="header" href="#Регистры-флагов-flags-registers-1" id="Регистры-флагов-flags-registers-1">Регистры флагов (FLAGS Registers)</a></h2>
<p>Большой (до 64 бит) регистр, каждый бит - какой-то флаг.
Выставляются после инструкций (<code>CMP</code>, арифметика и пр.)</p>
<pre><code class="language-nasm">	ZF - zero flag 		; если рез. 0
	SF - sign flag 		; если рез. отрицательный
	CF - carry flag		; если рез. с битом переноса (для unsigned)
	OF - overflow flag 	; если рез. переполнился (для signed)
</code></pre>
<p>Есть команда <code>ADC</code>:  <code>dst = dst + src + CF</code></p>
<p>Отсюда другие <strong>команды перехода</strong>:</p>
<pre><code class="language-nasm">	jc, jnc - jump if (not) carry flag
	jz, jnz - jump if (not) zero flag
	js, jns - jump if (not) sign flag
	jo, jno - jump if (not) overflow flag
	jb, jc  - jump if carry flag
	ja      - jump if not carry flag &amp;&amp; not zero flag
	jl      - OF != SF
	jg      - OF == SF &amp;&amp; !ZF
</code></pre>
<p>Флаги для <code>cmp a,b</code>:</p>
<p><img src="./images/02.08_flags.png" alt="Flags scheme" /></p>
<p>Многие команды расставляют флаги, выполняя операцию:</p>
<ul>
<li><code>cmp</code> - сделать вычитание, но не записывать результат</li>
<li><code>test</code> - побитовый &amp;, но не записывает результат</li>
</ul>
<pre><code class="language-nasm">	test		ax, ax ; проверка на 0
	jz		L2
</code></pre>
<p>Пример программы с метками и прыжками:</p>
<pre><code class="language-nasm">.loop:
	mov		dx, ax
	add		ax, bx
	mov		bx, dx
	dec		cx
	jnz		loop
</code></pre>
<h2><a class="header" href="#Вызов-функций-и-выход-из-них-1" id="Вызов-функций-и-выход-из-них-1">Вызов функций и выход из них</a></h2>
<p>Заходим в функции и выходим из них в порядке стека.
Есть специальный регистр <code>SP</code>, который указывает на вершину стека.
Стек - от старших адресов к младшим. </p>
<pre><code class="language-nasm">	push		src		; SP -= 2, так как 2 байта. mem[SP] = src
	pop		src		; tmp = mem[SP], SP += 2, dst = tmp
</code></pre>
<p>Команды работы со стеком. Стек позволяет сохранять старые значения, которые необходимо вернуть:</p>
<pre><code class="language-nasm">	call	label			; вызов ф-иии
	ret				; выход из ф-ии
	; по своей сути эти строки равносильны:
	push		next_instr
	jmp		label
	...
	pop		tmp		; return к следующей инструкции
	jmp		tmp
</code></pre>
<h2><a class="header" href="#abi-1" id="abi-1">ABI</a></h2>
<p><strong>ABI</strong> - application binary interface.</p>
<p>Программе нужно вызывать какие-то функции операционной системы. ABI - набор соглашений для доступа приложений к операционной системе, там прописано всё про функции и прочее, в том числе размеры типов данных.</p>
<h2><a class="header" href="#Выделение-памяти-1" id="Выделение-памяти-1">Выделение памяти:</a></h2>
<pre><code class="language-c++">void f(char const*);

void g()
{
    char arr[113];
    f(arr);
}
</code></pre>
<p>Компилируется в:</p>
<pre><code class="language-nasm">g():
        sub             rsp, 136
        mov             rdi, rsp
        call            f(char const*)
        add             rsp, 136
        ret
</code></pre>
<p>К локальным переменным обращаемся через <code>rsp</code>, лежат на стеке. Размер стека - переменная на уровне операционной системы (вроде).</p>
<p>Обратим внимание на то, что если изменить размер массива на <strong>112</strong>, то этот код скомпилируется в:</p>
<pre><code class="language-nasm">g():
        sub             rsp, 120
        mov             rdi, rsp
        call            f(char const*)
        add             rsp, 120
        ret
</code></pre>
<p>Почему 136 изменилось на 120? Этот эффект называется выравниванием (alignment).
В качестве основной единицы работы с памятью используется <strong>машинное слово</strong>, размер которого обычно составляет несколько байт. Так называемый &quot;unaligned access&quot; сложен в реализации на аппаратном уровне, поэтому обращения по произвольному адресу либо не поддерживаются (и вызывают исключение процессора), либо поддерживаются, но работают медленно. Обычно компилятор выравнивает данные по границам машинных слов, в нашем случае <code>8 + 16 * k</code>.</p>
<h2><a class="header" href="#Прерывания" id="Прерывания">Прерывания</a></h2>
<p>Почему программа с вечным циклом не повесит нам весь компьютер, даже если у нас всего одно ядро? Как ОС работает с устройствами? Всё это завязано на перерываниях.</p>
<p>Что происходит при прерывании: </p>
<ul>
<li>Значения регистров текущего процесса дампаются в оперативную память</li>
<li>Подгружаются значения регистров другого процесса и исполнение передаётся ему<br />
Такая схема называется <em>вытесняющей многозадачностью</em>.</li>
</ul>
<p>Способы прерывания на устройства:</p>
<ul>
<li><em>Polling</em> - процессор сам опрашивает устройства, когда считает нужным.</li>
<li><em>Interrupt</em> (прерывание) - устройство само говорит об изменении, процессор вызывает обработчик прерываний.</li>
</ul>
<p><strong>Local timer interrupt</strong> - прерывания по таймеру, своё у каждого ядра ЦП.
ОС заводит таймер, таймер срабатывает, провоцирует прерывание и ОС получает управление в обработчике прерываний.<br />
На самом деле, всё сложнее, потому что постоянно работающие таймеры это неэкономно, поэтому он, например, отключается, если на ядре ничего не исполняется.</p>
<p><strong>Rescheduling interrupts</strong> - прерывания, используещиеся для перепланировки (миграции) процесса на другое ядро в целях распределения нагрузки. Реализованы с помощью <a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt">IPI</a>.</p>
<h2><a class="header" href="#Про-память" id="Про-память">Про память</a></h2>
<p>ОС реализует следующие принципы:</p>
<ul>
<li><em>hardware abstraction</em> - мышка может быть подключена по-разному подключенной, но программе всё равно</li>
<li><em>isolation process</em> - программа не может повлиять на другие программы (записать в их память) </li>
</ul>
<p>Это достигается следующим образом:</p>
<p><strong>Физическая память</strong> - реальный модуль памяти (как на ЭВМ)</p>
<p><strong>Виртуальная память</strong> - пространство памяти процессов, &quot;то, что видит программа&quot;. Обращение по адресу памяти в программе - обращение по адресу в виртуальной памяти. 
Процесс преобразования из виртуальной в физическую называется <em>трансляцией адресов</em> и реализуется в специальном блоке процессора <a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a></p>
<p><em>дальше везде рассматривается 32-битная система</em></p>
<h3><a class="header" href="#Страничная-адресация" id="Страничная-адресация">Страничная адресация</a></h3>
<p>Способ организации виртуальной памяти, при котором виртуальные адреса отображаются на физические постранично (обычно 1 страница = 4 КB).</p>
<p>Память процесса может лежать в физической памяти в любом порядке:</p>
<p><img src="./images/02.15_memory_disorder.png" alt="Memory Disorder" /></p>
<p>Адресация реализуется через <em>PageTables</em>.</p>
<p>Вместо массива на много элементов храним массив (<em>каталог страниц</em>) размера 1024 из указателей на массивы размерами по 1024 (<em>таблицы страниц</em>). Почему это удобнее? Некоторые таблицы можно не хранить, если нужно выделить не все.</p>
<p>Это выглядит как-то так:</p>
<p><img src="./images/02.15_page_table.png" alt="Page Table" />
<img src="./images/02.15_page_tables.png" alt="Page Table" />
Для ускорения трансляции применяется специальный кеш TLB (Translation lookaside buffer).</p>
<p>Подробнее можно прочитать тут: https://wiki.osdev.org/Paging</p>
<h2><a class="header" href="#Механизм-адресации-на-уровне-процессора" id="Механизм-адресации-на-уровне-процессора">Механизм адресации на уровне процессора:</a></h2>
<p><strong>Пример адреса:</strong>
Virtual adress - 0x123456789A</p>
<p>Младшие 12 бит виртуального адреса: смещение внутри страницы. Следующие 10 бит - индекс в таблице страниц, старшие 10 бит - индекс в каталоге страниц.</p>
<pre><code class="language-c++">typedef uint32_t page_table_element;
typedef uint32_t virtual_address;
struct page_directory
{
     uint32_t translate(virtual_address);
     private:
     	page_table_element data[1024];
};
</code></pre>
<p>Альтернативы:</p>
<ul>
<li><em>Хеш-таблица</em>: плохо взаимодействует с кэшем. Использовалась в PowerPC</li>
</ul>
<p>Это всё было про <em>32-битную архитектуру</em>. На <em>64-битной</em> числа так красиво не сходятся. Используют следующее: добавляется ещё один уровень (можно и не один, на самом деле), массивы делают по 512. </p>
<p>Пример: процессор может транслировать только 48 бит (соответствует размеру дерева из уровней). Физической памяти - 39 бит. Почему? &quot;Сколько пинов у процессора есть, чтобы обращаться к памяти, столько и бит&quot;. 
Остальные биты в 64-битном адресе заполнены одинаковыми значениями и мы их не используем.</p>
<p>В регистре <strong>CR3</strong> хранится указатель на каталог страниц для процесса.</p>
<h2><a class="header" href="#Про-системные-вызовы-стек-вызовов-и-frame-pointer" id="Про-системные-вызовы-стек-вызовов-и-frame-pointer">Про системные вызовы, стек вызовов и frame pointer</a></h2>
<p><strong>syscall</strong> - интерфейс взаимодействия процесса программы с ядром ОС. Например, это чтение/запись в файла/терминала, завершение программы с кодом ошибки и т.д.</p>
<p><strong>rip</strong> - регистр, в котором хранится адрес исполняемой инструкции в памяти</p>
<pre><code class="language-nasm">main:
	mov		rdx, 42
	push		43
	push		44
	call		bar
bar:
	sub		rsp, 40
	; 
	add		rsp,40
	ret
</code></pre>
<p>Как понять, кто вызывал функцию? (WIP)</p>
<p><strong>Stack frame</strong> (кадр стека) - условная часть стека, принадлежащая вызванной функции. Содержит стековые переменные, адрес возврата и, опционально, описанный далее frame pointer</p>
<p>Компилятор умеет внедрять в файл специальную отладочную информацию: бесплатно по производительности, но занимает место в памяти.</p>
<p>Альтернатива: в скомпилированном коде при вызове функции обновляется stack frame pointer (указатель на кадр стека), таким образом кадры образуют односвязный список, а стек можно &quot;раскрутить&quot; (unwind).</p>
<p>Плюсы: без лишних телодвижений программа может узнать свой стек вызовов без отладчика. Минусы: при обильном вызове функций теряем в производительности.</p>
<p><strong>rbp</strong> - регистр, который используется для указания на предыдущий кадр стека.</p>
<p>На https://godbolt.org можно посмотреть, что следующий код:</p>
<pre><code class="language-nasm">int foo(char const*);

int bar()
{
    char arr[40];
    return foo(arr) + 1;
}
</code></pre>
<p>с флагами <code>-O2  -fno-omit-frame-pointer</code> компилируется во что-то такое:</p>
<pre><code class="language-nasm">bar:
	push		rbp
	mov		rbp, rsp
	sub		rbp, 40
	;
	mov		rsp, rbp
	pop		rbp
	ret
</code></pre>
<h2><a class="header" href="#Прерывания-1" id="Прерывания-1">Прерывания</a></h2>
<p>Почему программа с вечным циклом не повесит нам весь компьютер, даже если у нас всего одно ядро? Как ОС работает с устройствами? Всё это завязано на перерываниях.</p>
<p>Что происходит при прерывании: </p>
<ul>
<li>Значения регистров текущего процесса дампаются в оперативную память</li>
<li>Подгружаются значения регистров другого процесса и исполнение передаётся ему<br />
Такая схема называется <em>вытесняющей многозадачностью</em>.</li>
</ul>
<p>Способы прерывания на устройства:</p>
<ul>
<li><em>Polling</em> - процессор сам опрашивает устройства, когда считает нужным.</li>
<li><em>Interrupt</em> (прерывание) - устройство само говорит об изменении, процессор вызывает обработчик прерываний.</li>
</ul>
<p><strong>Local timer interrupt</strong> - прерывания по таймеру, своё у каждого ядра ЦП.
ОС заводит таймер, таймер срабатывает, провоцирует прерывание и ОС получает управление в обработчике прерываний.<br />
На самом деле, всё сложнее, потому что постоянно работающие таймеры это неэкономно, поэтому он, например, отключается, если на ядре ничего не исполняется.</p>
<p><strong>Rescheduling interrupts</strong> - прерывания, используещиеся для перепланировки (миграции) процесса на другое ядро в целях распределения нагрузки. Реализованы с помощью <a href="https://en.wikipedia.org/wiki/Inter-processor_interrupt">IPI</a>.</p>
<h2><a class="header" href="#Про-память-1" id="Про-память-1">Про память</a></h2>
<p>ОС реализует следующие принципы:</p>
<ul>
<li><em>hardware abstraction</em> - мышка может быть подключена по-разному подключенной, но программе всё равно</li>
<li><em>isolation process</em> - программа не может повлиять на другие программы (записать в их память) </li>
</ul>
<p>Это достигается следующим образом:</p>
<p><strong>Физическая память</strong> - реальный модуль памяти (как на ЭВМ)</p>
<p><strong>Виртуальная память</strong> - пространство памяти процессов, &quot;то, что видит программа&quot;. Обращение по адресу памяти в программе - обращение по адресу в виртуальной памяти. 
Процесс преобразования из виртуальной в физическую называется <em>трансляцией адресов</em> и реализуется в специальном блоке процессора <a href="https://en.wikipedia.org/wiki/Memory_management_unit">MMU</a></p>
<p><em>дальше везде рассматривается 32-битная система</em></p>
<h3><a class="header" href="#Страничная-адресация-1" id="Страничная-адресация-1">Страничная адресация</a></h3>
<p>Способ организации виртуальной памяти, при котором виртуальные адреса отображаются на физические постранично (обычно 1 страница = 4 КB).</p>
<p>Память процесса может лежать в физической памяти в любом порядке:</p>
<p><img src="./images/02.15_memory_disorder.png" alt="Memory Disorder" /></p>
<p>Адресация реализуется через <em>PageTables</em>.</p>
<p>Вместо массива на много элементов храним массив (<em>каталог страниц</em>) размера 1024 из указателей на массивы размерами по 1024 (<em>таблицы страниц</em>). Почему это удобнее? Некоторые таблицы можно не хранить, если нужно выделить не все.</p>
<p>Это выглядит как-то так:</p>
<p><img src="./images/02.15_page_table.png" alt="Page Table" />
<img src="./images/02.15_page_tables.png" alt="Page Table" />
Для ускорения трансляции применяется специальный кеш TLB (Translation lookaside buffer).</p>
<p>Подробнее можно прочитать тут: https://wiki.osdev.org/Paging</p>
<h2><a class="header" href="#Механизм-адресации-на-уровне-процессора-1" id="Механизм-адресации-на-уровне-процессора-1">Механизм адресации на уровне процессора:</a></h2>
<p><strong>Пример адреса:</strong>
Virtual adress - 0x123456789A</p>
<p>Младшие 12 бит виртуального адреса: смещение внутри страницы. Следующие 10 бит - индекс в таблице страниц, старшие 10 бит - индекс в каталоге страниц.</p>
<pre><code class="language-c++">typedef uint32_t page_table_element;
typedef uint32_t virtual_address;
struct page_directory
{
     uint32_t translate(virtual_address);
     private:
     	page_table_element data[1024];
};
</code></pre>
<p>Альтернативы:</p>
<ul>
<li><em>Хеш-таблица</em>: плохо взаимодействует с кэшем. Использовалась в PowerPC</li>
</ul>
<p>Это всё было про <em>32-битную архитектуру</em>. На <em>64-битной</em> числа так красиво не сходятся. Используют следующее: добавляется ещё один уровень (можно и не один, на самом деле), массивы делают по 512. </p>
<p>Пример: процессор может транслировать только 48 бит (соответствует размеру дерева из уровней). Физической памяти - 39 бит. Почему? &quot;Сколько пинов у процессора есть, чтобы обращаться к памяти, столько и бит&quot;. 
Остальные биты в 64-битном адресе заполнены одинаковыми значениями и мы их не используем.</p>
<p>В регистре <strong>CR3</strong> хранится указатель на каталог страниц для процесса.</p>
<h2><a class="header" href="#Про-системные-вызовы-стек-вызовов-и-frame-pointer-1" id="Про-системные-вызовы-стек-вызовов-и-frame-pointer-1">Про системные вызовы, стек вызовов и frame pointer</a></h2>
<p><strong>syscall</strong> - интерфейс взаимодействия процесса программы с ядром ОС. Например, это чтение/запись в файла/терминала, завершение программы с кодом ошибки и т.д.</p>
<p><strong>rip</strong> - регистр, в котором хранится адрес исполняемой инструкции в памяти</p>
<pre><code class="language-nasm">main:
	mov		rdx, 42
	push		43
	push		44
	call		bar
bar:
	sub		rsp, 40
	; 
	add		rsp,40
	ret
</code></pre>
<p>Как понять, кто вызывал функцию? (WIP)</p>
<p><strong>Stack frame</strong> (кадр стека) - условная часть стека, принадлежащая вызванной функции. Содержит стековые переменные, адрес возврата и, опционально, описанный далее frame pointer</p>
<p>Компилятор умеет внедрять в файл специальную отладочную информацию: бесплатно по производительности, но занимает место в памяти.</p>
<p>Альтернатива: в скомпилированном коде при вызове функции обновляется stack frame pointer (указатель на кадр стека), таким образом кадры образуют односвязный список, а стек можно &quot;раскрутить&quot; (unwind).</p>
<p>Плюсы: без лишних телодвижений программа может узнать свой стек вызовов без отладчика. Минусы: при обильном вызове функций теряем в производительности.</p>
<p><strong>rbp</strong> - регистр, который используется для указания на предыдущий кадр стека.</p>
<p>На https://godbolt.org можно посмотреть, что следующий код:</p>
<pre><code class="language-nasm">int foo(char const*);

int bar()
{
    char arr[40];
    return foo(arr) + 1;
}
</code></pre>
<p>с флагами <code>-O2  -fno-omit-frame-pointer</code> компилируется во что-то такое:</p>
<pre><code class="language-nasm">bar:
	push		rbp
	mov		rbp, rsp
	sub		rbp, 40
	;
	mov		rsp, rbp
	pop		rbp
	ret
</code></pre>
<h1><a class="header" href="#Запись-1" id="Запись-1">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2" id="Запись-2">Запись №2</a></h1>
<h1><a class="header" href="#Кэш-память" id="Кэш-память">Кэш-память</a></h1>
<blockquote>
<p>Optimize for data first, then code. Memory access is probably going to be your biggest bottleneck</p>
</blockquote>
<p>Одинаково ли по времени будет работать следующий код?</p>
<pre><code class="language-python">for i = 0..n:				for i=0..n:
	for j=0..n:				for j=0..n:
		a[i][j] = 0 				a[j][i] = 0
</code></pre>
<p>У этих двух кодов большая разница из-за процессорного кэша. Первый цикл обращается к памяти последовательно, а второй &quot;скачет&quot; по ней. Поэтому обращения к памяти первого цикла попадают в кэш, а второго - нет. С ростом <strong>N</strong> видна разница между уровнями кэша на графике времени обработки одного элемента:</p>
<p><img src="./images/02.29_cache_hit_graph.png" alt="Cache Hit Graph" /></p>
<p>Небольшие пики - скачки из-за попадания в один бакет (заметно на степенях двойки), сильное изменение времени работы происходит, когда данные перестают попадать в кэш какого-то уровня.</p>
<p><strong>Кэш</strong> реализован через хэш-таблицы (дискретного размера), где ключ - адрес в памяти.
Линии кэша примерно по <em>64 байта</em> разделенные на группы (buckets), размеры которых называются ассоциативностью кэша.</p>
<p>Подробнее про кэш  можно прочитать в <a href="https://github.com/DespairedController/computer-architecture/blob/master/1_4/1_4.pdf">конспектах по ЭВМ</a> </p>
<p><strong>Prefetching</strong> - если много кэш-промахов, запрашиваем заранее подгрузить в кэш. Это работает на уровне кэш-подсистемы процессора, а не компилятора/ОС.</p>
<p><em>Пример</em>: хранение хэш-таблицы с открытой адресацией. Два варианта: </p>
<p><img src="./images/02.29_hash_table.png" alt="Hash-Table" /></p>
<ul>
<li>
<p>Если ожидаются частые попадания, то хранить полезнее данные рядом с ключом.</p>
</li>
<li>
<p>Если ожидаются редкие попадания, то лучше хранить ключи и данные отдельно.</p>
</li>
</ul>
<h2><a class="header" href="#tlb---translation-lookaside-buffer" id="tlb---translation-lookaside-buffer">TLB - translation lookaside buffer</a></h2>
<p>Зачем нужен? Это кэш для ускорения трансляции виртуального адреса в физический. Так же, как и обычный, может быть нескольких уровней.</p>
<h2><a class="header" href="#huge-pages" id="huge-pages">Huge Pages</a></h2>
<p><em>Идея</em>: отображать страницу памяти в лежащую подряд физическую память. Тогда проще обходить каталог страниц. Например, если программе нужно прочитать 1 Мбайт непрерывных данных, которых нет в <em>TLB</em> кэше, то нужно сделать обращение к 256 страницам.</p>
<p>Но использовать тяжело, так как с ними тяжело делать <em>swap</em> (подкачка страниц). Например, в <em>Windows</em> требуются специальные права, чтобы выделять не-swappable память.</p>
<p><strong>Swap</strong> - хотим выделить памяти больше, чем у нас есть физической (оперативной). Особенно было актуально раньше, когда оперативной памяти было мало. Некоторые страницы из оперативной памяти записывались на диск и помечались недоступными, но при необходимости можно было вытеснить другую страницу и выгрузить нужную с диска.</p>
<h1><a class="header" href="#Конвейер-pipelining" id="Конвейер-pipelining">Конвейер (Pipelining)</a></h1>
<p>Ну тут опять всё <a href="https://github.com/DespairedController/computer-architecture/blob/master/2_3-4/2_3-4.pdf">как было на ЭВМ</a>.</p>
<p>Разбили выполнение команды на несколько стадий, теперь можем повысить частоту, так как каждая стадия стала проще. Выигрыш в том, что можем давать новые данные на каждом такте.</p>
<p><strong>Спекулятивное исполнение</strong>: условные переходы дорогие, поэтому мы предсказываем переход, выполняем, а если не угадали, то откатываемя. В общем, ничего нового. Также это называется <strong>branch prediction</strong>.
Можем как выиграть, так и проиграть от этого. Например, <a href="https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array">в некоторых программах на отсортированном массиве</a> предсказание может улучшить время работы в несколько раз.</p>
<p>Полезно писать программу так, чтобы уровень зависимостей команд был как можно меньше (это может также пытаться делать компилятор). Например:</p>
<pre><code class="language-c++">int f(int a, int b, int c, int d)
{
 return a * b * c * d;
}
</code></pre>
<p>может скомпилиться в следующий код, чтоб уменьшить количество зависимых умножений:
<code> (a* b) * (c * d)</code></p>
<pre><code class="language-nasm"> imul		edi, esi
 imul		edx, ecx
 imul		edx, edi
 mov		eax, edx
 ret
</code></pre>
<p>Похожее происходит с циклами. Посмотрим на алгоритм Хаффмана:</p>
<pre><code class="language-c++">void count_huffman_weights(char const* src, size_t size)
{
     uint32_t count[256] = {0};
     for (size_t i = 0; i != size; ++i)
         ++count[src[i]];
}
</code></pre>
<p>может быть разбит компилятором на параллельные исполнения. Так будут выглядеть зависимости:</p>
<p><img src="./images/02.29_dependencies.png" alt="Dependencies" /></p>
<p>Но у нас возникают проблемы из-за того, что мы пишем в одни переменные. Как пофиксить? Можем сделать 8 разных массивов-счетчиков. Такая реализация используется в библиотеке <strong>Zstandart</strong></p>
<pre><code class="language-c++">void count_huffman_weights_improved(char const* src, size_t size)
{
 uint32_t count[8][256] = {};
 size = size / 8 * 8;
 for (size_t i = 0; i &lt; size;)
     {
           ++count[0][src[i++]]; ++count[1][src[i++]]; ++count[2][src[i++]];
           ++count[3][src[i++]]; ++count[4][src[i++]]; ++count[5][src[i++]];
           ++count[6][src[i++]]; ++count[7][src[i++]];
     }
}
</code></pre>
<hr />
<p>​	Полезные книжки по теме:</p>
<ul>
<li>J. Shen, M. Lipasti — Modern Processor Design: Fundamentals of Superscalar Processors</li>
<li>J. Hennessy, D. Patterson — Computer Architecture: A Quantitative Approach</li>
</ul>
<h1><a class="header" href="#Кэш-память-1" id="Кэш-память-1">Кэш-память</a></h1>
<blockquote>
<p>Optimize for data first, then code. Memory access is probably going to be your biggest bottleneck</p>
</blockquote>
<p>Одинаково ли по времени будет работать следующий код?</p>
<pre><code class="language-python">for i = 0..n:				for i=0..n:
	for j=0..n:				for j=0..n:
		a[i][j] = 0 				a[j][i] = 0
</code></pre>
<p>У этих двух кодов большая разница из-за процессорного кэша. Первый цикл обращается к памяти последовательно, а второй &quot;скачет&quot; по ней. Поэтому обращения к памяти первого цикла попадают в кэш, а второго - нет. С ростом <strong>N</strong> видна разница между уровнями кэша на графике времени обработки одного элемента:</p>
<p><img src="./images/02.29_cache_hit_graph.png" alt="Cache Hit Graph" /></p>
<p>Небольшие пики - скачки из-за попадания в один бакет (заметно на степенях двойки), сильное изменение времени работы происходит, когда данные перестают попадать в кэш какого-то уровня.</p>
<p><strong>Кэш</strong> реализован через хэш-таблицы (дискретного размера), где ключ - адрес в памяти.
Линии кэша примерно по <em>64 байта</em> разделенные на группы (buckets), размеры которых называются ассоциативностью кэша.</p>
<p>Подробнее про кэш  можно прочитать в <a href="https://github.com/DespairedController/computer-architecture/blob/master/1_4/1_4.pdf">конспектах по ЭВМ</a> </p>
<p><strong>Prefetching</strong> - если много кэш-промахов, запрашиваем заранее подгрузить в кэш. Это работает на уровне кэш-подсистемы процессора, а не компилятора/ОС.</p>
<p><em>Пример</em>: хранение хэш-таблицы с открытой адресацией. Два варианта: </p>
<p><img src="./images/02.29_hash_table.png" alt="Hash-Table" /></p>
<ul>
<li>
<p>Если ожидаются частые попадания, то хранить полезнее данные рядом с ключом.</p>
</li>
<li>
<p>Если ожидаются редкие попадания, то лучше хранить ключи и данные отдельно.</p>
</li>
</ul>
<h2><a class="header" href="#tlb---translation-lookaside-buffer-1" id="tlb---translation-lookaside-buffer-1">TLB - translation lookaside buffer</a></h2>
<p>Зачем нужен? Это кэш для ускорения трансляции виртуального адреса в физический. Так же, как и обычный, может быть нескольких уровней.</p>
<h2><a class="header" href="#huge-pages-1" id="huge-pages-1">Huge Pages</a></h2>
<p><em>Идея</em>: отображать страницу памяти в лежащую подряд физическую память. Тогда проще обходить каталог страниц. Например, если программе нужно прочитать 1 Мбайт непрерывных данных, которых нет в <em>TLB</em> кэше, то нужно сделать обращение к 256 страницам.</p>
<p>Но использовать тяжело, так как с ними тяжело делать <em>swap</em> (подкачка страниц). Например, в <em>Windows</em> требуются специальные права, чтобы выделять не-swappable память.</p>
<p><strong>Swap</strong> - хотим выделить памяти больше, чем у нас есть физической (оперативной). Особенно было актуально раньше, когда оперативной памяти было мало. Некоторые страницы из оперативной памяти записывались на диск и помечались недоступными, но при необходимости можно было вытеснить другую страницу и выгрузить нужную с диска.</p>
<h1><a class="header" href="#Конвейер-pipelining-1" id="Конвейер-pipelining-1">Конвейер (Pipelining)</a></h1>
<p>Ну тут опять всё <a href="https://github.com/DespairedController/computer-architecture/blob/master/2_3-4/2_3-4.pdf">как было на ЭВМ</a>.</p>
<p>Разбили выполнение команды на несколько стадий, теперь можем повысить частоту, так как каждая стадия стала проще. Выигрыш в том, что можем давать новые данные на каждом такте.</p>
<p><strong>Спекулятивное исполнение</strong>: условные переходы дорогие, поэтому мы предсказываем переход, выполняем, а если не угадали, то откатываемя. В общем, ничего нового. Также это называется <strong>branch prediction</strong>.
Можем как выиграть, так и проиграть от этого. Например, <a href="https://stackoverflow.com/questions/11227809/why-is-processing-a-sorted-array-faster-than-processing-an-unsorted-array">в некоторых программах на отсортированном массиве</a> предсказание может улучшить время работы в несколько раз.</p>
<p>Полезно писать программу так, чтобы уровень зависимостей команд был как можно меньше (это может также пытаться делать компилятор). Например:</p>
<pre><code class="language-c++">int f(int a, int b, int c, int d)
{
 return a * b * c * d;
}
</code></pre>
<p>может скомпилиться в следующий код, чтоб уменьшить количество зависимых умножений:
<code> (a* b) * (c * d)</code></p>
<pre><code class="language-nasm"> imul		edi, esi
 imul		edx, ecx
 imul		edx, edi
 mov		eax, edx
 ret
</code></pre>
<p>Похожее происходит с циклами. Посмотрим на алгоритм Хаффмана:</p>
<pre><code class="language-c++">void count_huffman_weights(char const* src, size_t size)
{
     uint32_t count[256] = {0};
     for (size_t i = 0; i != size; ++i)
         ++count[src[i]];
}
</code></pre>
<p>может быть разбит компилятором на параллельные исполнения. Так будут выглядеть зависимости:</p>
<p><img src="./images/02.29_dependencies.png" alt="Dependencies" /></p>
<p>Но у нас возникают проблемы из-за того, что мы пишем в одни переменные. Как пофиксить? Можем сделать 8 разных массивов-счетчиков. Такая реализация используется в библиотеке <strong>Zstandart</strong></p>
<pre><code class="language-c++">void count_huffman_weights_improved(char const* src, size_t size)
{
 uint32_t count[8][256] = {};
 size = size / 8 * 8;
 for (size_t i = 0; i &lt; size;)
     {
           ++count[0][src[i++]]; ++count[1][src[i++]]; ++count[2][src[i++]];
           ++count[3][src[i++]]; ++count[4][src[i++]]; ++count[5][src[i++]];
           ++count[6][src[i++]]; ++count[7][src[i++]];
     }
}
</code></pre>
<hr />
<p>​	Полезные книжки по теме:</p>
<ul>
<li>J. Shen, M. Lipasti — Modern Processor Design: Fundamentals of Superscalar Processors</li>
<li>J. Hennessy, D. Patterson — Computer Architecture: A Quantitative Approach</li>
</ul>
<h1><a class="header" href="#Запись-1-1" id="Запись-1-1">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-1" id="Запись-2-1">Запись №2</a></h1>
<h1><a class="header" href="#Синтаксическое-пересечение-c-и-c" id="Синтаксическое-пересечение-c-и-c">Синтаксическое пересечение C и C++</a></h1>
<h2><a class="header" href="#Типы-данных" id="Типы-данных">Типы данных</a></h2>
<h3><a class="header" href="#Целочисленные" id="Целочисленные">Целочисленные:</a></h3>
<pre><code class="language-c++">signed int // по умолчанию тип знаковый, то же самое, что и int
// типы и их беззнаковые варианты:
short		unsigned short
int		unsigned
long		unsigned long
long long	unsigned long long
</code></pre>
<p>Стандарт не приписывает конкретных размеров типа, гарантирует только, что не меньше. Размеры типов прописаны в ABI архитектуры.</p>
<table><thead><tr><th>типы</th><th>32 bit</th><th>win64</th><th>linux64</th></tr></thead><tbody>
<tr><td>short</td><td>8</td><td>8</td><td>8</td></tr>
<tr><td>short</td><td>16</td><td>16</td><td>16</td></tr>
<tr><td>int</td><td>32</td><td>32</td><td>32</td></tr>
<tr><td>long</td><td>32</td><td>32</td><td>64</td></tr>
<tr><td>long long</td><td>64</td><td>64</td><td>64</td></tr>
</tbody></table>
<p><strong>8-битные типы</strong></p>
<pre><code class="language-c++">// это 3 разных типа, в отличие от int и signed int
char    // может быть как знаковый, так и нет
unsigned char			
signed char
</code></pre>
<p>Как проверить, одинаковые ли типы? Перегрузить функцию.</p>
<pre><code class="language-c++">void foo(int){}
void foo(signed int){} // не скомпилируется, так как две функции с одинаковой сигнатурой
</code></pre>
<pre><code class="language-c++">void foo(char){}
void foo(signed char){} // скомпилируется
</code></pre>
<p><strong>Существуют типы с фиксированным размером:</strong>
Следует использовать их, если хотим тип гарантированного размера:</p>
<pre><code class="language-c++">#inlcude &lt;cstdint&gt;
int8_t			uint8_t
int16_t			uint16_t
int32_t			uint32_t
int64_t			uint64_t
</code></pre>
<pre><code class="language-c++">arr[i]; // какого типа нужно брать i?
#inlcude &lt;cstddef&gt; // в ней лежат нужные типы
</code></pre>
<p><strong><code>size_t</code></strong> - тип, размера которого хватит, чтобы хранить максимальный размер;<br />
он <code>unsigned</code> (размер на 32bit - 32, на 64bit - 64), у <strong><code>sizeof(...)</code></strong> тип <strong><code>size_t</code></strong>.</p>
<p><strong><code>ptrdiff_t</code></strong> - тип для разности двух указателей (<code>signed</code>)</p>
<p>Как выбирать целочисленный тип:</p>
<ul>
<li>если данные приходят из существующей функции или уходят в неё, то используем тот же тип, что там.</li>
<li>если  используется как размер или индекс в контейнере - <code>size_t</code> и <code>ptrdiff_t</code>.</li>
<li>если знаем, оцениваем размер.</li>
</ul>
<h3><a class="header" href="#Типы-с-плавающей-точкой" id="Типы-с-плавающей-точкой">Типы с плавающей точкой:</a></h3>
<table><thead><tr><th>тип</th><th>размер (обычно)</th></tr></thead><tbody>
<tr><td>float</td><td>32</td></tr>
<tr><td>double</td><td>64</td></tr>
<tr><td>long double</td><td>64/80</td></tr>
</tbody></table>
<p>Разделение на мантиссу и экспоненту фиксировано в стандарте <a href="https://standards.ieee.org/standard/754-2019.html">IEEE-754</a></p>
<p><a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D1%85_%D1%87%D0%B8%D1%81%D0%B5%D0%BB">Подробнее на викиконспектах</a> - про денормализованные числа, <code>nan</code>, <code>inf</code> и всё такое.</p>
<p>Стоит заметить, что из-за особенностей чисел с плавающей точкой (из-за <code>nan</code> и <code>inf</code>) всякие <code>0 * a</code> и <code>a - a</code> не заменяются при компиляции на <code>0</code>.</p>
<p>А ещё сравнения с <code>nan</code> это всегда <code>false</code>, поэтому нужно быть аккуратнее.</p>
<blockquote>
<p><a href="https://www.itu.dk/%7Esestoft/bachelor/IEEE754_article.pdf">David Golberg, What Every Computer Scientist Should Know About Floating-Point Arithmetic</a></p>
<p><a href="http://notabs.org/fpuaccuracy/">Intel overstates FPU accuracy</a></p>
</blockquote>
<h2><a class="header" href="#Структуры-и-указатели" id="Структуры-и-указатели">Структуры и указатели:</a></h2>
<ol>
<li><strong>Структура</strong></li>
</ol>
<pre><code class="language-c++">struct point {
	float x;
	float y;
	float z;
};

// обращение к полям:
void f (point p) {
	p.x = 5;
}
</code></pre>
<p>Данные структуры хранятся подряд (с точностью до выравнивания).</p>
<p><a href="https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">Интересное про sizeof от структуры</a></p>
<p>А ещё<code>sizeof</code> возвращает столько, сколько структура занимает, когда она лежит в массиве.</p>
<ol start="2">
<li><strong>Указатель</strong> - &quot;номер ячейки памяти&quot; (важно указывать, какой тип, но эта информация используется на уровне компилятора). Все указатели имеют одинаковый размер - битность системы.</li>
</ol>
<pre><code class="language-c++">int a;
int *a;
long *a;
int *p = &amp;a;	// &amp; - взятие адреса
*p = 42;	// * - разыменования указателя
// обращение к полям структуры по указателю:
void f (point* p) {
    (*p).x = 5;
    p-&gt;x = 5;		// эквивалентно
}
</code></pre>
<ol start="3">
<li><strong>Массивы</strong> </li>
</ol>
<pre><code class="language-c++">int* a[10]; // массив указателей
char buf[4096];
char* p = buf; // неявное приведение массива к указателю на первый элемент
</code></pre>
<p>Функции, принимающие массив фиксированного размера лучше не писать, компилятор все равно изменит на применяющую указатель.</p>
<pre><code class="language-c++">void f(int a[10]){}
// компилируется в 
void f(int* a){}
</code></pre>
<h3><a class="header" href="#Арифметика-указателей" id="Арифметика-указателей">Арифметика указателей</a></h3>
<pre><code class="language-c++">int *p;
int n;
p += n; // добавить к указателю
p -= n; // вычесть из указателя
ptrdiff_t ans = p - q // разность указателей - количество элементов между ними (знаковое)
</code></pre>
<pre><code class="language-c++">for (int* p = a; p != a + 10; ++p)
int* b[10];   // массив указателей
int (*b)[10]; // указатель на массив, приоритет показываем скобками
</code></pre>
<p>Суффиксные модификаторы имеют больший приоритет.</p>
<h3><a class="header" href="#Указатели-на-функции" id="Указатели-на-функции">Указатели на функции:</a></h3>
<pre><code class="language-c++">int* f () {}        //  функция возвращает указатель
int f(int);
int (*g)(int) = &amp;f; // указатель на функцию f, сработает и без &amp;
g(5);               // можно вызывать указатель на функцию, как функцию. 
// пример использования: передавать компаратор в sort
</code></pre>
<p><strong>Разное про указатели:</strong></p>
<pre><code class="language-c++">int a[50];
int* p = a;
p[20] = 5; // *(p+20) = 5
20[p] = 5; // так тоже можно, но не нужно	

// Указатель на void может хранить 
// любой другой указатель(другого типа)
</code></pre>
<h3><a class="header" href="#Мем-про-switch" id="Мем-про-switch">Мем про switch:</a></h3>
<pre><code class="language-c++">void f(int a) {
	switch(a) {
	case 1:
		printf(&quot;1&quot;);
		if (false)
	case 2:
		printf(&quot;2&quot;);
		if (false)
	case 3:
		printf(&quot;3);
	}
}
</code></pre>
<p>Код работает корректно, но писать так не надо. </p>
<h3><a class="header" href="#lvalue-rvalue" id="lvalue-rvalue">lvalue, rvalue</a></h3>
<pre><code class="language-c++">int a;
(a + 1) = 42; // почему не скомпилится?
</code></pre>
<p><strong>lvalue</strong> - то, что может стоять слева от оператора присваивания.</p>
<p><strong>rvalue</strong> - &quot;временные объекты&quot;, им нельзя что-то присваивать.</p>
<p>Например, <code>a</code> - lvalue, <code>(a+1)</code> - rvalue.</p>
<pre><code class="language-c++">&amp;a;          // валидно
&amp;5;          // невалидно, так как 5 - rvalue
&amp;&amp;a;         // нельзя, так как &amp;a - rvalue
++a;         // увеличивает и возвращает по ссылке
a++;         // возвращает копию, а потом увеличивает исходное
a++++;       // так нельзя, так как a++ - rvalue
++++a;       // в C++ так можно, так как ++a - lvalue, в C так нельзя
++a++;       // суффиксный оператор имеет приоритет, поэтому не компилируется (как ++(a++))
+++a;        // первые ++ отдельно парсятся и это не компилится
(a = 5) = 6; // так можно, так как оператор = возвращает lvalue
a = b = c;   // равносильно a = (b = c)
</code></pre>
<h3><a class="header" href="#Приведение-типов" id="Приведение-типов">Приведение типов:</a></h3>
<p>Приведение происходит к более &quot;общему типу&quot;:</p>
<pre><code class="language-c++">5;         // int
5L;        // long
5LL;       // long long
'5';       // char
'5' + 1;   // int
'5' + '6'; // int
1+2L;      // long
1 + 1u;    // unsigned
</code></pre>
<p><img src="https://www.cdn.geeksforgeeks.org/wp-content/uploads/Implicit-Type-Conversion-in-c.png" alt="Image result for c++ types conversion explicit" /></p>
<h1><a class="header" href="#Синтаксическое-пересечение-c-и-c-1" id="Синтаксическое-пересечение-c-и-c-1">Синтаксическое пересечение C и C++</a></h1>
<h2><a class="header" href="#Типы-данных-1" id="Типы-данных-1">Типы данных</a></h2>
<h3><a class="header" href="#Целочисленные-1" id="Целочисленные-1">Целочисленные:</a></h3>
<pre><code class="language-c++">signed int // по умолчанию тип знаковый, то же самое, что и int
// типы и их беззнаковые варианты:
short		unsigned short
int		unsigned
long		unsigned long
long long	unsigned long long
</code></pre>
<p>Стандарт не приписывает конкретных размеров типа, гарантирует только, что не меньше. Размеры типов прописаны в ABI архитектуры.</p>
<table><thead><tr><th>типы</th><th>32 bit</th><th>win64</th><th>linux64</th></tr></thead><tbody>
<tr><td>short</td><td>8</td><td>8</td><td>8</td></tr>
<tr><td>short</td><td>16</td><td>16</td><td>16</td></tr>
<tr><td>int</td><td>32</td><td>32</td><td>32</td></tr>
<tr><td>long</td><td>32</td><td>32</td><td>64</td></tr>
<tr><td>long long</td><td>64</td><td>64</td><td>64</td></tr>
</tbody></table>
<p><strong>8-битные типы</strong></p>
<pre><code class="language-c++">// это 3 разных типа, в отличие от int и signed int
char    // может быть как знаковый, так и нет
unsigned char			
signed char
</code></pre>
<p>Как проверить, одинаковые ли типы? Перегрузить функцию.</p>
<pre><code class="language-c++">void foo(int){}
void foo(signed int){} // не скомпилируется, так как две функции с одинаковой сигнатурой
</code></pre>
<pre><code class="language-c++">void foo(char){}
void foo(signed char){} // скомпилируется
</code></pre>
<p><strong>Существуют типы с фиксированным размером:</strong>
Следует использовать их, если хотим тип гарантированного размера:</p>
<pre><code class="language-c++">#inlcude &lt;cstdint&gt;
int8_t			uint8_t
int16_t			uint16_t
int32_t			uint32_t
int64_t			uint64_t
</code></pre>
<pre><code class="language-c++">arr[i]; // какого типа нужно брать i?
#inlcude &lt;cstddef&gt; // в ней лежат нужные типы
</code></pre>
<p><strong><code>size_t</code></strong> - тип, размера которого хватит, чтобы хранить максимальный размер;<br />
он <code>unsigned</code> (размер на 32bit - 32, на 64bit - 64), у <strong><code>sizeof(...)</code></strong> тип <strong><code>size_t</code></strong>.</p>
<p><strong><code>ptrdiff_t</code></strong> - тип для разности двух указателей (<code>signed</code>)</p>
<p>Как выбирать целочисленный тип:</p>
<ul>
<li>если данные приходят из существующей функции или уходят в неё, то используем тот же тип, что там.</li>
<li>если  используется как размер или индекс в контейнере - <code>size_t</code> и <code>ptrdiff_t</code>.</li>
<li>если знаем, оцениваем размер.</li>
</ul>
<h3><a class="header" href="#Типы-с-плавающей-точкой-1" id="Типы-с-плавающей-точкой-1">Типы с плавающей точкой:</a></h3>
<table><thead><tr><th>тип</th><th>размер (обычно)</th></tr></thead><tbody>
<tr><td>float</td><td>32</td></tr>
<tr><td>double</td><td>64</td></tr>
<tr><td>long double</td><td>64/80</td></tr>
</tbody></table>
<p>Разделение на мантиссу и экспоненту фиксировано в стандарте <a href="https://standards.ieee.org/standard/754-2019.html">IEEE-754</a></p>
<p><a href="https://neerc.ifmo.ru/wiki/index.php?title=%D0%9F%D1%80%D0%B5%D0%B4%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%B2%D0%B5%D1%89%D0%B5%D1%81%D1%82%D0%B2%D0%B5%D0%BD%D0%BD%D1%8B%D1%85_%D1%87%D0%B8%D1%81%D0%B5%D0%BB">Подробнее на викиконспектах</a> - про денормализованные числа, <code>nan</code>, <code>inf</code> и всё такое.</p>
<p>Стоит заметить, что из-за особенностей чисел с плавающей точкой (из-за <code>nan</code> и <code>inf</code>) всякие <code>0 * a</code> и <code>a - a</code> не заменяются при компиляции на <code>0</code>.</p>
<p>А ещё сравнения с <code>nan</code> это всегда <code>false</code>, поэтому нужно быть аккуратнее.</p>
<blockquote>
<p><a href="https://www.itu.dk/%7Esestoft/bachelor/IEEE754_article.pdf">David Golberg, What Every Computer Scientist Should Know About Floating-Point Arithmetic</a></p>
<p><a href="http://notabs.org/fpuaccuracy/">Intel overstates FPU accuracy</a></p>
</blockquote>
<h2><a class="header" href="#Структуры-и-указатели-1" id="Структуры-и-указатели-1">Структуры и указатели:</a></h2>
<ol>
<li><strong>Структура</strong></li>
</ol>
<pre><code class="language-c++">struct point {
	float x;
	float y;
	float z;
};

// обращение к полям:
void f (point p) {
	p.x = 5;
}
</code></pre>
<p>Данные структуры хранятся подряд (с точностью до выравнивания).</p>
<p><a href="https://stackoverflow.com/questions/119123/why-isnt-sizeof-for-a-struct-equal-to-the-sum-of-sizeof-of-each-member">Интересное про sizeof от структуры</a></p>
<p>А ещё<code>sizeof</code> возвращает столько, сколько структура занимает, когда она лежит в массиве.</p>
<ol start="2">
<li><strong>Указатель</strong> - &quot;номер ячейки памяти&quot; (важно указывать, какой тип, но эта информация используется на уровне компилятора). Все указатели имеют одинаковый размер - битность системы.</li>
</ol>
<pre><code class="language-c++">int a;
int *a;
long *a;
int *p = &amp;a;	// &amp; - взятие адреса
*p = 42;	// * - разыменования указателя
// обращение к полям структуры по указателю:
void f (point* p) {
    (*p).x = 5;
    p-&gt;x = 5;		// эквивалентно
}
</code></pre>
<ol start="3">
<li><strong>Массивы</strong> </li>
</ol>
<pre><code class="language-c++">int* a[10]; // массив указателей
char buf[4096];
char* p = buf; // неявное приведение массива к указателю на первый элемент
</code></pre>
<p>Функции, принимающие массив фиксированного размера лучше не писать, компилятор все равно изменит на применяющую указатель.</p>
<pre><code class="language-c++">void f(int a[10]){}
// компилируется в 
void f(int* a){}
</code></pre>
<h3><a class="header" href="#Арифметика-указателей-1" id="Арифметика-указателей-1">Арифметика указателей</a></h3>
<pre><code class="language-c++">int *p;
int n;
p += n; // добавить к указателю
p -= n; // вычесть из указателя
ptrdiff_t ans = p - q // разность указателей - количество элементов между ними (знаковое)
</code></pre>
<pre><code class="language-c++">for (int* p = a; p != a + 10; ++p)
int* b[10];   // массив указателей
int (*b)[10]; // указатель на массив, приоритет показываем скобками
</code></pre>
<p>Суффиксные модификаторы имеют больший приоритет.</p>
<h3><a class="header" href="#Указатели-на-функции-1" id="Указатели-на-функции-1">Указатели на функции:</a></h3>
<pre><code class="language-c++">int* f () {}        //  функция возвращает указатель
int f(int);
int (*g)(int) = &amp;f; // указатель на функцию f, сработает и без &amp;
g(5);               // можно вызывать указатель на функцию, как функцию. 
// пример использования: передавать компаратор в sort
</code></pre>
<p><strong>Разное про указатели:</strong></p>
<pre><code class="language-c++">int a[50];
int* p = a;
p[20] = 5; // *(p+20) = 5
20[p] = 5; // так тоже можно, но не нужно	

// Указатель на void может хранить 
// любой другой указатель(другого типа)
</code></pre>
<h3><a class="header" href="#Мем-про-switch-1" id="Мем-про-switch-1">Мем про switch:</a></h3>
<pre><code class="language-c++">void f(int a) {
	switch(a) {
	case 1:
		printf(&quot;1&quot;);
		if (false)
	case 2:
		printf(&quot;2&quot;);
		if (false)
	case 3:
		printf(&quot;3);
	}
}
</code></pre>
<p>Код работает корректно, но писать так не надо. </p>
<h3><a class="header" href="#lvalue-rvalue-1" id="lvalue-rvalue-1">lvalue, rvalue</a></h3>
<pre><code class="language-c++">int a;
(a + 1) = 42; // почему не скомпилится?
</code></pre>
<p><strong>lvalue</strong> - то, что может стоять слева от оператора присваивания.</p>
<p><strong>rvalue</strong> - &quot;временные объекты&quot;, им нельзя что-то присваивать.</p>
<p>Например, <code>a</code> - lvalue, <code>(a+1)</code> - rvalue.</p>
<pre><code class="language-c++">&amp;a;          // валидно
&amp;5;          // невалидно, так как 5 - rvalue
&amp;&amp;a;         // нельзя, так как &amp;a - rvalue
++a;         // увеличивает и возвращает по ссылке
a++;         // возвращает копию, а потом увеличивает исходное
a++++;       // так нельзя, так как a++ - rvalue
++++a;       // в C++ так можно, так как ++a - lvalue, в C так нельзя
++a++;       // суффиксный оператор имеет приоритет, поэтому не компилируется (как ++(a++))
+++a;        // первые ++ отдельно парсятся и это не компилится
(a = 5) = 6; // так можно, так как оператор = возвращает lvalue
a = b = c;   // равносильно a = (b = c)
</code></pre>
<h3><a class="header" href="#Приведение-типов-1" id="Приведение-типов-1">Приведение типов:</a></h3>
<p>Приведение происходит к более &quot;общему типу&quot;:</p>
<pre><code class="language-c++">5;         // int
5L;        // long
5LL;       // long long
'5';       // char
'5' + 1;   // int
'5' + '6'; // int
1+2L;      // long
1 + 1u;    // unsigned
</code></pre>
<p><img src="https://www.cdn.geeksforgeeks.org/wp-content/uploads/Implicit-Type-Conversion-in-c.png" alt="Image result for c++ types conversion explicit" /></p>
<h1><a class="header" href="#Запись-1-2" id="Запись-1-2">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-2" id="Запись-2-2">Запись №2</a></h1>
<h1><a class="header" href="#Процесс-компиляции-программ" id="Процесс-компиляции-программ">Процесс компиляции программ</a></h1>
<p><img src="./images/03.28_compilation_graph.png" alt="Compilation graph" /></p>
<p>Классическая схема этапов компиляции. 
Есть <a href="https://habr.com/ru/post/478124/">похожая статья на хабре</a>.</p>
<p><strong>Preprocessing</strong>
<code>g++ -E -P 1.cpp -o 1.i</code></p>
<p>Выполняет директивы (<code>#define</code>, <code>#include</code> и другие).</p>
<p><code>#include</code> - вставляет текст из указанного файла
<code>#define</code> - задает макрос</p>
<p><strong>Translation</strong>
<code>g++ -S -masm=intel 1.i -o 1.s</code></p>
<p>Трансляция кода в ассемблер.</p>
<p><strong>Assembling</strong>
<code>g++ -C 1.s -o 1.o</code> (либо <code>as ...</code>)</p>
<p>Транслирует ассемблерный код в машинный код.</p>
<p><code>*.o</code> - объектный файл</p>
<p><strong>Linking</strong>
<code>g++ 1.o -o program</code> (либо <code>ld ...</code>)</p>
<p>Связывает все объектные файлы и библиотеки в один исполняемый файл.
После этого этапа можно запускать <code>./program</code>.</p>
<p><code>*.cpp</code> файлы так же называют единицами трансляции</p>
<p>Пример линкования файликов:</p>
<pre><code class="language-c++">// a.cpp:						
int main() {					
	f();						
}
// b.cpp:
#include&lt;cstdio&gt;
void f() {
	prinf(&quot;Hello world&quot;);
}
</code></pre>
<p>Это не скомпилится, так как на этапе до линковки компилятор не знает о существовании <code>f()</code> где то вне <code>a.cpp</code>, поэтому ее надо объявить:</p>
<pre><code class="language-c++">// a.cpp:						
void f();					
int main() {		
	f();						
}
// b.cpp:
#include&lt;cstdio&gt;
void f() {
	prinf(&quot;Hello world&quot;);
}
</code></pre>
<p>Для линковки вместе<code>g++ a.o b.o</code></p>
<ul>
<li>Функцию нужно объявлять до её вызова.</li>
<li>Если в обеих программах есть main, то невозможно будет слинковать (какой main запускать?)</li>
<li>В main можно не делать <code>return</code>, по умолчанию вернёт 0.</li>
<li>Можно писать функцию на ассемблере и вызывать из <code>*.cpp</code> файла, потому что на этапе линковки нет разницы.</li>
<li>Во всех единицах трансляции только одно определение.</li>
<li>Функцию нужно объявлять до её использования. Если она описана ниже, то транслятор не увидит её и кинет ошибку.</li>
</ul>
<h3><a class="header" href="#Некоторые-ключевые-слова" id="Некоторые-ключевые-слова">Некоторые ключевые слова</a></h3>
<p><strong><code>static</code></strong> - переменная или функция - &quot;не предоставляется наружу&quot;, видна только в одной единице трансляции. При этом если в другой единице есть функция с такой же сигнатурой, но в текущей единице она <code>static</code>, то не будет проблемы с multiple definition, а в текущей единице трансляции выберется <code>static</code>. </p>
<p>Для функций <code>void f();</code> это объявление (declaration), а <code>void f(){}</code> -- определение (definition).<br />
Для переменных немного иначе: <br />
<strong><code>int a</code></strong> - определение <br />
<strong><code>extern int a</code></strong> - объявление (означает, что переменная объявлена где-то снаружи).</p>
<p>Глобальные переменные инициализируются нулями при определении, в отличие от локальных.</p>
<p>Можно заметить, что при линковке нам не важно, откуда приходят функции, исходный код одной из единиц трансляций может быть сразу на ассемблере:</p>
<pre><code class="language-c++">extern &quot;C&quot; uint32_t fibonacci(uint32_t n);
// определена, например, в .s файле, но должны выполняться calling conventions
</code></pre>
<p><strong><code>extern &quot;C&quot; f</code></strong> - использовать СИшное имя функции. На имена функций можно посмотреть так: <code>nm a.o</code>, <code>nm -C a.o</code>.<br />
В Си имя функции выглядит как <code>f</code>, в C++ как <code>_Z1fd</code>, где <code>d</code> - типа аргумента, который она принимает (тут <code>double</code>).<br />
Это связано с тем, что в Си нет перегрузки функций, поэтому там имена функций не декорируются типами их аргументов. <br />
У функций с разными сигнатурами, но помеченных как <code>extern &quot;C&quot;</code>, после компиляции не будет информации об типах их аргументов, поэтому это даже слинкуется, но работать не будет (ну либо будет, но тут UB, так как, например, типы аргументов ожидаются разные).</p>
<p>Возьмём теперь объявление <code>printf</code> из <code>cstdio</code> и вставим его вручную:</p>
<pre><code class="language-c++">extern &quot;C&quot; int printf(const char*, ...);
int main() {
	printf(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Такая программа тоже работает. Откуда берётся <code>printf</code>? Ответ кроется в том, что при компиляции командой <code>g++ -c b.cpp</code> вызывается команда линковки <code>ld</code> с ключом, из-за которого файл линкуется с объектными файлами из стандартной библиотеки. Если посмотреть, то можно заметить, что наш файл линкуется с несколькими другими 
объектными файлами, один из которых содержит функцию <code>_start</code> (это может быть файл <code>crt1.o</code>), которая вызывает <code>main</code>.</p>
<h2><a class="header" href="#headers" id="headers">Headers</a></h2>
<p><code>2.h</code> - файлы не участвующие в компиляции, в них пишут объявления функций. Не нужно делать  <code>#include file.cpp</code>, а в <code>.h</code> не нужно определять функции.</p>
<p>Зачем это нужно? Как сказано выше, во всех единицах трансляции может быть только одно определение функции, потому что иначе получим redefinition error, так как компилятор не сможет выбрать из нескольких определений функции одно. Поэтому делаем на все единицы трансляции одно определение в <code>.cpp</code> файле, в хедерах объявления. Теперь, когда мы будем инклудить хедеры в другие единицы трансляции, у нас будет в них появляться только объявление функций из хедера.</p>
<p>Структуры/классы пишем в <code>.h</code>. При этом их методы можно определять там же, потому что они воспринимаются компилятором как <code>inline</code>.</p>
<p>Посмотрим на то, как работает <code>#include</code>:</p>
<pre><code class="language-c++">// x.h:
struct x {}; 
// y.h:
#include &quot;x.h&quot;
// z.h:
#include &quot;x.h&quot;

a.cpp:							
#include &quot;y.h&quot;		--&gt;		struct x{};
#include &quot;z.h&quot;				struct x{}; //ошибка компиляции
</code></pre>
<p>Решение:</p>
<ol>
<li><code>#include &quot;x.h&quot;</code> не писать в хедерах, а только по необходимости в .cpp (не очень решение)</li>
<li>
<pre><code class="language-c++"> // x.h:
 #ifndef X_H
 #define X_H		// - макрос
 struct x{};
 #endif
</code></pre>
Это решение называется <strong>include guard</strong>
Тогда при <code>#include x.h</code> будет проверка, заинклудили ли его уже и не будет проблем.</li>
<li>Директива  <code>#pragma once</code> - стандарт не поддерживает, но поддерживают, кажется, все компиляторы. Эффект как у <strong>include guard</strong>, но проще писать и нет проблемы с тем, что можем еще где-то сделать лишний <code>#define X_H</code></li>
</ol>
<p>Если меняется <em>header</em>, то необходимо перекомпилировать все файлы, которые подключают его (даже не непосредственно), что может быть неприятно.</p>
<pre><code class="language-c++">#define PI 3.14 
// препроцессор подставляет вместо PI 3.14
</code></pre>
<p>Макросы обычно пишут капсом</p>
<h2><a class="header" href="#Про-структуры" id="Про-структуры">Про структуры</a></h2>
<p>Хотим две структуры в разных хедерах <code>a.h</code> и <code>b.h</code>. В структуре <code>a</code> указатель на структуру <code>b</code> и наоборот.</p>
<pre><code class="language-c++">// main.cpp:
#include &quot;a.h&quot;
#include &quot;b.h&quot;
</code></pre>
<p>Если в <code>a.h</code> инклудится <code>b.h</code> и наоборот, то получим ошибку во время компиляции. Как фиксить? </p>
<p>Если нам не требуется знать, что находится внутри структуры, можно использовать <strong>forward declaration</strong>. Например, <code>a.h</code> будет выглядеть так:</p>
<pre><code class="language-c++">struct b;
struct a {
	b* bb;
};
</code></pre>
<p><strong>Важно</strong>: избегайте циклических инклудов, чаще всего это приводит к ошибкам.</p>
<p>Пока структуру не определили, структура - это <strong>incomplete type</strong>. Например, на момент объявление <code>struct b;</code> в коде выше, <code>b</code> - incomplete. 
Все, что можно с ними делать - это объявлять функции с их использованим и использовать указатель. 
Становятся полным типом после определения.</p>
<p>Бонусом с <strong>forward declaration</strong> получаем, что нужно меньше перекомпилировать, так как меньше инклудов.</p>
<p>А теперь такой пример:</p>
<pre><code class="language-c++">// a.cpp
#include &lt;iostream&gt;
struct x {
	int a;
	// padding
	double b;
	int c;
	int d;
}
int main(){
	x xx = f();
	std::cout &lt;&lt; xx.a &lt;&lt; &quot; &quot; &lt;&lt; xx.b &lt;&lt; &quot; &quot; &lt;&lt; xx.c &lt;&lt; &quot; &quot; &lt;&lt; xx.d &lt;&lt; &quot;\n&quot;;
}

// b.cpp
struct x {
	int a;
	int b;
	int c;
	int d;
	int e;
};

x f() {
	x result;
	result.a = 1;
	result.b = 2;
	result.c = 3;
	result.d = 4;
	result.e = 5;
}
</code></pre>
<p>Тут стоит вспомнить, что структуры при линковке не играют никакой роли, то есть линковщику всё равно, что у нас структура <code>x</code> определена в двух местах. Поэтому такая программа отлично скомпилируется и запустится, но есть одна проблема. В <code>b.cpp</code> определение функции <code>f</code> скомпилируется с учётом смещений в структуре, определённой в этой же единице трансляции, то есть будто там лежит 5 интов.</p>
<p>Поэтому следует придерживаться правила определять структуры один раз и не писать разные структуры с одним названием.</p>
<h2><a class="header" href="#inline" id="inline">Inline</a></h2>
<p>Компилятор сам умеет подставлять тело функций, но только внутри одной единицы трансляции (так как на момент трансляции у него нет функций из других единиц). Проблему с тем, что у нас не может быть больше одного определения функции во всех единицах трансляции, решает следующий модификатор:</p>
<p><strong><code>inline</code></strong> - <em>рекомендация</em> компилятору заинлайнить функцию (подставить её тело). Их нужно определять в хедере и инклудить во все единицы трансляции, где нужно их использовать. На самом деле, современные компиляторы почти всегда игнорируют изначальный смысл <code>inline</code>. У компиляторов есть свои эвристки (размер функции, насколько упростится код и т.д.), по которым он считает, насколько функцию выгодно подставить. Поэтому <code>inline</code> пользуются только из-за следующего свойства: для функции, помеченной <code>inline</code>, возможно повторное определение, линковщик в таком случае оставляет только одно, предполагая, что они все одинаковые.</p>
<p>Сейчас у компиляторов есть такая вещь, как <em>link time optimization</em> (ключ компиляции <code>-flto</code>). Компилятор не пытается генерить код на стадии трансляции, генерит там только внутренний промежуточный код, его же записывает в объектные файлы, а затем на стадии линковки инлайнит функции между единицами трансляции и генерит настоящий код. В таком случае линковка может занимать много времени, поэтому применяется при сборке с оптимизациями.</p>
<p>Если у <code>inline</code> функции несколько разных определений, то линковщик выберет произвольное из них (например, из первой единицы трансляции или вообще разные в разных местах), поэтому нельзя нарушать правило одинаковых определений для <code>inline</code> функций. </p>
<p>Если нужно именно заинлайнить функцию, то есть нестандартизированные модификаторы типа <code>__forceinline</code>, однако даже они могут игнорироваться компилятором. Инлайнинг функции может снизить производительность, на эту тему можно послушать доклад <a href="https://youtu.be/rJWSSWYL83U?t=1970">Антона Полухина на C++ Russia 2017</a>.</p>
<h1><a class="header" href="#Процесс-компиляции-программ-1" id="Процесс-компиляции-программ-1">Процесс компиляции программ</a></h1>
<p><img src="./images/03.28_compilation_graph.png" alt="Compilation graph" /></p>
<p>Классическая схема этапов компиляции. 
Есть <a href="https://habr.com/ru/post/478124/">похожая статья на хабре</a>.</p>
<p><strong>Preprocessing</strong>
<code>g++ -E -P 1.cpp -o 1.i</code></p>
<p>Выполняет директивы (<code>#define</code>, <code>#include</code> и другие).</p>
<p><code>#include</code> - вставляет текст из указанного файла
<code>#define</code> - задает макрос</p>
<p><strong>Translation</strong>
<code>g++ -S -masm=intel 1.i -o 1.s</code></p>
<p>Трансляция кода в ассемблер.</p>
<p><strong>Assembling</strong>
<code>g++ -C 1.s -o 1.o</code> (либо <code>as ...</code>)</p>
<p>Транслирует ассемблерный код в машинный код.</p>
<p><code>*.o</code> - объектный файл</p>
<p><strong>Linking</strong>
<code>g++ 1.o -o program</code> (либо <code>ld ...</code>)</p>
<p>Связывает все объектные файлы и библиотеки в один исполняемый файл.
После этого этапа можно запускать <code>./program</code>.</p>
<p><code>*.cpp</code> файлы так же называют единицами трансляции</p>
<p>Пример линкования файликов:</p>
<pre><code class="language-c++">// a.cpp:						
int main() {					
	f();						
}
// b.cpp:
#include&lt;cstdio&gt;
void f() {
	prinf(&quot;Hello world&quot;);
}
</code></pre>
<p>Это не скомпилится, так как на этапе до линковки компилятор не знает о существовании <code>f()</code> где то вне <code>a.cpp</code>, поэтому ее надо объявить:</p>
<pre><code class="language-c++">// a.cpp:						
void f();					
int main() {		
	f();						
}
// b.cpp:
#include&lt;cstdio&gt;
void f() {
	prinf(&quot;Hello world&quot;);
}
</code></pre>
<p>Для линковки вместе<code>g++ a.o b.o</code></p>
<ul>
<li>Функцию нужно объявлять до её вызова.</li>
<li>Если в обеих программах есть main, то невозможно будет слинковать (какой main запускать?)</li>
<li>В main можно не делать <code>return</code>, по умолчанию вернёт 0.</li>
<li>Можно писать функцию на ассемблере и вызывать из <code>*.cpp</code> файла, потому что на этапе линковки нет разницы.</li>
<li>Во всех единицах трансляции только одно определение.</li>
<li>Функцию нужно объявлять до её использования. Если она описана ниже, то транслятор не увидит её и кинет ошибку.</li>
</ul>
<h3><a class="header" href="#Некоторые-ключевые-слова-1" id="Некоторые-ключевые-слова-1">Некоторые ключевые слова</a></h3>
<p><strong><code>static</code></strong> - переменная или функция - &quot;не предоставляется наружу&quot;, видна только в одной единице трансляции. При этом если в другой единице есть функция с такой же сигнатурой, но в текущей единице она <code>static</code>, то не будет проблемы с multiple definition, а в текущей единице трансляции выберется <code>static</code>. </p>
<p>Для функций <code>void f();</code> это объявление (declaration), а <code>void f(){}</code> -- определение (definition).<br />
Для переменных немного иначе: <br />
<strong><code>int a</code></strong> - определение <br />
<strong><code>extern int a</code></strong> - объявление (означает, что переменная объявлена где-то снаружи).</p>
<p>Глобальные переменные инициализируются нулями при определении, в отличие от локальных.</p>
<p>Можно заметить, что при линковке нам не важно, откуда приходят функции, исходный код одной из единиц трансляций может быть сразу на ассемблере:</p>
<pre><code class="language-c++">extern &quot;C&quot; uint32_t fibonacci(uint32_t n);
// определена, например, в .s файле, но должны выполняться calling conventions
</code></pre>
<p><strong><code>extern &quot;C&quot; f</code></strong> - использовать СИшное имя функции. На имена функций можно посмотреть так: <code>nm a.o</code>, <code>nm -C a.o</code>.<br />
В Си имя функции выглядит как <code>f</code>, в C++ как <code>_Z1fd</code>, где <code>d</code> - типа аргумента, который она принимает (тут <code>double</code>).<br />
Это связано с тем, что в Си нет перегрузки функций, поэтому там имена функций не декорируются типами их аргументов. <br />
У функций с разными сигнатурами, но помеченных как <code>extern &quot;C&quot;</code>, после компиляции не будет информации об типах их аргументов, поэтому это даже слинкуется, но работать не будет (ну либо будет, но тут UB, так как, например, типы аргументов ожидаются разные).</p>
<p>Возьмём теперь объявление <code>printf</code> из <code>cstdio</code> и вставим его вручную:</p>
<pre><code class="language-c++">extern &quot;C&quot; int printf(const char*, ...);
int main() {
	printf(&quot;Hello, world!&quot;);
}
</code></pre>
<p>Такая программа тоже работает. Откуда берётся <code>printf</code>? Ответ кроется в том, что при компиляции командой <code>g++ -c b.cpp</code> вызывается команда линковки <code>ld</code> с ключом, из-за которого файл линкуется с объектными файлами из стандартной библиотеки. Если посмотреть, то можно заметить, что наш файл линкуется с несколькими другими 
объектными файлами, один из которых содержит функцию <code>_start</code> (это может быть файл <code>crt1.o</code>), которая вызывает <code>main</code>.</p>
<h2><a class="header" href="#headers-1" id="headers-1">Headers</a></h2>
<p><code>2.h</code> - файлы не участвующие в компиляции, в них пишут объявления функций. Не нужно делать  <code>#include file.cpp</code>, а в <code>.h</code> не нужно определять функции.</p>
<p>Зачем это нужно? Как сказано выше, во всех единицах трансляции может быть только одно определение функции, потому что иначе получим redefinition error, так как компилятор не сможет выбрать из нескольких определений функции одно. Поэтому делаем на все единицы трансляции одно определение в <code>.cpp</code> файле, в хедерах объявления. Теперь, когда мы будем инклудить хедеры в другие единицы трансляции, у нас будет в них появляться только объявление функций из хедера.</p>
<p>Структуры/классы пишем в <code>.h</code>. При этом их методы можно определять там же, потому что они воспринимаются компилятором как <code>inline</code>.</p>
<p>Посмотрим на то, как работает <code>#include</code>:</p>
<pre><code class="language-c++">// x.h:
struct x {}; 
// y.h:
#include &quot;x.h&quot;
// z.h:
#include &quot;x.h&quot;

a.cpp:							
#include &quot;y.h&quot;		--&gt;		struct x{};
#include &quot;z.h&quot;				struct x{}; //ошибка компиляции
</code></pre>
<p>Решение:</p>
<ol>
<li><code>#include &quot;x.h&quot;</code> не писать в хедерах, а только по необходимости в .cpp (не очень решение)</li>
<li>
<pre><code class="language-c++"> // x.h:
 #ifndef X_H
 #define X_H		// - макрос
 struct x{};
 #endif
</code></pre>
Это решение называется <strong>include guard</strong>
Тогда при <code>#include x.h</code> будет проверка, заинклудили ли его уже и не будет проблем.</li>
<li>Директива  <code>#pragma once</code> - стандарт не поддерживает, но поддерживают, кажется, все компиляторы. Эффект как у <strong>include guard</strong>, но проще писать и нет проблемы с тем, что можем еще где-то сделать лишний <code>#define X_H</code></li>
</ol>
<p>Если меняется <em>header</em>, то необходимо перекомпилировать все файлы, которые подключают его (даже не непосредственно), что может быть неприятно.</p>
<pre><code class="language-c++">#define PI 3.14 
// препроцессор подставляет вместо PI 3.14
</code></pre>
<p>Макросы обычно пишут капсом</p>
<h2><a class="header" href="#Про-структуры-1" id="Про-структуры-1">Про структуры</a></h2>
<p>Хотим две структуры в разных хедерах <code>a.h</code> и <code>b.h</code>. В структуре <code>a</code> указатель на структуру <code>b</code> и наоборот.</p>
<pre><code class="language-c++">// main.cpp:
#include &quot;a.h&quot;
#include &quot;b.h&quot;
</code></pre>
<p>Если в <code>a.h</code> инклудится <code>b.h</code> и наоборот, то получим ошибку во время компиляции. Как фиксить? </p>
<p>Если нам не требуется знать, что находится внутри структуры, можно использовать <strong>forward declaration</strong>. Например, <code>a.h</code> будет выглядеть так:</p>
<pre><code class="language-c++">struct b;
struct a {
	b* bb;
};
</code></pre>
<p><strong>Важно</strong>: избегайте циклических инклудов, чаще всего это приводит к ошибкам.</p>
<p>Пока структуру не определили, структура - это <strong>incomplete type</strong>. Например, на момент объявление <code>struct b;</code> в коде выше, <code>b</code> - incomplete. 
Все, что можно с ними делать - это объявлять функции с их использованим и использовать указатель. 
Становятся полным типом после определения.</p>
<p>Бонусом с <strong>forward declaration</strong> получаем, что нужно меньше перекомпилировать, так как меньше инклудов.</p>
<p>А теперь такой пример:</p>
<pre><code class="language-c++">// a.cpp
#include &lt;iostream&gt;
struct x {
	int a;
	// padding
	double b;
	int c;
	int d;
}
int main(){
	x xx = f();
	std::cout &lt;&lt; xx.a &lt;&lt; &quot; &quot; &lt;&lt; xx.b &lt;&lt; &quot; &quot; &lt;&lt; xx.c &lt;&lt; &quot; &quot; &lt;&lt; xx.d &lt;&lt; &quot;\n&quot;;
}

// b.cpp
struct x {
	int a;
	int b;
	int c;
	int d;
	int e;
};

x f() {
	x result;
	result.a = 1;
	result.b = 2;
	result.c = 3;
	result.d = 4;
	result.e = 5;
}
</code></pre>
<p>Тут стоит вспомнить, что структуры при линковке не играют никакой роли, то есть линковщику всё равно, что у нас структура <code>x</code> определена в двух местах. Поэтому такая программа отлично скомпилируется и запустится, но есть одна проблема. В <code>b.cpp</code> определение функции <code>f</code> скомпилируется с учётом смещений в структуре, определённой в этой же единице трансляции, то есть будто там лежит 5 интов.</p>
<p>Поэтому следует придерживаться правила определять структуры один раз и не писать разные структуры с одним названием.</p>
<h2><a class="header" href="#inline-1" id="inline-1">Inline</a></h2>
<p>Компилятор сам умеет подставлять тело функций, но только внутри одной единицы трансляции (так как на момент трансляции у него нет функций из других единиц). Проблему с тем, что у нас не может быть больше одного определения функции во всех единицах трансляции, решает следующий модификатор:</p>
<p><strong><code>inline</code></strong> - <em>рекомендация</em> компилятору заинлайнить функцию (подставить её тело). Их нужно определять в хедере и инклудить во все единицы трансляции, где нужно их использовать. На самом деле, современные компиляторы почти всегда игнорируют изначальный смысл <code>inline</code>. У компиляторов есть свои эвристки (размер функции, насколько упростится код и т.д.), по которым он считает, насколько функцию выгодно подставить. Поэтому <code>inline</code> пользуются только из-за следующего свойства: для функции, помеченной <code>inline</code>, возможно повторное определение, линковщик в таком случае оставляет только одно, предполагая, что они все одинаковые.</p>
<p>Сейчас у компиляторов есть такая вещь, как <em>link time optimization</em> (ключ компиляции <code>-flto</code>). Компилятор не пытается генерить код на стадии трансляции, генерит там только внутренний промежуточный код, его же записывает в объектные файлы, а затем на стадии линковки инлайнит функции между единицами трансляции и генерит настоящий код. В таком случае линковка может занимать много времени, поэтому применяется при сборке с оптимизациями.</p>
<p>Если у <code>inline</code> функции несколько разных определений, то линковщик выберет произвольное из них (например, из первой единицы трансляции или вообще разные в разных местах), поэтому нельзя нарушать правило одинаковых определений для <code>inline</code> функций. </p>
<p>Если нужно именно заинлайнить функцию, то есть нестандартизированные модификаторы типа <code>__forceinline</code>, однако даже они могут игнорироваться компилятором. Инлайнинг функции может снизить производительность, на эту тему можно послушать доклад <a href="https://youtu.be/rJWSSWYL83U?t=1970">Антона Полухина на C++ Russia 2017</a>.</p>
<h1><a class="header" href="#Запись-1-3" id="Запись-1-3">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-3" id="Запись-2-3">Запись №2</a></h1>
<h1><a class="header" href="#Запись-3" id="Запись-3">Запись №3</a></h1>
<h1><a class="header" href="#Практика" id="Практика">Практика</a></h1>
<h1><a class="header" href="#Классы-абстракция-данных" id="Классы-абстракция-данных">Классы, абстракция данных</a></h1>
<p><a href="https://github.com/sorokin/cpp-course/blob/gh-pages/demos/string-demo/main.cpp">Примеры к лекции</a></p>
<h2><a class="header" href="#Структуры" id="Структуры">Структуры</a></h2>
<p>С помощью структур можно создавать свои типы. У структуры есть поля и методы. У полей и методов есть модификаторы доступа <code>public</code>, <code>private</code>, <code>protected</code>. По дефолту все поля и методы структуры - <code>public</code>.</p>
<p>Классы отличаются от структур только тем, что в классах по умолчанию все <code>private</code>, а в структурах <code>public</code>. Далее всё будет называться классами.</p>
<p>К полям класса можно обращать сразу через указатель на экземпляр:</p>
<pre><code class="language-c++">complex * c;
c-&gt;im // то же самое, что (*c).im
</code></pre>
<p>В отличие от языка <code>C</code>, в <code>C++</code> можно объявлять методы у структур.</p>
<pre><code class="language-c++">struct complex {
	void conjugate() {	
		im = -im;
	}
private:
	double re;
     double im;
};
</code></pre>
<p>Чем отличается метод внутри класса от такой функции?</p>
<pre><code class="language-c++">void conjugate(complex* c) {
	c-&gt;im = -c-&gt;im; 
}
</code></pre>
<ul>
<li>
<p>У метода есть неявный параметр - указатель <code>this</code> на текущий экземпляр.</p>
</li>
<li>
<p>Метод имеет доступ к приватным полям, внешняя функция - нет.</p>
</li>
</ul>
<h4><a class="header" href="#Что-должно-быть-private-а-что-public" id="Что-должно-быть-private-а-что-public">Что должно быть <code>private</code>, а что <code>public</code>?</a></h4>
<p>Инвариант класса - сохраняющиеся свойства класса. Например, инварианты структуры данных.</p>
<blockquote>
<p>То, что может испортить инвариант класса, должно быть private.</p>
</blockquote>
<p>Проверять инварианты можно ассертами (assert), но не стоит злоупотреблять ими, потому что это дорогоЮ могут быть полезны при дебаге и тестировании.</p>
<p>Обычно пишут объявления функций в <code>class.h</code>, а определения в <code>class.cpp</code>. Если определение функции сделано внутри класса, то она неявно помечается как inline, но мы не всегда хотим этого (дольше время компиляции из-за зависимостей и т.д.).</p>
<pre><code class="language-c++">// struct.h:
struct complex {
  void conjugate();
private:
  double re;
  double im;
}
// struct.cpp:
void complex::conjugate(){
	im = -im;
}
</code></pre>
<p>Как гарантировать какие-то свойства у объекта, который только создан? Это можно реализовать с помощью конструктора.</p>
<h2><a class="header" href="#Конструкторы" id="Конструкторы">Конструкторы</a></h2>
<p>Классы можно создавать через конструкторы.</p>
<pre><code class="language-c++">struct complex {
	complex(re, im) {
		this.re = re;
		this.im = im;
	}
	complex() {		// конструктор по умолчанию
		this.re = 0;
		this.im = 0;
	}
	void conjugate() {	
		im = -im;
	}
private:
	double re;
  double im;
};

void f(complex);
int main() {
	complex c; // вызывается конструктор по умолчанию
	complex d(1., 2.);
	f(complex(1., 2.));
}
</code></pre>
<p>Если в классе есть конструктор от одного аргумента, то может происходить неявное приведение типов (например, <code>big_integer a = 42</code>, если есть конструктор, который принимает <code>int</code>). Чтобы подавить такое поведение, конструктор нужно объявить с модификатором <code>explicit</code>.</p>
<p>Так же существуют деструкторы, освобождающие ресурсы при удалении объекта. Они вызываются когда объект выходит из &quot;зоны видимости&quot;:</p>
<pre><code class="language-C++">~string() {
	free(data);
	// ...
}

void foo() {
	string S;
} // вызовется деструктор S при выходе из функции
</code></pre>
<h2><a class="header" href="#Немного-про-const-и-указатели" id="Немного-про-const-и-указатели">Немного про const и указатели</a></h2>
<p>Ключевое слово <code>const</code> - неизменяемое. Относится к тому типу, который стоит слева от него. </p>
<pre><code class="language-c++">int const PI = 3;
int const* q = &amp;PI; 
// int* q = &amp;PI; - кинет ошибку
*q = 4;
	
int* a; - указатель на int
int const* b; - указатель на константный int
int* const b; - константный указатель на int
int const* const c; - константный указатель на константный int

int a = 42;
int const* p = &amp;a; // так тоже можно, но по этому указателю нельзя будет писать
</code></pre>
<p>В функцию, которая принимает указатель, нельзя передать указатель на <code>const</code>, а наоборот - можно.
Поэтому у аргументов функции полезно не забывать <code>const</code>, если функция не меняет принимаемый аргумент.</p>
<p>Константными могут быть не только стандартные типы,
У константных объектов можно вызывать только методы, помеченные <code>const</code>:</p>
<pre><code class="language-c++">struct complex {
	//...
	double real() const {
		&amp;re; // имеет тип double const *, так как метод const
		return re;
	}
}
int main(){
	complex const c(1.1, 2.2);
	c.re = 42; // так нельзя, так как у const структуры все поля const
	c.conjugate(); // так нельзя
	c.real(); // так можно
}
</code></pre>
<h2><a class="header" href="#Операторы" id="Операторы">Операторы</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/operators">cppreference: operator overloading</a></p>
<p>В С++ есть возможность определять собственные операторы для классов:</p>
<pre><code class="language-c++">complex operator+(complex a, complex b) {
	return complex(a.re + b.re, a.im + a.im)
}
</code></pre>
<p>Если вы пишете какой то оператор, то хотя бы один из его элементов должен быть пользовательским типом (нельзя переопределить оператор для <code>int, int</code>, но можно, например, для <code>vector</code> и <code>int</code>).</p>
<p>Еще пример:</p>
<pre><code class="language-c++">complex operator+=(complex a, complex b) {}
</code></pre>
<p>Мы такое сделать не можем, так как нужно поменять а, то есть передать его по указателю: <code>&amp;a += b</code>, что не очень естественно.
Сделать такое можно, используя ссылки:</p>
<table><thead><tr><th>указатель</th><th>ссылка</th></tr></thead><tbody>
<tr><td><code>int* p = &amp;a;</code></td><td><code>int&amp; r = a;</code></td></tr>
<tr><td><code>*p = 5;</code></td><td><code>r = 5;</code></td></tr>
<tr><td><code>int *pp = p</code></td><td><code>int* pr = &amp;r;</code></td></tr>
<tr><td><code>p-&gt;foo</code></td><td><code>p.foo;</code></td></tr>
<tr><td><code>p = &amp;b;</code></td><td><code>// нельзя перенаправить</code></td></tr>
</tbody></table>
<p>Нужно делать так:</p>
<pre><code class="language-c++">complex&amp; operator+=(complex &amp;a, complex b) { // возвращает ссылку, так что можно присвоить куда-то результат a += b;
	// поэтому можно (a += b) += c;
	return a = a + b;
}
</code></pre>
<p>Если мы принимаем экземпляр класса и нам не нужно его менять, можно передавать его по константной ссылке, тогда мы избегаем лишних копирований (в отличие от передачи по значению):</p>
<pre><code class="language-c++">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, complex const&amp; a) {
	os &lt;&lt; a.real &lt;&lt; &quot; + &quot; &lt;&lt; a.im &lt;&lt; &quot;i&quot;;
	return os;
}
</code></pre>
<p>Если функция принимает <code>const&amp;</code>, то в неё можно передавать временный объект (rvalue). Если же она принимает обычную ссылку, то только <code>lvalue</code>. <br />
Аналогично возвращая по ссылке, возвращаем <code>lvalue</code>, а по значению <code>rvalue</code>.</p>
<h2><a class="header" href="#Перегрузка-операторов-внутри-класса-и-снаружи" id="Перегрузка-операторов-внутри-класса-и-снаружи">Перегрузка операторов внутри класса и снаружи:</a></h2>
<p>Операторы можно перегружать как функции (снаружи класса) и как методы (внутри класса).  Соответственно, у операторов, перегруженных как методы, первым аргументов будет неявный <code>this</code>. </p>
<p>У операторов может срабатывать неявное приведение типов (если есть не <code>explicit</code> конструктор). При этом если оператор перегружен как функция, то приводится любой из аргументов, а если как метод, то только правый.</p>
<p>Примеры:</p>
<pre><code class="language-c++">// как методы:
struct A {
	A (int a); // не explicit конструктор
	A operator-() const; // -(*this)
	A operator-(A const&amp; w) const; // (*this) - w, нельзя вызвать (2-v)
}

// как функции:
A operator-(A const&amp; v);
A operator +(A const&amp; v, A const&amp; w);
// можно вызвать как (2-v), так как есть не explicit конструктор от int
</code></pre>
<p>Можно делать аргументы оператора другого типа но тогда его нужно перегрузить как функцию, если первый аргумент другого типа.</p>
<pre><code class="language-c++">Vector operator*(double d, Vector const&amp; v);
</code></pre>
<p>Некоторые операторы необходимо перегружать только внутри класса: <code>(type), [], (), -&gt;, -&gt;*, =</code>. </p>
<p>Вот так перегружается оператор <code>()</code>, заметьте, что можно сделать это для разного количества аргументов:</p>
<pre><code class="language-c++">bool operator()(double d) const;
void operator()(double a, double b);
</code></pre>
<p><strong>Пример инкремента и декремента</strong>:</p>
<p>Чтобы отличать их, постфиксный перегружают с неиспользуемым (<em>dummy</em>) параметром типа <code>int</code>. Когда вызывается постфиксный оператор, всегда передаётся аргумент, хотя можно и вручную вызвать оператор как функцию и передать любое значение:<code>a.operator++(2)</code>.</p>
<pre><code class="language-c++">struct big_integer {
     big_integer &amp; operator++() { // prefix
         // ...
          return *this;
     }
     big_integer operator++(int) { // postfix
          big_integer tmp(*this);
          ++(*this);
          return tmp;
     }
}
</code></pre>
<p><strong>Пример оператора приведения в стиле C:</strong></p>
<pre><code class="language-c++">struct String {
	operator bool() const {  // приведение к bool
		return size_ != 0;
	}
	operator char const*() const {   // приведение к char const*
  		if (*this) {
    			return data_;
    		} else {
    			return &quot;&quot;;
   	 	}
	} 
	// ...
}
</code></pre>
<p>Аналогично можно перегружать и касты в стиле C++ (static_cast и др.). </p>
<p>У операторов приведения, как и у конструкторов, можно указывать модификатор <code>explicit</code> и запрещать неявное приведение.</p>
<p>Некоторые ограничения:</p>
<ul>
<li>Оператор <code>-&gt;</code> должен возвращать указатель или объект класса, для которого он переопределён (по ссылке или по значению).</li>
<li>Операторы <code>&amp;&amp;</code>, <code>||</code> при перегрузке теряют своё <a href="https://en.cppreference.com/w/cpp/language/eval_order">специальное поведение</a> и ведут себя как обычные функции.</li>
<li>Операторы <code>+=</code> и подобные лучше перегружать внутри класса, а <code>+</code> снаружи через <code>+=</code>. Тогда для <code>+</code> будет работать приведение типов.</li>
<li>Операторы сравнений стоит определять одновременно и согласованно: если определили какой-то один из них, принято определить и все остальные так, чтобы они не противоречили друг другу.</li>
<li>Хорошим тоном считается соблюдать стандартный смысл операторов: не перегружать оператор <code>+</code> как умножение.</li>
<li>Приоритет операторов остаётся стандартным.</li>
</ul>
<h2><a class="header" href="#Про-указатели-и-массивы" id="Про-указатели-и-массивы">Про указатели и массивы</a></h2>
<pre><code class="language-c++">int a[10]; // массивы - полноценные типы
int* p = a; // неявно приводится в указатель на тип элемента массива
int b[10] = a; // так не работает, массивы нельзя копировать

void f(int c[10]); // то же самое, что void f(int* c);

int const a[10]; // константный массив константных элементов, не может быть константно что-то одно из них

void f(int const (*p)[10]); // массив по указателю
void f(int (&amp;c)[10]); // массив по ссылке
</code></pre>
<p>Если функция принимает массив: <code>void f(int a[10])</code>, то на самом деле она принимает <code>int *</code> и длина игнорируется. </p>
<p>Но если функция принимает указатель на массив: <code>void g(int (*p)[10])</code>, то она принимает указатель на массив длины 10. Все размерности, кроме внешней, должны быть определены, так как являются частью типа элемента.</p>
<p>Важно: <code> int *p[10]</code> - массив указателей, <code>int (*p)[10]</code> - указатель на массив длины 10.</p>
<h1><a class="header" href="#Классы-абстракция-данных-1" id="Классы-абстракция-данных-1">Классы, абстракция данных</a></h1>
<p><a href="https://github.com/sorokin/cpp-course/blob/gh-pages/demos/string-demo/main.cpp">Примеры к лекции</a></p>
<h2><a class="header" href="#Структуры-1" id="Структуры-1">Структуры</a></h2>
<p>С помощью структур можно создавать свои типы. У структуры есть поля и методы. У полей и методов есть модификаторы доступа <code>public</code>, <code>private</code>, <code>protected</code>. По дефолту все поля и методы структуры - <code>public</code>.</p>
<p>Классы отличаются от структур только тем, что в классах по умолчанию все <code>private</code>, а в структурах <code>public</code>. Далее всё будет называться классами.</p>
<p>К полям класса можно обращать сразу через указатель на экземпляр:</p>
<pre><code class="language-c++">complex * c;
c-&gt;im // то же самое, что (*c).im
</code></pre>
<p>В отличие от языка <code>C</code>, в <code>C++</code> можно объявлять методы у структур.</p>
<pre><code class="language-c++">struct complex {
	void conjugate() {	
		im = -im;
	}
private:
	double re;
     double im;
};
</code></pre>
<p>Чем отличается метод внутри класса от такой функции?</p>
<pre><code class="language-c++">void conjugate(complex* c) {
	c-&gt;im = -c-&gt;im; 
}
</code></pre>
<ul>
<li>
<p>У метода есть неявный параметр - указатель <code>this</code> на текущий экземпляр.</p>
</li>
<li>
<p>Метод имеет доступ к приватным полям, внешняя функция - нет.</p>
</li>
</ul>
<h4><a class="header" href="#Что-должно-быть-private-а-что-public-1" id="Что-должно-быть-private-а-что-public-1">Что должно быть <code>private</code>, а что <code>public</code>?</a></h4>
<p>Инвариант класса - сохраняющиеся свойства класса. Например, инварианты структуры данных.</p>
<blockquote>
<p>То, что может испортить инвариант класса, должно быть private.</p>
</blockquote>
<p>Проверять инварианты можно ассертами (assert), но не стоит злоупотреблять ими, потому что это дорогоЮ могут быть полезны при дебаге и тестировании.</p>
<p>Обычно пишут объявления функций в <code>class.h</code>, а определения в <code>class.cpp</code>. Если определение функции сделано внутри класса, то она неявно помечается как inline, но мы не всегда хотим этого (дольше время компиляции из-за зависимостей и т.д.).</p>
<pre><code class="language-c++">// struct.h:
struct complex {
  void conjugate();
private:
  double re;
  double im;
}
// struct.cpp:
void complex::conjugate(){
	im = -im;
}
</code></pre>
<p>Как гарантировать какие-то свойства у объекта, который только создан? Это можно реализовать с помощью конструктора.</p>
<h2><a class="header" href="#Конструкторы-1" id="Конструкторы-1">Конструкторы</a></h2>
<p>Классы можно создавать через конструкторы.</p>
<pre><code class="language-c++">struct complex {
	complex(re, im) {
		this.re = re;
		this.im = im;
	}
	complex() {		// конструктор по умолчанию
		this.re = 0;
		this.im = 0;
	}
	void conjugate() {	
		im = -im;
	}
private:
	double re;
  double im;
};

void f(complex);
int main() {
	complex c; // вызывается конструктор по умолчанию
	complex d(1., 2.);
	f(complex(1., 2.));
}
</code></pre>
<p>Если в классе есть конструктор от одного аргумента, то может происходить неявное приведение типов (например, <code>big_integer a = 42</code>, если есть конструктор, который принимает <code>int</code>). Чтобы подавить такое поведение, конструктор нужно объявить с модификатором <code>explicit</code>.</p>
<p>Так же существуют деструкторы, освобождающие ресурсы при удалении объекта. Они вызываются когда объект выходит из &quot;зоны видимости&quot;:</p>
<pre><code class="language-C++">~string() {
	free(data);
	// ...
}

void foo() {
	string S;
} // вызовется деструктор S при выходе из функции
</code></pre>
<h2><a class="header" href="#Немного-про-const-и-указатели-1" id="Немного-про-const-и-указатели-1">Немного про const и указатели</a></h2>
<p>Ключевое слово <code>const</code> - неизменяемое. Относится к тому типу, который стоит слева от него. </p>
<pre><code class="language-c++">int const PI = 3;
int const* q = &amp;PI; 
// int* q = &amp;PI; - кинет ошибку
*q = 4;
	
int* a; - указатель на int
int const* b; - указатель на константный int
int* const b; - константный указатель на int
int const* const c; - константный указатель на константный int

int a = 42;
int const* p = &amp;a; // так тоже можно, но по этому указателю нельзя будет писать
</code></pre>
<p>В функцию, которая принимает указатель, нельзя передать указатель на <code>const</code>, а наоборот - можно.
Поэтому у аргументов функции полезно не забывать <code>const</code>, если функция не меняет принимаемый аргумент.</p>
<p>Константными могут быть не только стандартные типы,
У константных объектов можно вызывать только методы, помеченные <code>const</code>:</p>
<pre><code class="language-c++">struct complex {
	//...
	double real() const {
		&amp;re; // имеет тип double const *, так как метод const
		return re;
	}
}
int main(){
	complex const c(1.1, 2.2);
	c.re = 42; // так нельзя, так как у const структуры все поля const
	c.conjugate(); // так нельзя
	c.real(); // так можно
}
</code></pre>
<h2><a class="header" href="#Операторы-1" id="Операторы-1">Операторы</a></h2>
<p><a href="https://en.cppreference.com/w/cpp/language/operators">cppreference: operator overloading</a></p>
<p>В С++ есть возможность определять собственные операторы для классов:</p>
<pre><code class="language-c++">complex operator+(complex a, complex b) {
	return complex(a.re + b.re, a.im + a.im)
}
</code></pre>
<p>Если вы пишете какой то оператор, то хотя бы один из его элементов должен быть пользовательским типом (нельзя переопределить оператор для <code>int, int</code>, но можно, например, для <code>vector</code> и <code>int</code>).</p>
<p>Еще пример:</p>
<pre><code class="language-c++">complex operator+=(complex a, complex b) {}
</code></pre>
<p>Мы такое сделать не можем, так как нужно поменять а, то есть передать его по указателю: <code>&amp;a += b</code>, что не очень естественно.
Сделать такое можно, используя ссылки:</p>
<table><thead><tr><th>указатель</th><th>ссылка</th></tr></thead><tbody>
<tr><td><code>int* p = &amp;a;</code></td><td><code>int&amp; r = a;</code></td></tr>
<tr><td><code>*p = 5;</code></td><td><code>r = 5;</code></td></tr>
<tr><td><code>int *pp = p</code></td><td><code>int* pr = &amp;r;</code></td></tr>
<tr><td><code>p-&gt;foo</code></td><td><code>p.foo;</code></td></tr>
<tr><td><code>p = &amp;b;</code></td><td><code>// нельзя перенаправить</code></td></tr>
</tbody></table>
<p>Нужно делать так:</p>
<pre><code class="language-c++">complex&amp; operator+=(complex &amp;a, complex b) { // возвращает ссылку, так что можно присвоить куда-то результат a += b;
	// поэтому можно (a += b) += c;
	return a = a + b;
}
</code></pre>
<p>Если мы принимаем экземпляр класса и нам не нужно его менять, можно передавать его по константной ссылке, тогда мы избегаем лишних копирований (в отличие от передачи по значению):</p>
<pre><code class="language-c++">std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, complex const&amp; a) {
	os &lt;&lt; a.real &lt;&lt; &quot; + &quot; &lt;&lt; a.im &lt;&lt; &quot;i&quot;;
	return os;
}
</code></pre>
<p>Если функция принимает <code>const&amp;</code>, то в неё можно передавать временный объект (rvalue). Если же она принимает обычную ссылку, то только <code>lvalue</code>. <br />
Аналогично возвращая по ссылке, возвращаем <code>lvalue</code>, а по значению <code>rvalue</code>.</p>
<h2><a class="header" href="#Перегрузка-операторов-внутри-класса-и-снаружи-1" id="Перегрузка-операторов-внутри-класса-и-снаружи-1">Перегрузка операторов внутри класса и снаружи:</a></h2>
<p>Операторы можно перегружать как функции (снаружи класса) и как методы (внутри класса).  Соответственно, у операторов, перегруженных как методы, первым аргументов будет неявный <code>this</code>. </p>
<p>У операторов может срабатывать неявное приведение типов (если есть не <code>explicit</code> конструктор). При этом если оператор перегружен как функция, то приводится любой из аргументов, а если как метод, то только правый.</p>
<p>Примеры:</p>
<pre><code class="language-c++">// как методы:
struct A {
	A (int a); // не explicit конструктор
	A operator-() const; // -(*this)
	A operator-(A const&amp; w) const; // (*this) - w, нельзя вызвать (2-v)
}

// как функции:
A operator-(A const&amp; v);
A operator +(A const&amp; v, A const&amp; w);
// можно вызвать как (2-v), так как есть не explicit конструктор от int
</code></pre>
<p>Можно делать аргументы оператора другого типа но тогда его нужно перегрузить как функцию, если первый аргумент другого типа.</p>
<pre><code class="language-c++">Vector operator*(double d, Vector const&amp; v);
</code></pre>
<p>Некоторые операторы необходимо перегружать только внутри класса: <code>(type), [], (), -&gt;, -&gt;*, =</code>. </p>
<p>Вот так перегружается оператор <code>()</code>, заметьте, что можно сделать это для разного количества аргументов:</p>
<pre><code class="language-c++">bool operator()(double d) const;
void operator()(double a, double b);
</code></pre>
<p><strong>Пример инкремента и декремента</strong>:</p>
<p>Чтобы отличать их, постфиксный перегружают с неиспользуемым (<em>dummy</em>) параметром типа <code>int</code>. Когда вызывается постфиксный оператор, всегда передаётся аргумент, хотя можно и вручную вызвать оператор как функцию и передать любое значение:<code>a.operator++(2)</code>.</p>
<pre><code class="language-c++">struct big_integer {
     big_integer &amp; operator++() { // prefix
         // ...
          return *this;
     }
     big_integer operator++(int) { // postfix
          big_integer tmp(*this);
          ++(*this);
          return tmp;
     }
}
</code></pre>
<p><strong>Пример оператора приведения в стиле C:</strong></p>
<pre><code class="language-c++">struct String {
	operator bool() const {  // приведение к bool
		return size_ != 0;
	}
	operator char const*() const {   // приведение к char const*
  		if (*this) {
    			return data_;
    		} else {
    			return &quot;&quot;;
   	 	}
	} 
	// ...
}
</code></pre>
<p>Аналогично можно перегружать и касты в стиле C++ (static_cast и др.). </p>
<p>У операторов приведения, как и у конструкторов, можно указывать модификатор <code>explicit</code> и запрещать неявное приведение.</p>
<p>Некоторые ограничения:</p>
<ul>
<li>Оператор <code>-&gt;</code> должен возвращать указатель или объект класса, для которого он переопределён (по ссылке или по значению).</li>
<li>Операторы <code>&amp;&amp;</code>, <code>||</code> при перегрузке теряют своё <a href="https://en.cppreference.com/w/cpp/language/eval_order">специальное поведение</a> и ведут себя как обычные функции.</li>
<li>Операторы <code>+=</code> и подобные лучше перегружать внутри класса, а <code>+</code> снаружи через <code>+=</code>. Тогда для <code>+</code> будет работать приведение типов.</li>
<li>Операторы сравнений стоит определять одновременно и согласованно: если определили какой-то один из них, принято определить и все остальные так, чтобы они не противоречили друг другу.</li>
<li>Хорошим тоном считается соблюдать стандартный смысл операторов: не перегружать оператор <code>+</code> как умножение.</li>
<li>Приоритет операторов остаётся стандартным.</li>
</ul>
<h2><a class="header" href="#Про-указатели-и-массивы-1" id="Про-указатели-и-массивы-1">Про указатели и массивы</a></h2>
<pre><code class="language-c++">int a[10]; // массивы - полноценные типы
int* p = a; // неявно приводится в указатель на тип элемента массива
int b[10] = a; // так не работает, массивы нельзя копировать

void f(int c[10]); // то же самое, что void f(int* c);

int const a[10]; // константный массив константных элементов, не может быть константно что-то одно из них

void f(int const (*p)[10]); // массив по указателю
void f(int (&amp;c)[10]); // массив по ссылке
</code></pre>
<p>Если функция принимает массив: <code>void f(int a[10])</code>, то на самом деле она принимает <code>int *</code> и длина игнорируется. </p>
<p>Но если функция принимает указатель на массив: <code>void g(int (*p)[10])</code>, то она принимает указатель на массив длины 10. Все размерности, кроме внешней, должны быть определены, так как являются частью типа элемента.</p>
<p>Важно: <code> int *p[10]</code> - массив указателей, <code>int (*p)[10]</code> - указатель на массив длины 10.</p>
<h1><a class="header" href="#Запись-1-4" id="Запись-1-4">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-4" id="Запись-2-4">Запись №2</a></h1>
<h1><a class="header" href="#Ещё-немного-про-классы" id="Ещё-немного-про-классы">Ещё немного про классы</a></h1>
<p><a href="https://github.com/sorokin/cpp-course/blob/gh-pages/demos/string-demo/main.cpp">Пример к лекции</a></p>
<h2><a class="header" href="#special-member-функции" id="special-member-функции">Special member функции</a></h2>
<p>Такие функции компилятор сгенерирует сам, если не написать их.</p>
<ul>
<li>
<p>Default constructor - конструктор без аргументов.</p>
</li>
<li>
<p>Destructor - вызывается при выходе из области видимости, используется для освобождения ресурсов. Вызываются в обратном порядке по отношению к порядку вызовов конструктора.</p>
</li>
</ul>
<pre><code class="language-c++">~my_string() {
	free(data_);
}
</code></pre>
<ul>
<li>
<p>Copy constructor - конструктор копирования:</p>
<pre><code class="language-c++">my_string(my_string const&amp; other) {
	size_ = other.size_;
  capacity_ = other.capacity_;
  data_ = (char*)malloc(size_ + 1);
  memcpy(data_, other.data_, size_ + 1);	
}
</code></pre>
</li>
<li>
<p>Assignment operator - оператор присваивания, похож на конструктор копирования, но не создает объект, а меняет уже существующий.<br />
Поэтому в <code>my_string bb = a;</code> вызывается конструктор копирования, так как объект <code>bb</code> ещё не создан.</p>
</li>
</ul>
<pre><code class="language-c++">my_string&amp; operator=(my_string const&amp; other){
	if (this != &amp;other) { 
		// важно проверить, что не присваиваем a = a
		// иначе почистим data_ у себя же
		free(data_);
		size_ = other.size_;
		capacity_ = other.capacity_;
		data_ = (char*)malloc(size_ + 1);
		memcpy(data_, other.data_, size_ + 1);	
	}
	return *this;
}
</code></pre>
<p>Special member функции позволяют реализовать поведение пользовательским типам аналогично стандартным типам (присваивание, копирование), поэтому если они не написаны, то их генерирует компилятор по следующим правилам:</p>
<ul>
<li>
<p>Default constructor - генерируется пустой, если нет других конструкторов.</p>
</li>
<li>
<p>Destructor - генерируется пустой, если не написан.</p>
</li>
<li>
<p>Copy constructor - генерируется, если не написан. Сгенерированный автоматически копирует все поля класса, при этом все члены класса копируются не побайтово, а с вызовом их конструкторов копирования.</p>
<p>Дефолтный конструктор копирования будет копировать указатели без выделения новой памяти. Так, например, у двух объектов <code>my_string</code> будут одинаковые указатели на <code>data_</code> и при выходе из области видимости, оба деструктора вызовут <code>free(data_)</code>. </p>
</li>
<li>
<p>Assignment constructor - генерируется, если не написан. </p>
</li>
</ul>
<p>Как запретить копирования и присваивания?</p>
<pre><code class="language-c++">my_string&amp; operator=(my_string const&amp;) = delete;
my_string(my_string const&amp;) = delete;
</code></pre>
<p>Также можно явно создать дефолтный конструктор (например, если есть уже какой-то другой и из-за него дефолтный не сгенерируется):</p>
<pre><code class="language-c++">my_string() = default;
my_string(my_string const&amp;) = default;
</code></pre>
<p>Так ещё может быть полезно писать, чтобы явно документировать, что дефолтный подходит.</p>
<p>Отличается ли чем-то пустой конструктор от дефолтного?  Пустой конструктор - это <em>user-defined</em> конструктор. Класс с <em>default</em> конструктором - это  <em>trivially constructible</em>. Для них, например, при создании массива не будут вызываться конструкторы.</p>
<p>Если <code>= default</code> писать в определении в какой-нибудь из единиц трансляции, то другие единицы трансляции во время компиляции не знают, что класс <em>trivially constructible</em> и не используют это.</p>
<h2><a class="header" href="#cписки-инициализации-у-конструкторов" id="cписки-инициализации-у-конструкторов">Cписки инициализации у конструкторов</a></h2>
<p>Перед исполнением кода конструктора, вызываются дефолтные конструкторы у всех полей класса. Списки инициализации позволяют заменить вызов дефолтного конструктора поля на вызов конструктора с аргументами.</p>
<pre><code class="language-c++">person() : name(&quot;Ivan&quot;), surname (&quot;Sorokin&quot;) {
	// ...
}
</code></pre>
<p>Хорошее правило - порядок инициализации такой же, как порядок объявления полей, потому что вне зависимости от написанного порядка, они будут инициализироваться в том порядке, в котором объявлены.</p>
<p>Кроме того, конструкторы можно делегировать:</p>
<pre><code class="language-c++">person() : person(&quot;Ivan&quot;, &quot;Sorokin&quot;) {
	// сначала вызовет конструктор от двух char const*, а затем будет выполнять тело это конструктора
}
</code></pre>
<h2><a class="header" href="#Выделение-памяти-2" id="Выделение-памяти-2">Выделение памяти</a></h2>
<pre><code class="language-c++">void f(person const&amp; p);
itn main() {
	person p; // выделяется на стеке, удалится после }
	f(person(&quot;Ivan&quot;, &quot;Sorokin&quot;));	// temporary объект, удалится после ;
}
</code></pre>
<h3><a class="header" href="#malloc-free" id="malloc-free">malloc, free</a></h3>
<pre><code class="language-c++">void * p = malloc(42); // выделяем 42 байта
free(p); // чистит память, выделенную по указателю p
free(p); // так делать не нужно
p = nullptr;
free(p); // так можно, ничего не произойдет
</code></pre>
<h3><a class="header" href="#new-delete" id="new-delete">new, delete</a></h3>
<p>В большинстве реализаций <code>new</code> внутри вызывает <code>malloc</code> и на выделенной памяти вызывается конструктор. <code>delete</code>, соответственно, вызывает деструктор и <code>free</code>.</p>
<pre><code class="language-c++">person* p = new person(&quot;Ivan&quot;, &quot;Sorokin&quot;);
dlete p;

person* p = new person[10]; // выделяет память на 10 объектов person и вызывает их дефолтные конструкторы
delete[] p; // если new вызывался с [], то нужно delete[]

new T;   // оставляет неинициализированную память, если trivially constructible
new T(); // вызывает конструктор
</code></pre>
<h2><a class="header" href="#Препроцессор" id="Препроцессор">Препроцессор</a></h2>
<h3><a class="header" href="#define" id="define">#define</a></h3>
<pre><code class="language-c++">#define PI 3.14159265
double circumference(double r) {
    return 2 * PI * r;
}
</code></pre>
<p>Здесь директива <code>#define</code> определяет макрос с именем <code>PI</code>. Текст, который идет после имени макроса, называется <em>replacement</em>. Replacement отделяется от имени макроса пробелом и распростроняется до конца строки. Все вхождения идентификатора <code>PI</code> ниже этой директивы будут заменены на <em>replacement</em>. При этом препроцессор смотрит целиком токены и не будет заменять, например, часть названия переменной.  Результатом препроцессирования примера выше является следующий текст:</p>
<pre><code class="language-c++">double circumference(double r) {
    return 2 * 3.14159265 * r;
}
</code></pre>
<p>Приведенная выше форма директивы <code>#define</code> называется <em>object-like</em>. Существует вторая форма этой директивы, называемая <em>function-like</em>:</p>
<pre><code class="language-c++">#define MIN(x, y) x &lt; y ? x : y
printf(&quot;%d&quot;, MIN(4, 5));
</code></pre>
<p>Результатом препроцессирования этого фрагмента кода является:</p>
<pre><code class="language-c++">printf(&quot;%d&quot;, 4 &lt; 5 ? 4 : 5);
</code></pre>
<p>Важно понимать, что препроцессор, выполняя подстановки макросов, ничего не знает про приоритет арифметических операций и синтаксическую структуру программы. Рассмотрим следующую программу:</p>
<pre><code class="language-c++">#define MIN(x, y) x &lt; y ? x : y
int main()
{
    printf(&quot;%d&quot;, 10 + MIN(4, 5));
}
</code></pre>
<p>Данная программа выводит <code>5</code>, тогда как скорее всего программист ожидал вывода <code>14</code>. Дело в том, что после раскрытия макроса возникает выражение <code>10 + 4 &lt; 5 ? 4 : 5</code>. Поскольку бинарный <code>+</code> имеет приоритет выше, чем у тернарного оператора, данное выражение разбирается транслятором как <code>(10 + 4) &lt; 5 ? 4 : 5</code>, а не <code>10 + (4 &lt; 5 ? 4 : 5)</code>, как мог ожидать программист, использующий макрос. Чтобы избегать подобных проблем, у <em>function-like</em> макросов, которые раскрываются в выражение, <em>replacement</em> следует брать в скобки. По той же причине имена параметров макроса в <em>replacement</em>, следует брать в скобки. Корректный макрос <code>MIN</code> мог бы выглядеть следующим образом:</p>
<pre><code class="language-c++">#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))
</code></pre>
<p>Директива <code>#define</code> позволяет определять макросы повторно, при этом, в каждой точке программы силу имеет последний <code>#define</code> данного макроса:</p>
<pre><code class="language-c++">X
#define X foo
X
#define X bar
X
</code></pre>
<p>раскрывается в:</p>
<pre><code class="language-c++">foo
bar
</code></pre>
<p><em>Replacement</em> макроса не препроцессируется при определении макроса, но результат раскрытия макроса препроцессируется повторно:</p>
<pre><code class="language-c++">#define Y foo
#define X Y
#define Y bar
X                   // раскрывается в bar
</code></pre>
<p>Что произойдет если replacement макроса <code>M</code> будет содержать использование макроса <code>M</code>? В этом случае возникает рекурсия. По спецификации препроцессор никогда не должен раскрывать макрос <code>M</code> изнутри самого себя, а оставлять вложенный идентификатор как есть:</p>
<pre><code class="language-c++">#define M { M }
M                   // раскрывается в { M } один раз, второй раз M не раскрывается
</code></pre>
<p>Ещё пример:</p>
<pre><code class="language-c++">#define A a{ B }
#define B b{ C }
#define C c{ A }
A
B
C
</code></pre>
<p>Результат препроцессирования:</p>
<pre><code class="language-c++">a{ b{ c{ A } } }
b{ c{ a{ B } } }
c{ a{ b{ C } } }
</code></pre>
<h3><a class="header" href="#undef" id="undef">#undef</a></h3>
<p>Директива <code>#undef</code> позволяет разопределить макрос, определенный ранее с помощью директивы <code>#define</code>. Пример:</p>
<pre><code class="language-c++">#define X foo
X
#undef X
X
</code></pre>
<p>Результат препроцессирования:</p>
<pre><code class="language-c++">X
foo
X
</code></pre>
<h3><a class="header" href="#if" id="if">#if</a></h3>
<p>Директивы <code>#ifdef</code>, <code>#ifndef</code>, <code>#if</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code> позволяют отпрепроцессировать часть файла, лишь при определенном условии. Директивы <code>#ifdef</code>, <code>#ifndef</code> проверяют определен ли указанный макрос. Например, они полезны для разной компиляции:</p>
<pre><code class="language-c++">#ifdef __x64_64__
typedef unsigned long uint64_t;
#else
typedef unsigned long long uint64_t;
#endif
</code></pre>
<p>Директива <code>if</code> позволяет проверить произвольное арифметическое выражение.</p>
<pre><code class="language-c++">#define TWO 2
#if TWO + TWO == 4
// ...
#endif
</code></pre>
<p>Директива <code>#if</code> препроцессирует свой аргумент, а затем парсит то, что получилось как арифметическое выражение. Если после препроцессирования в аргументе <code>#if</code> остаются идентификаторы, то они заменяются на 0, кроме идентификатора <code>true</code>, который заменяется на 1.</p>
<p>Одно из применений <code>#if</code> - это <code>include guard</code>, которые уже обсуждались <a href="https://github.com/lejabque/cpp-notes/blob/master/03.28%20Compilation.md">ранее</a>.</p>
<h3><a class="header" href="#Проблемы-макросов" id="Проблемы-макросов">Проблемы макросов</a></h3>
<p>Основной сложностью <a href="http://www.stroustrup.com/bs_faq2.html#macro">см. также FAQ Бьярна Страуструпа на тему, почему макросы это плохо.</a> при использовании макросов препроцессора является то, что препроцессор оперирует на уровне токенов, не зная ничего про контекст где макрос раскрывается. Предположим, что определен макрос <code>errno</code>, а где-то ниже программист пытается определить локальную переменную <code>errno</code>.</p>
<pre><code class="language-c++">#define errno (*errno_location())
int process() {
    int errno = 0;
}
</code></pre>
<p>Результатом препроцессирования этого фрагмента будет:</p>
<pre><code class="language-c++">int process() {
    int (*errno_location()) = 0;
}
</code></pre>
<p>Как мы видим получившийся в результате препроцессирования фрагмент не объявляет переменную <code>errno</code>. Этот фрагмент не объявляет вообще никакую переменную. В данном конкретном случае программист получит ошибку трансляции:</p>
<pre><code class="language-c++">errno.cpp:5:17: error: function ‘int* errno_location()’ is initialized like a variable
     int errno = 0;
                 ^
</code></pre>
<p>Сообщение об ошибке ссылается на некоторую функцию <code>int* errno_location()</code>, которая в пользовательском коде не упоминается. Такие ошибки могут быть запутывающими. При использовании библиотек, которые определяют много макросов с короткими именами это может доставлять неудобство, поскольку эти имена становиться невозможно использовать ни под что другое. Чтобы смягчить такие проблемы, стоит избегать коротких имён макросов: <code>GTK_MAJOR_VERSION</code> - пример хорошего имени макроса. <code>min</code>, <code>check</code>, <code>tmp</code>, <code>out</code> - примеры плохих имен.</p>
<p>Второй проблемой при использовании пропроцессора является то, что отладчик ничего не знает про раскрытые макросы. Независимо от того, сколько кода пришло из макроса, отладчик будет работать как будто весь этот код написан в одной строке. Поэтому, как правило, в коде активно использующем макросы, сложно работать с отладчиком.</p>
<h3><a class="header" href="#Альтернативы-макросам" id="Альтернативы-макросам">Альтернативы макросам</a></h3>
<p>В связи с расширение языка, сейчас возможно использовать обычные языковые конструкции, там где раньше использовался препроцессор. Например, изначально препроцессор использовался для того, чтобы определять константы:</p>
<pre><code class="language-c++">#define BUFF_SIZE 10240
</code></pre>
<p>Без использования препроцессора эту константу возможно объявить как:</p>
<pre><code class="language-c++">size_t const BUFF_SIZE = 10240;
</code></pre>
<p>Аналогично function-like макросы часто можно заменить на inline-функции:</p>
<pre><code class="language-c++">#define STREQ(s1, s2) (strcmp((s1), (s2)) == 0)

inline bool streq(char const* s1, char const* s2) {
    return strcmp(s1, s2) == 0;
}
</code></pre>
<p>В случае когда типы аргументов могут быть различными возможно использование шаблонов:</p>
<pre><code class="language-c++">#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))

template &lt;class T&gt;
T const&amp; min(T const&amp; x, T const&amp; y) {
    return x &lt; y ? x : y;
}
</code></pre>
<h1><a class="header" href="#Ещё-немного-про-классы-1" id="Ещё-немного-про-классы-1">Ещё немного про классы</a></h1>
<p><a href="https://github.com/sorokin/cpp-course/blob/gh-pages/demos/string-demo/main.cpp">Пример к лекции</a></p>
<h2><a class="header" href="#special-member-функции-1" id="special-member-функции-1">Special member функции</a></h2>
<p>Такие функции компилятор сгенерирует сам, если не написать их.</p>
<ul>
<li>
<p>Default constructor - конструктор без аргументов.</p>
</li>
<li>
<p>Destructor - вызывается при выходе из области видимости, используется для освобождения ресурсов. Вызываются в обратном порядке по отношению к порядку вызовов конструктора.</p>
</li>
</ul>
<pre><code class="language-c++">~my_string() {
	free(data_);
}
</code></pre>
<ul>
<li>
<p>Copy constructor - конструктор копирования:</p>
<pre><code class="language-c++">my_string(my_string const&amp; other) {
	size_ = other.size_;
  capacity_ = other.capacity_;
  data_ = (char*)malloc(size_ + 1);
  memcpy(data_, other.data_, size_ + 1);	
}
</code></pre>
</li>
<li>
<p>Assignment operator - оператор присваивания, похож на конструктор копирования, но не создает объект, а меняет уже существующий.<br />
Поэтому в <code>my_string bb = a;</code> вызывается конструктор копирования, так как объект <code>bb</code> ещё не создан.</p>
</li>
</ul>
<pre><code class="language-c++">my_string&amp; operator=(my_string const&amp; other){
	if (this != &amp;other) { 
		// важно проверить, что не присваиваем a = a
		// иначе почистим data_ у себя же
		free(data_);
		size_ = other.size_;
		capacity_ = other.capacity_;
		data_ = (char*)malloc(size_ + 1);
		memcpy(data_, other.data_, size_ + 1);	
	}
	return *this;
}
</code></pre>
<p>Special member функции позволяют реализовать поведение пользовательским типам аналогично стандартным типам (присваивание, копирование), поэтому если они не написаны, то их генерирует компилятор по следующим правилам:</p>
<ul>
<li>
<p>Default constructor - генерируется пустой, если нет других конструкторов.</p>
</li>
<li>
<p>Destructor - генерируется пустой, если не написан.</p>
</li>
<li>
<p>Copy constructor - генерируется, если не написан. Сгенерированный автоматически копирует все поля класса, при этом все члены класса копируются не побайтово, а с вызовом их конструкторов копирования.</p>
<p>Дефолтный конструктор копирования будет копировать указатели без выделения новой памяти. Так, например, у двух объектов <code>my_string</code> будут одинаковые указатели на <code>data_</code> и при выходе из области видимости, оба деструктора вызовут <code>free(data_)</code>. </p>
</li>
<li>
<p>Assignment constructor - генерируется, если не написан. </p>
</li>
</ul>
<p>Как запретить копирования и присваивания?</p>
<pre><code class="language-c++">my_string&amp; operator=(my_string const&amp;) = delete;
my_string(my_string const&amp;) = delete;
</code></pre>
<p>Также можно явно создать дефолтный конструктор (например, если есть уже какой-то другой и из-за него дефолтный не сгенерируется):</p>
<pre><code class="language-c++">my_string() = default;
my_string(my_string const&amp;) = default;
</code></pre>
<p>Так ещё может быть полезно писать, чтобы явно документировать, что дефолтный подходит.</p>
<p>Отличается ли чем-то пустой конструктор от дефолтного?  Пустой конструктор - это <em>user-defined</em> конструктор. Класс с <em>default</em> конструктором - это  <em>trivially constructible</em>. Для них, например, при создании массива не будут вызываться конструкторы.</p>
<p>Если <code>= default</code> писать в определении в какой-нибудь из единиц трансляции, то другие единицы трансляции во время компиляции не знают, что класс <em>trivially constructible</em> и не используют это.</p>
<h2><a class="header" href="#cписки-инициализации-у-конструкторов-1" id="cписки-инициализации-у-конструкторов-1">Cписки инициализации у конструкторов</a></h2>
<p>Перед исполнением кода конструктора, вызываются дефолтные конструкторы у всех полей класса. Списки инициализации позволяют заменить вызов дефолтного конструктора поля на вызов конструктора с аргументами.</p>
<pre><code class="language-c++">person() : name(&quot;Ivan&quot;), surname (&quot;Sorokin&quot;) {
	// ...
}
</code></pre>
<p>Хорошее правило - порядок инициализации такой же, как порядок объявления полей, потому что вне зависимости от написанного порядка, они будут инициализироваться в том порядке, в котором объявлены.</p>
<p>Кроме того, конструкторы можно делегировать:</p>
<pre><code class="language-c++">person() : person(&quot;Ivan&quot;, &quot;Sorokin&quot;) {
	// сначала вызовет конструктор от двух char const*, а затем будет выполнять тело это конструктора
}
</code></pre>
<h2><a class="header" href="#Выделение-памяти-3" id="Выделение-памяти-3">Выделение памяти</a></h2>
<pre><code class="language-c++">void f(person const&amp; p);
itn main() {
	person p; // выделяется на стеке, удалится после }
	f(person(&quot;Ivan&quot;, &quot;Sorokin&quot;));	// temporary объект, удалится после ;
}
</code></pre>
<h3><a class="header" href="#malloc-free-1" id="malloc-free-1">malloc, free</a></h3>
<pre><code class="language-c++">void * p = malloc(42); // выделяем 42 байта
free(p); // чистит память, выделенную по указателю p
free(p); // так делать не нужно
p = nullptr;
free(p); // так можно, ничего не произойдет
</code></pre>
<h3><a class="header" href="#new-delete-1" id="new-delete-1">new, delete</a></h3>
<p>В большинстве реализаций <code>new</code> внутри вызывает <code>malloc</code> и на выделенной памяти вызывается конструктор. <code>delete</code>, соответственно, вызывает деструктор и <code>free</code>.</p>
<pre><code class="language-c++">person* p = new person(&quot;Ivan&quot;, &quot;Sorokin&quot;);
dlete p;

person* p = new person[10]; // выделяет память на 10 объектов person и вызывает их дефолтные конструкторы
delete[] p; // если new вызывался с [], то нужно delete[]

new T;   // оставляет неинициализированную память, если trivially constructible
new T(); // вызывает конструктор
</code></pre>
<h2><a class="header" href="#Препроцессор-1" id="Препроцессор-1">Препроцессор</a></h2>
<h3><a class="header" href="#define-1" id="define-1">#define</a></h3>
<pre><code class="language-c++">#define PI 3.14159265
double circumference(double r) {
    return 2 * PI * r;
}
</code></pre>
<p>Здесь директива <code>#define</code> определяет макрос с именем <code>PI</code>. Текст, который идет после имени макроса, называется <em>replacement</em>. Replacement отделяется от имени макроса пробелом и распростроняется до конца строки. Все вхождения идентификатора <code>PI</code> ниже этой директивы будут заменены на <em>replacement</em>. При этом препроцессор смотрит целиком токены и не будет заменять, например, часть названия переменной.  Результатом препроцессирования примера выше является следующий текст:</p>
<pre><code class="language-c++">double circumference(double r) {
    return 2 * 3.14159265 * r;
}
</code></pre>
<p>Приведенная выше форма директивы <code>#define</code> называется <em>object-like</em>. Существует вторая форма этой директивы, называемая <em>function-like</em>:</p>
<pre><code class="language-c++">#define MIN(x, y) x &lt; y ? x : y
printf(&quot;%d&quot;, MIN(4, 5));
</code></pre>
<p>Результатом препроцессирования этого фрагмента кода является:</p>
<pre><code class="language-c++">printf(&quot;%d&quot;, 4 &lt; 5 ? 4 : 5);
</code></pre>
<p>Важно понимать, что препроцессор, выполняя подстановки макросов, ничего не знает про приоритет арифметических операций и синтаксическую структуру программы. Рассмотрим следующую программу:</p>
<pre><code class="language-c++">#define MIN(x, y) x &lt; y ? x : y
int main()
{
    printf(&quot;%d&quot;, 10 + MIN(4, 5));
}
</code></pre>
<p>Данная программа выводит <code>5</code>, тогда как скорее всего программист ожидал вывода <code>14</code>. Дело в том, что после раскрытия макроса возникает выражение <code>10 + 4 &lt; 5 ? 4 : 5</code>. Поскольку бинарный <code>+</code> имеет приоритет выше, чем у тернарного оператора, данное выражение разбирается транслятором как <code>(10 + 4) &lt; 5 ? 4 : 5</code>, а не <code>10 + (4 &lt; 5 ? 4 : 5)</code>, как мог ожидать программист, использующий макрос. Чтобы избегать подобных проблем, у <em>function-like</em> макросов, которые раскрываются в выражение, <em>replacement</em> следует брать в скобки. По той же причине имена параметров макроса в <em>replacement</em>, следует брать в скобки. Корректный макрос <code>MIN</code> мог бы выглядеть следующим образом:</p>
<pre><code class="language-c++">#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))
</code></pre>
<p>Директива <code>#define</code> позволяет определять макросы повторно, при этом, в каждой точке программы силу имеет последний <code>#define</code> данного макроса:</p>
<pre><code class="language-c++">X
#define X foo
X
#define X bar
X
</code></pre>
<p>раскрывается в:</p>
<pre><code class="language-c++">foo
bar
</code></pre>
<p><em>Replacement</em> макроса не препроцессируется при определении макроса, но результат раскрытия макроса препроцессируется повторно:</p>
<pre><code class="language-c++">#define Y foo
#define X Y
#define Y bar
X                   // раскрывается в bar
</code></pre>
<p>Что произойдет если replacement макроса <code>M</code> будет содержать использование макроса <code>M</code>? В этом случае возникает рекурсия. По спецификации препроцессор никогда не должен раскрывать макрос <code>M</code> изнутри самого себя, а оставлять вложенный идентификатор как есть:</p>
<pre><code class="language-c++">#define M { M }
M                   // раскрывается в { M } один раз, второй раз M не раскрывается
</code></pre>
<p>Ещё пример:</p>
<pre><code class="language-c++">#define A a{ B }
#define B b{ C }
#define C c{ A }
A
B
C
</code></pre>
<p>Результат препроцессирования:</p>
<pre><code class="language-c++">a{ b{ c{ A } } }
b{ c{ a{ B } } }
c{ a{ b{ C } } }
</code></pre>
<h3><a class="header" href="#undef-1" id="undef-1">#undef</a></h3>
<p>Директива <code>#undef</code> позволяет разопределить макрос, определенный ранее с помощью директивы <code>#define</code>. Пример:</p>
<pre><code class="language-c++">#define X foo
X
#undef X
X
</code></pre>
<p>Результат препроцессирования:</p>
<pre><code class="language-c++">X
foo
X
</code></pre>
<h3><a class="header" href="#if-1" id="if-1">#if</a></h3>
<p>Директивы <code>#ifdef</code>, <code>#ifndef</code>, <code>#if</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code> позволяют отпрепроцессировать часть файла, лишь при определенном условии. Директивы <code>#ifdef</code>, <code>#ifndef</code> проверяют определен ли указанный макрос. Например, они полезны для разной компиляции:</p>
<pre><code class="language-c++">#ifdef __x64_64__
typedef unsigned long uint64_t;
#else
typedef unsigned long long uint64_t;
#endif
</code></pre>
<p>Директива <code>if</code> позволяет проверить произвольное арифметическое выражение.</p>
<pre><code class="language-c++">#define TWO 2
#if TWO + TWO == 4
// ...
#endif
</code></pre>
<p>Директива <code>#if</code> препроцессирует свой аргумент, а затем парсит то, что получилось как арифметическое выражение. Если после препроцессирования в аргументе <code>#if</code> остаются идентификаторы, то они заменяются на 0, кроме идентификатора <code>true</code>, который заменяется на 1.</p>
<p>Одно из применений <code>#if</code> - это <code>include guard</code>, которые уже обсуждались <a href="https://github.com/lejabque/cpp-notes/blob/master/03.28%20Compilation.md">ранее</a>.</p>
<h3><a class="header" href="#Проблемы-макросов-1" id="Проблемы-макросов-1">Проблемы макросов</a></h3>
<p>Основной сложностью <a href="http://www.stroustrup.com/bs_faq2.html#macro">см. также FAQ Бьярна Страуструпа на тему, почему макросы это плохо.</a> при использовании макросов препроцессора является то, что препроцессор оперирует на уровне токенов, не зная ничего про контекст где макрос раскрывается. Предположим, что определен макрос <code>errno</code>, а где-то ниже программист пытается определить локальную переменную <code>errno</code>.</p>
<pre><code class="language-c++">#define errno (*errno_location())
int process() {
    int errno = 0;
}
</code></pre>
<p>Результатом препроцессирования этого фрагмента будет:</p>
<pre><code class="language-c++">int process() {
    int (*errno_location()) = 0;
}
</code></pre>
<p>Как мы видим получившийся в результате препроцессирования фрагмент не объявляет переменную <code>errno</code>. Этот фрагмент не объявляет вообще никакую переменную. В данном конкретном случае программист получит ошибку трансляции:</p>
<pre><code class="language-c++">errno.cpp:5:17: error: function ‘int* errno_location()’ is initialized like a variable
     int errno = 0;
                 ^
</code></pre>
<p>Сообщение об ошибке ссылается на некоторую функцию <code>int* errno_location()</code>, которая в пользовательском коде не упоминается. Такие ошибки могут быть запутывающими. При использовании библиотек, которые определяют много макросов с короткими именами это может доставлять неудобство, поскольку эти имена становиться невозможно использовать ни под что другое. Чтобы смягчить такие проблемы, стоит избегать коротких имён макросов: <code>GTK_MAJOR_VERSION</code> - пример хорошего имени макроса. <code>min</code>, <code>check</code>, <code>tmp</code>, <code>out</code> - примеры плохих имен.</p>
<p>Второй проблемой при использовании пропроцессора является то, что отладчик ничего не знает про раскрытые макросы. Независимо от того, сколько кода пришло из макроса, отладчик будет работать как будто весь этот код написан в одной строке. Поэтому, как правило, в коде активно использующем макросы, сложно работать с отладчиком.</p>
<h3><a class="header" href="#Альтернативы-макросам-1" id="Альтернативы-макросам-1">Альтернативы макросам</a></h3>
<p>В связи с расширение языка, сейчас возможно использовать обычные языковые конструкции, там где раньше использовался препроцессор. Например, изначально препроцессор использовался для того, чтобы определять константы:</p>
<pre><code class="language-c++">#define BUFF_SIZE 10240
</code></pre>
<p>Без использования препроцессора эту константу возможно объявить как:</p>
<pre><code class="language-c++">size_t const BUFF_SIZE = 10240;
</code></pre>
<p>Аналогично function-like макросы часто можно заменить на inline-функции:</p>
<pre><code class="language-c++">#define STREQ(s1, s2) (strcmp((s1), (s2)) == 0)

inline bool streq(char const* s1, char const* s2) {
    return strcmp(s1, s2) == 0;
}
</code></pre>
<p>В случае когда типы аргументов могут быть различными возможно использование шаблонов:</p>
<pre><code class="language-c++">#define MIN(x, y) ((x) &lt; (y) ? (x) : (y))

template &lt;class T&gt;
T const&amp; min(T const&amp; x, T const&amp; y) {
    return x &lt; y ? x : y;
}
</code></pre>
<h1><a class="header" href="#Запись-1-5" id="Запись-1-5">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-5" id="Запись-2-5">Запись №2</a></h1>
<h1><a class="header" href="#Наследование-и-виртуальные-функции" id="Наследование-и-виртуальные-функции">Наследование и виртуальные функции</a></h1>
<pre><code class="language-c++">struct vehicle {
	std::string registration_number;
	void print_name() {
		std::cout &lt;&lt; &quot;vehicle\n&quot;;
	}
};
struct bus : vehicle {	// наследуется от vehicle
	int32_t route_number;
	std::string next_stop() const;
	void print_name() {
		std::cout &lt;&lt; &quot;bus\n&quot;;
	}
};
struct truck : vehicle {
	double cargo_mass;
	void print_name() {
		std::cout &lt;&lt; &quot;truck\n&quot;;
	}
};
void f(vehicle&amp; v){
	v.print_name(); // выведет vehicle, так как статический тип vehicle и при компиляции f подставляется вызов print_name от базового класса
}
int main() {
	bus b;
	vehicle&amp; v = b; // можно делать так
	v.registation_number = &quot;123&quot;;
}
</code></pre>
<p><code>bus</code> содержит и <code>route_number</code>, и <code>registration_number</code>.
Компилятор ищет методы и поля сначала внутри последнего, наследовавшего класса. Поэтому обращение к одинаковым полям класса будет возвращать поле последнего. Если наследуемся от двух классов (в C++ есть множественное наследование) и в двух базовых есть поле/метод с одинаковым названием, а в наследнике нет, то будет ошибка компиляции при обращении от объекта наследника.<br />
Если поля классов совпадают в названии, то обратиться к полю другого можно либо через приведение, либо через <code>classname::field</code>.<br />
Наследующий класс можно приводить к любому наследуемому классу и наоборот.</p>
<p>С методами в наследовании работают точно так же, как и с полями:</p>
<pre><code class="language-c++">struct base {
	void g();
};
struct derived : base {
	void g();
};
int main() {
	derived d;
	d.g(); // запустит g() из derived
	d.base::g(); // запустит g() из base
}
</code></pre>
<p>При создании объектов класса-наследника вызывается дефолтный конструктор базового класса (классы конструируются в порядке от базового к производному, деструкторы наоборот). Если хотим вызывать какой-то определённый конструктор, то можно вызывать его через списки инициализации:</p>
<pre><code class="language-c++">struct bus : vehicle {
	bus(std::string const&amp; registration_number, std::string const&amp; next_stop_name) 
		: vehicle(registration_number),
			next_stop_name(next_stop_name){}
}
</code></pre>
<p>При этом стандарт определяет следующий порядок инициализации <a href="https://en.cppreference.com/w/cpp/language/constructor">перевод с cppreference</a>:</p>
<ul>
<li>Инициализируются виртуальные базовые классы (про них будет потом) in depth-first left-to-right traversal.</li>
<li>Инициализируются прямые базовые классы in left-to-right order.</li>
<li>Инициализируются нестатичные члены класса в порядке их объявления.</li>
</ul>
<p><strong>Как не нужно наследоваться</strong>: если вы не добавляете новых данных, то, возможно, вам не нужно наследование и хватит просто функций.</p>
<h2><a class="header" href="#Виртуальные-функции" id="Виртуальные-функции">Виртуальные функции</a></h2>
<p>Когда без наследования не обойтись? Чаще всего его используют вместе с такими конструкциями, как виртуальные функции. Реализованы они через так называемую таблицу виртуальных функций.</p>
<p>Функции можно пометить кодовым словом <code>virtual</code>. Если пометить в базовом классе, то в производных они тоже будут считаться <code>virtual</code>. Функция <code>virtual</code> вызывается в соответствии с динамическим, а не статическим типом (определяется в рантайме).</p>
<pre><code class="language-c++">struct vehicle {
	virtual void print_name() {
		std::cout &lt;&lt; &quot;vehicle&quot; &lt;&lt; std::endl;
	}
}
struct bus : vehicle {
	void print_name() {
  	std::cout &lt;&lt; &quot;bus&quot; &lt;&lt; std::endl;
  }
}
void f (vehicle&amp; a) {
	a.print_name();
}
int main() {
	bus b;
  b.print_name();
  f(b); // выведет bus, так как print_name виртуальная
}
</code></pre>
<p>Чаще всего для базового класса тяжело разумно определить копирование и присваивание, поэтому помечаем их <code>delete</code>:</p>
<pre><code class="language-c++">int main() {
	bus b;
	vehicle v = b; // что тут происходит? это аналоогично vehicle v = (vehicle&amp;) b; и вызывается конструктор копирования у vehicle
}
</code></pre>
<p>Деструктор базового класса лучше объявлять виртуальным: в таком случае обеспечивается правильное разрушение объектов (чтобы всегда вызывался конструктор производного класса).</p>
<p><strong>Мем</strong>: параметры по умолчанию являются частью декларации, поэтому соответствуют статическому типу, даже если указать другие в наследнике.</p>
<pre><code class="language-c++">#include &lt;string&gt;
#include &lt;iostream&gt;
struct vehicle {
	virtual void print_name(std::string prefix = &quot;Base: &quot;){
		std::cout &lt;&lt; prefix &lt;&lt; &quot;vehicle&quot; &lt;&lt; std::endl;
	}
};
struct bus : vehicle {
	void print_name(std::string prefix = &quot;Derived: &quot;){
		std::cout &lt;&lt; prefix &lt;&lt; &quot;bus&quot; &lt;&lt; std::endl;
	}
};
void bar(vehicle&amp; t){
	t.print_name();
}
int main() {
	bus b;
	b.print_name(); // Derived: bus
	bar(b);	// Base: bus
}
</code></pre>
<h3><a class="header" href="#Про-то-как-это-устроено-внутри" id="Про-то-как-это-устроено-внутри">Про то, как это устроено внутри:</a></h3>
<p>Мы могли бы вместо виртуальных функций делать указатели на функции, но это дорого, так как каждая функция добавляет указатель каждому объекту. Но так как для каждого типа они у нас общие, они хранятся в таблице виртуальных функций, а в объекте хранится указатель на неё.</p>
<p>Из-за этого наличие хотя бы одной виртуальной функции в классе добавляет указатель объектам, а при вызове функции сначала смотрим в таблицу, что обходится дороже и мешает компилятору инлайнить функции.</p>
<h2><a class="header" href="#Абстрактные-методы-и-классы" id="Абстрактные-методы-и-классы">Абстрактные методы (и классы):</a></h2>
<p>Если в классе есть хотя бы одна абстрактная функция (ещё их называют чистыми виртуальными), то класс считается абстрактным и создавать объекты такого типа нельзя.</p>
<pre><code class="language-c++">struct output_device {
	virtual void write(void const* data, size_t size) = 0; // обязательство реализации у наследников
};
struct speakers : output_device {};
struct twitch_stream : output_device {};
struct null_output : output_device {};
</code></pre>
<h2><a class="header" href="#Ещё-немного-про-удаление" id="Ещё-немного-про-удаление">Ещё немного про удаление:</a></h2>
<pre><code class="language-c++">struct base1 {
	int a;
};
struct base2 {
	int b;
};
struct derived : base1, base2 {};
int main () {
	derived* d = new derived();
	base2* b = d;
  delete b; // UB, скорее всего получим ошибку о том, что b - невалидный указатель
}
</code></pre>
<p>Почему ошибка именно такая? Это из-за того, как наследование реализовано внутри: по указателю на <code>derived</code> подряд лежат <code>base1</code> и <code>base2</code> (можно понять, если посмотреть, во что компилируется приведение к ним). По сути, в <code>delete b</code> мы пытаемся освободить не то, что аллоцировали, а то, что лежит по указателю <code>derived+4</code>. </p>
<p>Ещё можно заметить, что приведение ссылок и указателей компилируются по-разному, потому что <code>nullptr</code> после приведения должен оставаться <code>nullptr</code>.</p>
<h2><a class="header" href="#Приведение-типов-cast" id="Приведение-типов-cast">Приведение типов (cast):</a></h2>
<p>Представим, что у нас получился такой код (такое иногда бывает, если части приходят из разных хедеров):</p>
<pre><code class="language-c++">struct base1 {
	int a;
};
struct base2 {
	int b;
};
struct derived;
derived&amp; to_derived(base2&amp; b) {
	return (derived&amp;)b;
}
struct derived : base1, base2 {};
derived&amp; to_derived_2(base2&amp; b) {
	return (derived&amp;)b;
}
</code></pre>
<p>Функции <code>to_derived</code> и <code>to_derived_2</code> скомпилируются в разный код, потому что на момент компиляции <code>to_derived</code> типы <code>base2</code> и <code>derived</code> - несвязанные и Си-шные касты втупую приводят указатели для них без пересчёта сдвигов в памяти.</p>
<p>Как такого избежать (хотя бы словить ошибку)? Использовать C++-style касты:</p>
<pre><code class="language-c++">derived&amp; to_derived(base2&amp; b) {
	return static_cast&lt;derived&amp;&gt;(b); // синтаксис шаблонов
}
</code></pre>
<p>Если это будет написано в том же месте, то словим ошибку компиляции, если после определения <code>derived</code>, то проблем не будет.</p>
<p>Всего есть 4 разных <code>cast</code>:</p>
<ul>
<li>
<p><code>static_cast</code> - то, что нам нужно в 99% случаев. В основном это те касты, которые адекватно прописаны в стандарте: касты чисел, upcast/downcast (в наследовании), T* &lt;-&gt; void*.</p>
</li>
<li>
<p><code>reinterpret_cast</code> - касты, которые зависят от реализации компилятором. Редко бывает полезен, стоит избегать. Например, может приводить указатели к числам.</p>
</li>
<li>
<p><code>const_cast</code> - тоже редко хотим использовать. Например:</p>
</li>
</ul>
<pre><code class="language-c++">int a;
int const&amp; b = a;	// знаем, что ссылка на неконстантный a, но по ней нельзя менять
int&amp; c = const_cast&lt;int&amp;&gt;(b); // &quot;снимает const&quot;, редко нужно, например, если в библиотеке забыли пометить аргумент функции const, а хотим передать что-то константно
</code></pre>
<ul>
<li><code>dynamic_cast</code> - позволяет кастить к указателям и ссылкам на объекты полиморфного типа (которые содержат хотя бы одну виртуальную функцию). Если динамический тип не приводится к тому, к чему кастуем, то <code>nullptr</code> (для ссылок бросит исключение).</li>
</ul>
<pre><code class="language-c++">struct base {
	virtual ~base();
};
struct derived : base {};
void f(base* b) {
	derived* d = dynamic_cast&lt;derived*&gt;(b);
}
</code></pre>
<p>Как это работает внутри? Если посмотреть на код, в который это компилируется, в качестве параметров <code>dynamic_cast</code> передаются <code>type_info</code> для классов. <code>type_info</code> содержит информацию об имени класса и позволяет проверить, одинаковый ли тип у объектов, получить его можнно через <code>typeid(d)</code>. Указатель на <code>type_info</code> хранится в таблице виртуальных функций.</p>
<p><em>В коде редко используют <code>dynamic_cast</code>, потому что чаще всего можно обойтись без него и ещё это может быть дорого</em><br />
Ключ компиляции <code>-fno-rtti</code> отключает хранение рантайм-информации, если хочется сэкономить место в бинарном файле, но это выключает возможность использовать </p>
<h2><a class="header" href="#private-наследование" id="private-наследование">Private наследование</a></h2>
<pre><code class="language-c++">struct output_device {
	virtual void write(void const* data, size_t size) = 0;
	virtual void set_volume(double val) = 0;
	virtual void write(void const* data, size_t size) = 0;
};
struct volume_data : output_device {
	void set_volume(double val) override {
		volume = val;
	}
	double get_volume() override {
		return volume;
	}
private:
	double volume;
}
struct file : volume_data {};
struct speakers : volume_data {};
</code></pre>
<p>В коде выше можно приводить <code>file</code> и <code>speakers</code> к <code>volume_data</code> или использовать указатели на них как указатели на <code>volume_data</code>, чего мы не хотим. Эту проблему решает <code>private</code> наследование:</p>
<pre><code class="language-c++">struct file : private volume_data {}; 
</code></pre>
<p><code>private</code> base класс означает, что мы знаем про наследование только внутри класса. Тогда снаружи нельзя не только приводить, но и вызывать функции родительского класса (если нет <code>override</code> в наследнике).</p>
<p>В этом примере есть проблема - от <code>output_device</code> в таком случае мы тоже наследуемся приватно, так как <code>private</code> &quot;скрывает&quot; непрямые базовые классы тоже. </p>
<p>Часто для использования как выше, можно делать так (например, если у нас независимые аспекты поведения, <em>ну ещё можно менять в рантайме реализацию</em>):</p>
<pre><code class="language-c++">struct widget_painter {
	virtual void paint() = 0;
};
struct widget {
	widget(widget_painter*);
	void set_painter(widget_painter*);
private:
	widget_painter* painter;	// аспекты поведения меняем, передавая разные widget_painter
};
struct mandelbrot_painter : widget_painter {
	void print() override;
};
</code></pre>
<h3><a class="header" href="#protected" id="protected">Protected</a></h3>
<p><code>Protected</code> - модификатор, как <code>public</code> и <code>private</code>, но <code>protected</code> функции можно вызывать только в классах-наследниках.</p>
<h3><a class="header" href="#Мем-про-квадрат-и-прямоугольник" id="Мем-про-квадрат-и-прямоугольник">Мем про квадрат и прямоугольник</a></h3>
<p>Как правильно наследоваться: квадрат от прямоугольника или прямоугольника от квадрата? </p>
<p><del>А никак</del> Это зависит от того, что требуется от интерфейса. В общем случае и то, и то может не подходить (у <code>rectangle</code> разные стороны, у <code>square</code> одинаковые, поэтому могут быть проблемы с сеттерами/геттерами и другими функциями)</p>
<h2><a class="header" href="#virtual-наследование" id="virtual-наследование">Virtual наследование</a></h2>
<p>Если базовый класс помечен <code>virtual</code>, то это значит, что он шарится с другими классами в иерархии. Для иерархии все <code>virtual</code> базы склеиваются в один <code>subobject</code>. Пример:</p>
<pre><code class="language-c++">struct a {
	int x;
	void f() {
		x = 42;
	}
};
struct b : virtual a {};
struct c : virtual a {};
struct d : b, c {};
int main() {
     d dd;
     dd.f(); // не упадёт, как без virtual, так как a общий
}
</code></pre>
<p>Но нельзя в <code>b</code> и <code>c</code> оверрайдить одинаковые виртуальные функции из <code>a</code>, будет ошибка компиляции.</p>
<p>С помощью <code>virtual</code> наследования можно реализовывать часть функций интерфейса:</p>
<pre><code class="language-c++">struct a {
	virtual void f() = 0;
	virtual void g() = 0;
	virtual void h() = 0;
};
struct f_impl : virtual a {
	void f() override;
};
struct g_impl : virtual a {
	void g() override;
};
struct derived : f_impl, g_impl {
	void h() override;
};
</code></pre>
<p>Как хранится виртуальная база? Хранятся указатели на таблицу, в которой оффсеты каждой виртуальной базы.</p>
<h1><a class="header" href="#Наследование-и-виртуальные-функции-1" id="Наследование-и-виртуальные-функции-1">Наследование и виртуальные функции</a></h1>
<pre><code class="language-c++">struct vehicle {
	std::string registration_number;
	void print_name() {
		std::cout &lt;&lt; &quot;vehicle\n&quot;;
	}
};
struct bus : vehicle {	// наследуется от vehicle
	int32_t route_number;
	std::string next_stop() const;
	void print_name() {
		std::cout &lt;&lt; &quot;bus\n&quot;;
	}
};
struct truck : vehicle {
	double cargo_mass;
	void print_name() {
		std::cout &lt;&lt; &quot;truck\n&quot;;
	}
};
void f(vehicle&amp; v){
	v.print_name(); // выведет vehicle, так как статический тип vehicle и при компиляции f подставляется вызов print_name от базового класса
}
int main() {
	bus b;
	vehicle&amp; v = b; // можно делать так
	v.registation_number = &quot;123&quot;;
}
</code></pre>
<p><code>bus</code> содержит и <code>route_number</code>, и <code>registration_number</code>.
Компилятор ищет методы и поля сначала внутри последнего, наследовавшего класса. Поэтому обращение к одинаковым полям класса будет возвращать поле последнего. Если наследуемся от двух классов (в C++ есть множественное наследование) и в двух базовых есть поле/метод с одинаковым названием, а в наследнике нет, то будет ошибка компиляции при обращении от объекта наследника.<br />
Если поля классов совпадают в названии, то обратиться к полю другого можно либо через приведение, либо через <code>classname::field</code>.<br />
Наследующий класс можно приводить к любому наследуемому классу и наоборот.</p>
<p>С методами в наследовании работают точно так же, как и с полями:</p>
<pre><code class="language-c++">struct base {
	void g();
};
struct derived : base {
	void g();
};
int main() {
	derived d;
	d.g(); // запустит g() из derived
	d.base::g(); // запустит g() из base
}
</code></pre>
<p>При создании объектов класса-наследника вызывается дефолтный конструктор базового класса (классы конструируются в порядке от базового к производному, деструкторы наоборот). Если хотим вызывать какой-то определённый конструктор, то можно вызывать его через списки инициализации:</p>
<pre><code class="language-c++">struct bus : vehicle {
	bus(std::string const&amp; registration_number, std::string const&amp; next_stop_name) 
		: vehicle(registration_number),
			next_stop_name(next_stop_name){}
}
</code></pre>
<p>При этом стандарт определяет следующий порядок инициализации <a href="https://en.cppreference.com/w/cpp/language/constructor">перевод с cppreference</a>:</p>
<ul>
<li>Инициализируются виртуальные базовые классы (про них будет потом) in depth-first left-to-right traversal.</li>
<li>Инициализируются прямые базовые классы in left-to-right order.</li>
<li>Инициализируются нестатичные члены класса в порядке их объявления.</li>
</ul>
<p><strong>Как не нужно наследоваться</strong>: если вы не добавляете новых данных, то, возможно, вам не нужно наследование и хватит просто функций.</p>
<h2><a class="header" href="#Виртуальные-функции-1" id="Виртуальные-функции-1">Виртуальные функции</a></h2>
<p>Когда без наследования не обойтись? Чаще всего его используют вместе с такими конструкциями, как виртуальные функции. Реализованы они через так называемую таблицу виртуальных функций.</p>
<p>Функции можно пометить кодовым словом <code>virtual</code>. Если пометить в базовом классе, то в производных они тоже будут считаться <code>virtual</code>. Функция <code>virtual</code> вызывается в соответствии с динамическим, а не статическим типом (определяется в рантайме).</p>
<pre><code class="language-c++">struct vehicle {
	virtual void print_name() {
		std::cout &lt;&lt; &quot;vehicle&quot; &lt;&lt; std::endl;
	}
}
struct bus : vehicle {
	void print_name() {
  	std::cout &lt;&lt; &quot;bus&quot; &lt;&lt; std::endl;
  }
}
void f (vehicle&amp; a) {
	a.print_name();
}
int main() {
	bus b;
  b.print_name();
  f(b); // выведет bus, так как print_name виртуальная
}
</code></pre>
<p>Чаще всего для базового класса тяжело разумно определить копирование и присваивание, поэтому помечаем их <code>delete</code>:</p>
<pre><code class="language-c++">int main() {
	bus b;
	vehicle v = b; // что тут происходит? это аналоогично vehicle v = (vehicle&amp;) b; и вызывается конструктор копирования у vehicle
}
</code></pre>
<p>Деструктор базового класса лучше объявлять виртуальным: в таком случае обеспечивается правильное разрушение объектов (чтобы всегда вызывался конструктор производного класса).</p>
<p><strong>Мем</strong>: параметры по умолчанию являются частью декларации, поэтому соответствуют статическому типу, даже если указать другие в наследнике.</p>
<pre><code class="language-c++">#include &lt;string&gt;
#include &lt;iostream&gt;
struct vehicle {
	virtual void print_name(std::string prefix = &quot;Base: &quot;){
		std::cout &lt;&lt; prefix &lt;&lt; &quot;vehicle&quot; &lt;&lt; std::endl;
	}
};
struct bus : vehicle {
	void print_name(std::string prefix = &quot;Derived: &quot;){
		std::cout &lt;&lt; prefix &lt;&lt; &quot;bus&quot; &lt;&lt; std::endl;
	}
};
void bar(vehicle&amp; t){
	t.print_name();
}
int main() {
	bus b;
	b.print_name(); // Derived: bus
	bar(b);	// Base: bus
}
</code></pre>
<h3><a class="header" href="#Про-то-как-это-устроено-внутри-1" id="Про-то-как-это-устроено-внутри-1">Про то, как это устроено внутри:</a></h3>
<p>Мы могли бы вместо виртуальных функций делать указатели на функции, но это дорого, так как каждая функция добавляет указатель каждому объекту. Но так как для каждого типа они у нас общие, они хранятся в таблице виртуальных функций, а в объекте хранится указатель на неё.</p>
<p>Из-за этого наличие хотя бы одной виртуальной функции в классе добавляет указатель объектам, а при вызове функции сначала смотрим в таблицу, что обходится дороже и мешает компилятору инлайнить функции.</p>
<h2><a class="header" href="#Абстрактные-методы-и-классы-1" id="Абстрактные-методы-и-классы-1">Абстрактные методы (и классы):</a></h2>
<p>Если в классе есть хотя бы одна абстрактная функция (ещё их называют чистыми виртуальными), то класс считается абстрактным и создавать объекты такого типа нельзя.</p>
<pre><code class="language-c++">struct output_device {
	virtual void write(void const* data, size_t size) = 0; // обязательство реализации у наследников
};
struct speakers : output_device {};
struct twitch_stream : output_device {};
struct null_output : output_device {};
</code></pre>
<h2><a class="header" href="#Ещё-немного-про-удаление-1" id="Ещё-немного-про-удаление-1">Ещё немного про удаление:</a></h2>
<pre><code class="language-c++">struct base1 {
	int a;
};
struct base2 {
	int b;
};
struct derived : base1, base2 {};
int main () {
	derived* d = new derived();
	base2* b = d;
  delete b; // UB, скорее всего получим ошибку о том, что b - невалидный указатель
}
</code></pre>
<p>Почему ошибка именно такая? Это из-за того, как наследование реализовано внутри: по указателю на <code>derived</code> подряд лежат <code>base1</code> и <code>base2</code> (можно понять, если посмотреть, во что компилируется приведение к ним). По сути, в <code>delete b</code> мы пытаемся освободить не то, что аллоцировали, а то, что лежит по указателю <code>derived+4</code>. </p>
<p>Ещё можно заметить, что приведение ссылок и указателей компилируются по-разному, потому что <code>nullptr</code> после приведения должен оставаться <code>nullptr</code>.</p>
<h2><a class="header" href="#Приведение-типов-cast-1" id="Приведение-типов-cast-1">Приведение типов (cast):</a></h2>
<p>Представим, что у нас получился такой код (такое иногда бывает, если части приходят из разных хедеров):</p>
<pre><code class="language-c++">struct base1 {
	int a;
};
struct base2 {
	int b;
};
struct derived;
derived&amp; to_derived(base2&amp; b) {
	return (derived&amp;)b;
}
struct derived : base1, base2 {};
derived&amp; to_derived_2(base2&amp; b) {
	return (derived&amp;)b;
}
</code></pre>
<p>Функции <code>to_derived</code> и <code>to_derived_2</code> скомпилируются в разный код, потому что на момент компиляции <code>to_derived</code> типы <code>base2</code> и <code>derived</code> - несвязанные и Си-шные касты втупую приводят указатели для них без пересчёта сдвигов в памяти.</p>
<p>Как такого избежать (хотя бы словить ошибку)? Использовать C++-style касты:</p>
<pre><code class="language-c++">derived&amp; to_derived(base2&amp; b) {
	return static_cast&lt;derived&amp;&gt;(b); // синтаксис шаблонов
}
</code></pre>
<p>Если это будет написано в том же месте, то словим ошибку компиляции, если после определения <code>derived</code>, то проблем не будет.</p>
<p>Всего есть 4 разных <code>cast</code>:</p>
<ul>
<li>
<p><code>static_cast</code> - то, что нам нужно в 99% случаев. В основном это те касты, которые адекватно прописаны в стандарте: касты чисел, upcast/downcast (в наследовании), T* &lt;-&gt; void*.</p>
</li>
<li>
<p><code>reinterpret_cast</code> - касты, которые зависят от реализации компилятором. Редко бывает полезен, стоит избегать. Например, может приводить указатели к числам.</p>
</li>
<li>
<p><code>const_cast</code> - тоже редко хотим использовать. Например:</p>
</li>
</ul>
<pre><code class="language-c++">int a;
int const&amp; b = a;	// знаем, что ссылка на неконстантный a, но по ней нельзя менять
int&amp; c = const_cast&lt;int&amp;&gt;(b); // &quot;снимает const&quot;, редко нужно, например, если в библиотеке забыли пометить аргумент функции const, а хотим передать что-то константно
</code></pre>
<ul>
<li><code>dynamic_cast</code> - позволяет кастить к указателям и ссылкам на объекты полиморфного типа (которые содержат хотя бы одну виртуальную функцию). Если динамический тип не приводится к тому, к чему кастуем, то <code>nullptr</code> (для ссылок бросит исключение).</li>
</ul>
<pre><code class="language-c++">struct base {
	virtual ~base();
};
struct derived : base {};
void f(base* b) {
	derived* d = dynamic_cast&lt;derived*&gt;(b);
}
</code></pre>
<p>Как это работает внутри? Если посмотреть на код, в который это компилируется, в качестве параметров <code>dynamic_cast</code> передаются <code>type_info</code> для классов. <code>type_info</code> содержит информацию об имени класса и позволяет проверить, одинаковый ли тип у объектов, получить его можнно через <code>typeid(d)</code>. Указатель на <code>type_info</code> хранится в таблице виртуальных функций.</p>
<p><em>В коде редко используют <code>dynamic_cast</code>, потому что чаще всего можно обойтись без него и ещё это может быть дорого</em><br />
Ключ компиляции <code>-fno-rtti</code> отключает хранение рантайм-информации, если хочется сэкономить место в бинарном файле, но это выключает возможность использовать </p>
<h2><a class="header" href="#private-наследование-1" id="private-наследование-1">Private наследование</a></h2>
<pre><code class="language-c++">struct output_device {
	virtual void write(void const* data, size_t size) = 0;
	virtual void set_volume(double val) = 0;
	virtual void write(void const* data, size_t size) = 0;
};
struct volume_data : output_device {
	void set_volume(double val) override {
		volume = val;
	}
	double get_volume() override {
		return volume;
	}
private:
	double volume;
}
struct file : volume_data {};
struct speakers : volume_data {};
</code></pre>
<p>В коде выше можно приводить <code>file</code> и <code>speakers</code> к <code>volume_data</code> или использовать указатели на них как указатели на <code>volume_data</code>, чего мы не хотим. Эту проблему решает <code>private</code> наследование:</p>
<pre><code class="language-c++">struct file : private volume_data {}; 
</code></pre>
<p><code>private</code> base класс означает, что мы знаем про наследование только внутри класса. Тогда снаружи нельзя не только приводить, но и вызывать функции родительского класса (если нет <code>override</code> в наследнике).</p>
<p>В этом примере есть проблема - от <code>output_device</code> в таком случае мы тоже наследуемся приватно, так как <code>private</code> &quot;скрывает&quot; непрямые базовые классы тоже. </p>
<p>Часто для использования как выше, можно делать так (например, если у нас независимые аспекты поведения, <em>ну ещё можно менять в рантайме реализацию</em>):</p>
<pre><code class="language-c++">struct widget_painter {
	virtual void paint() = 0;
};
struct widget {
	widget(widget_painter*);
	void set_painter(widget_painter*);
private:
	widget_painter* painter;	// аспекты поведения меняем, передавая разные widget_painter
};
struct mandelbrot_painter : widget_painter {
	void print() override;
};
</code></pre>
<h3><a class="header" href="#protected-1" id="protected-1">Protected</a></h3>
<p><code>Protected</code> - модификатор, как <code>public</code> и <code>private</code>, но <code>protected</code> функции можно вызывать только в классах-наследниках.</p>
<h3><a class="header" href="#Мем-про-квадрат-и-прямоугольник-1" id="Мем-про-квадрат-и-прямоугольник-1">Мем про квадрат и прямоугольник</a></h3>
<p>Как правильно наследоваться: квадрат от прямоугольника или прямоугольника от квадрата? </p>
<p><del>А никак</del> Это зависит от того, что требуется от интерфейса. В общем случае и то, и то может не подходить (у <code>rectangle</code> разные стороны, у <code>square</code> одинаковые, поэтому могут быть проблемы с сеттерами/геттерами и другими функциями)</p>
<h2><a class="header" href="#virtual-наследование-1" id="virtual-наследование-1">Virtual наследование</a></h2>
<p>Если базовый класс помечен <code>virtual</code>, то это значит, что он шарится с другими классами в иерархии. Для иерархии все <code>virtual</code> базы склеиваются в один <code>subobject</code>. Пример:</p>
<pre><code class="language-c++">struct a {
	int x;
	void f() {
		x = 42;
	}
};
struct b : virtual a {};
struct c : virtual a {};
struct d : b, c {};
int main() {
     d dd;
     dd.f(); // не упадёт, как без virtual, так как a общий
}
</code></pre>
<p>Но нельзя в <code>b</code> и <code>c</code> оверрайдить одинаковые виртуальные функции из <code>a</code>, будет ошибка компиляции.</p>
<p>С помощью <code>virtual</code> наследования можно реализовывать часть функций интерфейса:</p>
<pre><code class="language-c++">struct a {
	virtual void f() = 0;
	virtual void g() = 0;
	virtual void h() = 0;
};
struct f_impl : virtual a {
	void f() override;
};
struct g_impl : virtual a {
	void g() override;
};
struct derived : f_impl, g_impl {
	void h() override;
};
</code></pre>
<p>Как хранится виртуальная база? Хранятся указатели на таблицу, в которой оффсеты каждой виртуальной базы.</p>
<h1><a class="header" href="#Запись-1-6" id="Запись-1-6">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-6" id="Запись-2-6">Запись №2</a></h1>
<h1><a class="header" href="#Запись-3-1" id="Запись-3-1">Запись №3</a></h1>
<h1><a class="header" href="#Запись-4" id="Запись-4">Запись №4</a></h1>
<h1><a class="header" href="#Исключения-гарантии-безопасности-исключений-raii" id="Исключения-гарантии-безопасности-исключений-raii">Исключения, гарантии безопасности исключений, RAII</a></h1>
<pre><code class="language-c++">bool do_something() {
	FILE* file = fopen(&quot;1.txt&quot;);
	if (!file)
		return false;
	size_t bytes_read = fread(..., file);
	if (bytes_read &lt; 0)
		return false;
	bytes_read = fread(..., file);
	if (bytes_read &lt; 0)
		return false;
	bytes_read = fread(..., file);
	if (bytes_read &lt; 0)
		return false;
	fclose(file);
	return true;
}
</code></pre>
<p>Как можно возвращать ошибку? Можно это делать с помощью error-кодов (так делали в Си), но это не очень удобно. Для этого используют механизм исключений.</p>
<pre><code class="language-c++">void f() {
	if (...)
		throw runtime_error const&amp; e(&quot;...&quot;);
}
</code></pre>
<p>Что происходит при бросании исключения: </p>
<ul>
<li>
<p>Создаётся копия объекта, переданного в <code>throw</code>. Копия будет существовать, пока исключение не будет обработано. Если тип объекта имеет конструктор копирования, то будет использован он.</p>
</li>
<li>
<p>Прерывается исполнение программы.</p>
</li>
<li>
<p>Выполняется раскрутка стека, пока исключение не будет обработано (поймано), вызываются деструкторы в правильном порядке.</p>
</li>
</ul>
<p>Чтобы ловить исключения, есть конструкция <code>try</code>-<code>catch</code>:</p>
<pre><code class="language-c++">try {
	...
	f();
	...
} catch (runtime_error const&amp; e) {
	...
}
</code></pre>
<p>Выполняется сначала блок <code>try</code> если в нем ничего не произошло, код продолжает выполняться. Если ловится какой-то exception, то он переходит в соответствующий <code>catch</code> блок. Если такового нет, то исключение вылетает за пределы <code>try-catch</code>. Ловить в <code>catch</code> можно и любые исключения <code>catch(...)</code></p>
<h2><a class="header" href="#Пример" id="Пример">Пример:</a></h2>
<pre><code class="language-c++">struct base {
	virtual std::string msg() const {
		return &quot;base&quot;;
	}
}
struct derived : base {
	std::string msg() const {
		return &quot;derived&quot;;
	}
}
int main() {
	try {
		throw derived(); // без const&amp; в catch выведет base
          throw new derived(); // вот так писать не надо, бросится указатель
	} catch (base const&amp; e) {
		std::cout &lt;&lt; e.msg();
          throw e; // вот так тоже не очень, он пробрасывает со статическим типом (base)
	}
}
</code></pre>
<h2><a class="header" href="#Ошибки-и-аллокация-памяти" id="Ошибки-и-аллокация-памяти">Ошибки и аллокация памяти</a></h2>
<p><code>operator new</code> и <code>operator delete</code> - работают как <code>malloc</code> и <code>free</code> (выделяют сырую память), но бросают исключения, а не возвращают <code>nullptr</code></p>
<p>Посмотрим на такой пример:</p>
<pre><code class="language-c++">my_string&amp; my_string::operator =(char const* rhs) {
     char* old_data = data_;
     size_ = strlen(rhs);
     capacity_ = size_;
     data_ = (char*)operator new(size_ + 1);
     memcpy(data_, rhs, size_ + 1);
     operator delete(old_data);
     return *this;
}
</code></pre>
<p>Если <code>operator new</code> выкинет исключение, то получим проблему, что мы уже изменили <code>size_</code> и <code>capacity_</code>, но ничего не скопировали.</p>
<h2><a class="header" href="#Про-работу-с-ресурсами-и-raii" id="Про-работу-с-ресурсами-и-raii">Про работу с ресурсами и RAII</a></h2>
<p>Посмотрим на такой код:</p>
<pre><code class="language-c++">int main() {
     FILE* a = my_fopen(&quot;a.txt&quot;, &quot;r&quot;);
     ...
     fclose(a);
}
</code></pre>
<p>Чем это плохо? Нам нужно не забывать закрывать ресурс. Особенно возникают проблемы, если в процессе кидаем исключения, а ресурсов несколько.</p>
<p>Здесь придерживаются идиомы <code>RAII</code> - resource allocation is initialization</p>
<pre><code class="language-c++">struct file {	
     file(char const* filename, char const* mode) : f(my_fopen(filename, mode)){}
     file(file const&amp;) = delete;
     file&amp; operator=(file const&amp;) = delete;
     ~file() {
          fclose(f);
     }
     FILE* f;
};
</code></pre>
<p>Тогда ресурсы проще создавать и не будет проблем с закрытием при исключениях:</p>
<pre><code class="language-c++">int main() {
     file a(&quot;a.txt&quot;, &quot;r&quot;);
}
</code></pre>
<p>В стандартной библиотеке есть похожий класс - <strong>unique_ptr</strong>. Он представляет из себя уникальный указатель на объект, который нельзя копировать. При уничтожении указателя автоматически вызывается деструктор объекта, на который он указывает. </p>
<p>Обычно его создают через <code>make_unique</code>:</p>
<pre><code class="language-c++">std::unique_ptr&lt;file&gt; a = std::make_unique&lt;file&gt;(&quot;a.txt&quot;, &quot;r&quot;);
</code></pre>
<p>Через <code>.get()</code> можно получить указатель из <code>unique_ptr</code>:</p>
<pre><code class="language-c++">file* ptr = a.get();
</code></pre>
<h2><a class="header" href="#Гарантии-исключений" id="Гарантии-исключений">Гарантии исключений</a></h2>
<ol>
<li>
<p><code>nothrow</code> - гарантируется, что исключение не будет выброшено наружу</p>
</li>
<li>
<p><code>strong</code> - допускается проброс исключений, однако гарантируется сохранение всего исходного состояния в случае исключения</p>
</li>
<li>
<p><code>basic</code> - допускается изменение состояния, однако сохраняется ивариант, утечки ресурсов не допускаются</p>
</li>
<li>
<p><code>no guarantee</code></p>
</li>
</ol>
<p>В деструкторах лучше не делать исключения, это может вызывать проблемы, если мы бросили исключение, вызвался другой деструктор, который тоже бросил исключение. </p>
<h3><a class="header" href="#swap-trick" id="swap-trick">Swap trick</a></h3>
<p>Хорошая идея - писать операторы присваивания и копирования через <code>swap</code>. Это даёт нам <code>strong</code> гарантии:</p>
<pre><code class="language-c++">my_string&amp; my_string::operator=(my_string rhs) {
     swap(rhs); 
     return *this;
}
</code></pre>
<p>Здесь при передаче вызовется оператор копирования строки, а потом мы сделаем swap.</p>
<p>Ещё пример:</p>
<pre><code class="language-c++">void erase_middle_basic(std::vector&lt;std::string&gt;&amp; v) {
     v.erase(v.begin() + v.size() / 2);
}
void erase_middle_strong(std::vector&lt;std::string&gt;&amp; v) {
     std::vector&lt;std::string&gt; copy = v;
     erase_middle_basic(copy);
     std::swap(v, copy);
}
</code></pre>
<h1><a class="header" href="#Исключения-гарантии-безопасности-исключений-raii-1" id="Исключения-гарантии-безопасности-исключений-raii-1">Исключения, гарантии безопасности исключений, RAII</a></h1>
<pre><code class="language-c++">bool do_something() {
	FILE* file = fopen(&quot;1.txt&quot;);
	if (!file)
		return false;
	size_t bytes_read = fread(..., file);
	if (bytes_read &lt; 0)
		return false;
	bytes_read = fread(..., file);
	if (bytes_read &lt; 0)
		return false;
	bytes_read = fread(..., file);
	if (bytes_read &lt; 0)
		return false;
	fclose(file);
	return true;
}
</code></pre>
<p>Как можно возвращать ошибку? Можно это делать с помощью error-кодов (так делали в Си), но это не очень удобно. Для этого используют механизм исключений.</p>
<pre><code class="language-c++">void f() {
	if (...)
		throw runtime_error const&amp; e(&quot;...&quot;);
}
</code></pre>
<p>Что происходит при бросании исключения: </p>
<ul>
<li>
<p>Создаётся копия объекта, переданного в <code>throw</code>. Копия будет существовать, пока исключение не будет обработано. Если тип объекта имеет конструктор копирования, то будет использован он.</p>
</li>
<li>
<p>Прерывается исполнение программы.</p>
</li>
<li>
<p>Выполняется раскрутка стека, пока исключение не будет обработано (поймано), вызываются деструкторы в правильном порядке.</p>
</li>
</ul>
<p>Чтобы ловить исключения, есть конструкция <code>try</code>-<code>catch</code>:</p>
<pre><code class="language-c++">try {
	...
	f();
	...
} catch (runtime_error const&amp; e) {
	...
}
</code></pre>
<p>Выполняется сначала блок <code>try</code> если в нем ничего не произошло, код продолжает выполняться. Если ловится какой-то exception, то он переходит в соответствующий <code>catch</code> блок. Если такового нет, то исключение вылетает за пределы <code>try-catch</code>. Ловить в <code>catch</code> можно и любые исключения <code>catch(...)</code></p>
<h2><a class="header" href="#Пример-1" id="Пример-1">Пример:</a></h2>
<pre><code class="language-c++">struct base {
	virtual std::string msg() const {
		return &quot;base&quot;;
	}
}
struct derived : base {
	std::string msg() const {
		return &quot;derived&quot;;
	}
}
int main() {
	try {
		throw derived(); // без const&amp; в catch выведет base
          throw new derived(); // вот так писать не надо, бросится указатель
	} catch (base const&amp; e) {
		std::cout &lt;&lt; e.msg();
          throw e; // вот так тоже не очень, он пробрасывает со статическим типом (base)
	}
}
</code></pre>
<h2><a class="header" href="#Ошибки-и-аллокация-памяти-1" id="Ошибки-и-аллокация-памяти-1">Ошибки и аллокация памяти</a></h2>
<p><code>operator new</code> и <code>operator delete</code> - работают как <code>malloc</code> и <code>free</code> (выделяют сырую память), но бросают исключения, а не возвращают <code>nullptr</code></p>
<p>Посмотрим на такой пример:</p>
<pre><code class="language-c++">my_string&amp; my_string::operator =(char const* rhs) {
     char* old_data = data_;
     size_ = strlen(rhs);
     capacity_ = size_;
     data_ = (char*)operator new(size_ + 1);
     memcpy(data_, rhs, size_ + 1);
     operator delete(old_data);
     return *this;
}
</code></pre>
<p>Если <code>operator new</code> выкинет исключение, то получим проблему, что мы уже изменили <code>size_</code> и <code>capacity_</code>, но ничего не скопировали.</p>
<h2><a class="header" href="#Про-работу-с-ресурсами-и-raii-1" id="Про-работу-с-ресурсами-и-raii-1">Про работу с ресурсами и RAII</a></h2>
<p>Посмотрим на такой код:</p>
<pre><code class="language-c++">int main() {
     FILE* a = my_fopen(&quot;a.txt&quot;, &quot;r&quot;);
     ...
     fclose(a);
}
</code></pre>
<p>Чем это плохо? Нам нужно не забывать закрывать ресурс. Особенно возникают проблемы, если в процессе кидаем исключения, а ресурсов несколько.</p>
<p>Здесь придерживаются идиомы <code>RAII</code> - resource allocation is initialization</p>
<pre><code class="language-c++">struct file {	
     file(char const* filename, char const* mode) : f(my_fopen(filename, mode)){}
     file(file const&amp;) = delete;
     file&amp; operator=(file const&amp;) = delete;
     ~file() {
          fclose(f);
     }
     FILE* f;
};
</code></pre>
<p>Тогда ресурсы проще создавать и не будет проблем с закрытием при исключениях:</p>
<pre><code class="language-c++">int main() {
     file a(&quot;a.txt&quot;, &quot;r&quot;);
}
</code></pre>
<p>В стандартной библиотеке есть похожий класс - <strong>unique_ptr</strong>. Он представляет из себя уникальный указатель на объект, который нельзя копировать. При уничтожении указателя автоматически вызывается деструктор объекта, на который он указывает. </p>
<p>Обычно его создают через <code>make_unique</code>:</p>
<pre><code class="language-c++">std::unique_ptr&lt;file&gt; a = std::make_unique&lt;file&gt;(&quot;a.txt&quot;, &quot;r&quot;);
</code></pre>
<p>Через <code>.get()</code> можно получить указатель из <code>unique_ptr</code>:</p>
<pre><code class="language-c++">file* ptr = a.get();
</code></pre>
<h2><a class="header" href="#Гарантии-исключений-1" id="Гарантии-исключений-1">Гарантии исключений</a></h2>
<ol>
<li>
<p><code>nothrow</code> - гарантируется, что исключение не будет выброшено наружу</p>
</li>
<li>
<p><code>strong</code> - допускается проброс исключений, однако гарантируется сохранение всего исходного состояния в случае исключения</p>
</li>
<li>
<p><code>basic</code> - допускается изменение состояния, однако сохраняется ивариант, утечки ресурсов не допускаются</p>
</li>
<li>
<p><code>no guarantee</code></p>
</li>
</ol>
<p>В деструкторах лучше не делать исключения, это может вызывать проблемы, если мы бросили исключение, вызвался другой деструктор, который тоже бросил исключение. </p>
<h3><a class="header" href="#swap-trick-1" id="swap-trick-1">Swap trick</a></h3>
<p>Хорошая идея - писать операторы присваивания и копирования через <code>swap</code>. Это даёт нам <code>strong</code> гарантии:</p>
<pre><code class="language-c++">my_string&amp; my_string::operator=(my_string rhs) {
     swap(rhs); 
     return *this;
}
</code></pre>
<p>Здесь при передаче вызовется оператор копирования строки, а потом мы сделаем swap.</p>
<p>Ещё пример:</p>
<pre><code class="language-c++">void erase_middle_basic(std::vector&lt;std::string&gt;&amp; v) {
     v.erase(v.begin() + v.size() / 2);
}
void erase_middle_strong(std::vector&lt;std::string&gt;&amp; v) {
     std::vector&lt;std::string&gt; copy = v;
     erase_middle_basic(copy);
     std::swap(v, copy);
}
</code></pre>
<h1><a class="header" href="#Запись-1-7" id="Запись-1-7">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-7" id="Запись-2-7">Запись №2</a></h1>
<h1><a class="header" href="#Механизмы-ОС-для-аллокации-памяти-аллокаторы-памяти-small-object-и-copy-on-write-оптимизации" id="Механизмы-ОС-для-аллокации-памяти-аллокаторы-памяти-small-object-и-copy-on-write-оптимизации">Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации</a></h1>
<p><em>Первую часть лекции лучше смотреть запись, так как там много профилирования и я не хочу вставлять это в конспект</em></p>
<h2><a class="header" href="#Аллокация-памяти-на-linux-mmap" id="Аллокация-памяти-на-linux-mmap">Аллокация памяти на Linux (mmap)</a></h2>
<p>На Linux страницы памяти выделяются через <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a>, а освобождают через <code>munmap</code>. Он выделяет &quot;лениво&quot; и без обращений к памяти почти нет разницы, сколько выделять. Это можно заметить, если протестировать выделения с обращениями и без.</p>
<p>При запросе выделения памяти через <code>mmap</code> ОС не сразу обращается к процессору, а помечает у себя страницы как &quot;заказанные&quot;. Затем когда происходит обращение к памяти, получаем ошибку <code>page fault</code>, ОС проверяет, если страница выделена, что она мапит её в физическую память, иначе это ошибка.</p>
<p>Зачем так сделано? Типовое использование - это не выделение одной страницы, а сразу порции памяти, которая разбивается на мелкие куски и выдается <code>malloc</code>-ом. Когда они выдаются в программе, они мапаются в физическую память. Ещё мапить сразу в физическую память не очень полезно, так как память, не принадлежащая программой, используется ОС, например, как дисковый кэш.</p>
<p>Зачем нам это знать? Это полезно, если мы что-то бенчмаркаем и выделяем большой массив, первый прогон какого-нибудь алгоритма может быть дольше остальных из-за 
того, что он сначала не помаплен в память.</p>
<p><code>MAP_POPULATE</code> - ключ, который сразу запрашивает память так, будто к ней сделано обращение. Если делать много выделений памяти с обращениями, то можно заметить, что больше всего времени занимает функция зануления памяти. Это логично, потому что память, выделяемую программе, нужно сначала занулить, чтобы исключить доступ к старым данным других программ.</p>
<h2><a class="header" href="#Аллокаторы-памяти" id="Аллокаторы-памяти">Аллокаторы памяти</a></h2>
<p>Большинство аллокаторов сейчас используют дизайн, заимствованный у аллокатора <a href="http://hoard.org/">Hoard</a>. В основном, аллокаторы одинаково работают именно с маленькими объектами, для работы с большими объектами разные аллокаторы используют свои фичи. Рассмотрим один из частых способов работы с маленькими объектами:</p>
<p>Современные аллокаторы умеют выделять их за O(1). Добиваются этого следующим образом: для каждого из частых размеров (16, 24, 32,...) генерируют отдельные аллокаторы. Как делать аллокаторы эффективно? Hashmap дорого, поэтому используют односвязный список. Но для оптимизации в самих блоках памяти, которые выделяем, кладём ноды этого списка (указатели на next).</p>
<h2><a class="header" href="#so-и-cow-оптимизации" id="so-и-cow-оптимизации">SO и CoW оптимизации</a></h2>
<h3><a class="header" href="#copy-on-write" id="copy-on-write">Copy-on-Write</a></h3>
<p>Вспомним класс <code>my_string</code> из прошлых лекций. У строки был какой-то буфер <code>data</code>, которым может заниматься достаточно много. Хотим при копировании сэкономить в случае, если после копирования не нужно изменять данные. Идея такая: когда делаем копию, копируем не данные, а просто указатель на них. При попытке модифицировать их, если буфер расшарен между несколькими string-ми, делаем копию данных.</p>
<p>Обычно это реализуется так: вместе с <code>data</code> храним счётчик объектов (<code>ref_counter</code>), у которых этот буфер общий. Если при попытке модификации <code>ref_counter &gt; 1</code>, то нужно сделать копию.</p>
<pre><code class="language-c++">struct buffer {
  size_t ref_counter;
  char chars[];
}

static buffer* allocate_buffer(size_t capacity) {
  return reinterpret_cast&lt;buffer*&gt;(operator new(sizeof(buffer) + (capacity + 1) * sizeof(char)));
}
</code></pre>
<p>Во всех методах класса нужно обработать счетчик ссылок (опустим этот момент) и функцию <code>unshare</code>:</p>
<pre><code class="language-c++">void my_string::unshare() {
  buffer* new_data = allocate_buffer(size_ + 1);
  memcpy(new_data-&gt;chars, data_-&gt;chars, size);
  
  --data_-&gt;ref_counter;
  assert(data-&gt;ref_counter != 0);
}
</code></pre>
<p>Можно заметить, что <code>capacity</code> и <code>size</code> строки можно перенести тоже в буфер.</p>
<p>Хороший доклад про оптимизации строк от facebook с иллюстрациями по теме: <a href="https://www.youtube.com/watch?v=kPR8h4-qZdk">CppCon 2016: “The strange details of std::string at Facebook&quot;</a></p>
<p>После gcc5 отказались от такого использования CoW в строчках. Первая причина - заморочки с многопоточностью, вторая - оптимизация помогает на длинных строчках, но на небольших скопировать явно может быть даже дешевле. Для маленьких строк используют:</p>
<h3><a class="header" href="#small-object-optimization" id="small-object-optimization">Small-object optimization:</a></h3>
<p>Заметим, что мы хранили в буфере указатель на <code>size</code>, <code>capacity</code> и <code>data</code>, получаются накладные расходы в размере строки в ~20 символов. Что сделали в GCC: добили строчку до 32 байт, а затем <code>data</code> и <code>size</code> остаются собой, а в остальном храним либо сами данные (<code>data</code> указывает туда, где лежало <code>capacity</code>), либо <code>capacity</code> и пустой хвост. Тогда в большом количестве случаев не делаем аллокаций, а копирование стоит недорого, так как в отличие от CoW просто копируем на 15 байт больше.</p>
<p>Как это хранить?</p>
<pre><code class="language-c++">struct dynamic_buffer {
  char* chars;
  size_t capacity;
}
struct small_string {
  // ...
private:
  static const size_t MAX_STATIC_DATA_SIZE = sizeof(dynamic_buffer) - 1;
  size_t size;
  union {
    dynamic_buffer dynamic_data;
    char static_buffer[sizeof(dynamic_buffer)];
  };
};
</code></pre>
<p>В <code>union</code> все поля размещаются на одном месте, поверх друг друга. Соответственно, во всех функциях нужно проверять, какой из буферов используем. </p>
<p>Бонусом получаем, что со small-object оптимизацией нам нужно меньше аллокаций для маленьких строк, а ещё для них меньше кэш-мисов, так как до этого мы сначала брали указатель, а затем шли в память по нему. </p>
<h2><a class="header" href="#Динамические-и-статические-библиотеки" id="Динамические-и-статические-библиотеки">Динамические и статические библиотеки</a></h2>
<p>Тут нужно вспомнить, что мы говорили про процесс компиляции.</p>
<p>Программы можно объединять в статические и динамические библиотеки. Их используют, например, когда есть общий код, который мы хотим включить в несколько программ (можно скомпилировать один раз и включать в линковку другим программ, но обычно это много объектных файлов),  поэтому кучу объектных файлов объединяют в библиотеку, чтобы одним именем сослаться на них. </p>
<pre><code class="language-c++">// sum.cpp
int sum(int a, int b){
  return a + b;
}
// four.cpp
int sum(int a, int b);
int main(){
  std::cout &lt;&lt; sum(2, 2);
}
// five.cpp
int sum(int a, int b);
int main(){
  std::cout &lt;&lt; sum(2, 2);
}
</code></pre>
<p>Компилируем:</p>
<pre><code class="language-shell">g++ -c sum.cpp -o sum.o
g++ -c four.cpp -o four.o
g++ -c five.cpp -o five.o

g++ four.u sum.o -o four
g++ five.o sum.o -o five
</code></pre>
<p>Предположим, что <code>sum</code> это не один объектных файл, а целая библиотека из кучи файлов. Хочется сослаться на неё одним именем (и распространять тоже один файл, а не кучу объектных). Для этого существуют библиотеки:</p>
<pre><code class="language-shell">ar rcs libsum.a sum.o        # rcs - 
g++ four.o -lsum -L. -o four # -lsum - указывает на имя библиотеки
g++ five.o -lsum -L. -o five #  -L. - каталог (здесь это текущий каталог)
</code></pre>
<p>Это всё было про статическую библиотеку. В таком случае код библиотеки попадал в каждую из программ. Чтобы этого избежать, применяют динамические библиотеки:
Динамические библиотеки должны уметь подгружаться по любому адресу. Для этого нужно компилировать <code>sum</code> было с ключом <code>-fpic</code>:</p>
<pre><code class="language-shell">g++ -fpic -c sum.cpp -o sum.o
g++ -shared sum.o -o libsum.so
</code></pre>
<p>Если сейчас мы попробуем запустить программу <code>four</code>, то получим ошибку <code>file not found</code>. Дело в том, что по умолчанию система ищет библиотеки по системным путям. Есть несколько способов обойти: вшить в бинарник путь или прописать <code>LD_LIBRARY_PATH</code>:</p>
<pre><code class="language-shell">LD_LIBRARY_PATH=... # здесь абсолютный путь к каталогу, где лежит наша библиотека
</code></pre>
<p>Если удалить <code>.so</code> файл и попробовать запустить программы, то получим ошибку, так как они на неё ссылались.
Можно посмотреть, на какие динамические библиотеки ссылается программа:</p>
<pre><code class="language-shell">LD_LIBRARY_PATH=... ldd ./four`
</code></pre>
<p>Библиотеки можно подключать в <code>cmake</code> коммндой <code>add_library</code>.</p>
<p>Полезная статья про динамические библиотеки --- <a href="https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf">How to write shared libraries, Ulrich Drepper</a></p>
<h1><a class="header" href="#Механизмы-ОС-для-аллокации-памяти-аллокаторы-памяти-small-object-и-copy-on-write-оптимизации-1" id="Механизмы-ОС-для-аллокации-памяти-аллокаторы-памяти-small-object-и-copy-on-write-оптимизации-1">Механизмы ОС для аллокации памяти, аллокаторы памяти, small-object и copy-on-write оптимизации</a></h1>
<p><em>Первую часть лекции лучше смотреть запись, так как там много профилирования и я не хочу вставлять это в конспект</em></p>
<h2><a class="header" href="#Аллокация-памяти-на-linux-mmap-1" id="Аллокация-памяти-на-linux-mmap-1">Аллокация памяти на Linux (mmap)</a></h2>
<p>На Linux страницы памяти выделяются через <a href="http://man7.org/linux/man-pages/man2/mmap.2.html">mmap</a>, а освобождают через <code>munmap</code>. Он выделяет &quot;лениво&quot; и без обращений к памяти почти нет разницы, сколько выделять. Это можно заметить, если протестировать выделения с обращениями и без.</p>
<p>При запросе выделения памяти через <code>mmap</code> ОС не сразу обращается к процессору, а помечает у себя страницы как &quot;заказанные&quot;. Затем когда происходит обращение к памяти, получаем ошибку <code>page fault</code>, ОС проверяет, если страница выделена, что она мапит её в физическую память, иначе это ошибка.</p>
<p>Зачем так сделано? Типовое использование - это не выделение одной страницы, а сразу порции памяти, которая разбивается на мелкие куски и выдается <code>malloc</code>-ом. Когда они выдаются в программе, они мапаются в физическую память. Ещё мапить сразу в физическую память не очень полезно, так как память, не принадлежащая программой, используется ОС, например, как дисковый кэш.</p>
<p>Зачем нам это знать? Это полезно, если мы что-то бенчмаркаем и выделяем большой массив, первый прогон какого-нибудь алгоритма может быть дольше остальных из-за 
того, что он сначала не помаплен в память.</p>
<p><code>MAP_POPULATE</code> - ключ, который сразу запрашивает память так, будто к ней сделано обращение. Если делать много выделений памяти с обращениями, то можно заметить, что больше всего времени занимает функция зануления памяти. Это логично, потому что память, выделяемую программе, нужно сначала занулить, чтобы исключить доступ к старым данным других программ.</p>
<h2><a class="header" href="#Аллокаторы-памяти-1" id="Аллокаторы-памяти-1">Аллокаторы памяти</a></h2>
<p>Большинство аллокаторов сейчас используют дизайн, заимствованный у аллокатора <a href="http://hoard.org/">Hoard</a>. В основном, аллокаторы одинаково работают именно с маленькими объектами, для работы с большими объектами разные аллокаторы используют свои фичи. Рассмотрим один из частых способов работы с маленькими объектами:</p>
<p>Современные аллокаторы умеют выделять их за O(1). Добиваются этого следующим образом: для каждого из частых размеров (16, 24, 32,...) генерируют отдельные аллокаторы. Как делать аллокаторы эффективно? Hashmap дорого, поэтому используют односвязный список. Но для оптимизации в самих блоках памяти, которые выделяем, кладём ноды этого списка (указатели на next).</p>
<h2><a class="header" href="#so-и-cow-оптимизации-1" id="so-и-cow-оптимизации-1">SO и CoW оптимизации</a></h2>
<h3><a class="header" href="#copy-on-write-1" id="copy-on-write-1">Copy-on-Write</a></h3>
<p>Вспомним класс <code>my_string</code> из прошлых лекций. У строки был какой-то буфер <code>data</code>, которым может заниматься достаточно много. Хотим при копировании сэкономить в случае, если после копирования не нужно изменять данные. Идея такая: когда делаем копию, копируем не данные, а просто указатель на них. При попытке модифицировать их, если буфер расшарен между несколькими string-ми, делаем копию данных.</p>
<p>Обычно это реализуется так: вместе с <code>data</code> храним счётчик объектов (<code>ref_counter</code>), у которых этот буфер общий. Если при попытке модификации <code>ref_counter &gt; 1</code>, то нужно сделать копию.</p>
<pre><code class="language-c++">struct buffer {
  size_t ref_counter;
  char chars[];
}

static buffer* allocate_buffer(size_t capacity) {
  return reinterpret_cast&lt;buffer*&gt;(operator new(sizeof(buffer) + (capacity + 1) * sizeof(char)));
}
</code></pre>
<p>Во всех методах класса нужно обработать счетчик ссылок (опустим этот момент) и функцию <code>unshare</code>:</p>
<pre><code class="language-c++">void my_string::unshare() {
  buffer* new_data = allocate_buffer(size_ + 1);
  memcpy(new_data-&gt;chars, data_-&gt;chars, size);
  
  --data_-&gt;ref_counter;
  assert(data-&gt;ref_counter != 0);
}
</code></pre>
<p>Можно заметить, что <code>capacity</code> и <code>size</code> строки можно перенести тоже в буфер.</p>
<p>Хороший доклад про оптимизации строк от facebook с иллюстрациями по теме: <a href="https://www.youtube.com/watch?v=kPR8h4-qZdk">CppCon 2016: “The strange details of std::string at Facebook&quot;</a></p>
<p>После gcc5 отказались от такого использования CoW в строчках. Первая причина - заморочки с многопоточностью, вторая - оптимизация помогает на длинных строчках, но на небольших скопировать явно может быть даже дешевле. Для маленьких строк используют:</p>
<h3><a class="header" href="#small-object-optimization-1" id="small-object-optimization-1">Small-object optimization:</a></h3>
<p>Заметим, что мы хранили в буфере указатель на <code>size</code>, <code>capacity</code> и <code>data</code>, получаются накладные расходы в размере строки в ~20 символов. Что сделали в GCC: добили строчку до 32 байт, а затем <code>data</code> и <code>size</code> остаются собой, а в остальном храним либо сами данные (<code>data</code> указывает туда, где лежало <code>capacity</code>), либо <code>capacity</code> и пустой хвост. Тогда в большом количестве случаев не делаем аллокаций, а копирование стоит недорого, так как в отличие от CoW просто копируем на 15 байт больше.</p>
<p>Как это хранить?</p>
<pre><code class="language-c++">struct dynamic_buffer {
  char* chars;
  size_t capacity;
}
struct small_string {
  // ...
private:
  static const size_t MAX_STATIC_DATA_SIZE = sizeof(dynamic_buffer) - 1;
  size_t size;
  union {
    dynamic_buffer dynamic_data;
    char static_buffer[sizeof(dynamic_buffer)];
  };
};
</code></pre>
<p>В <code>union</code> все поля размещаются на одном месте, поверх друг друга. Соответственно, во всех функциях нужно проверять, какой из буферов используем. </p>
<p>Бонусом получаем, что со small-object оптимизацией нам нужно меньше аллокаций для маленьких строк, а ещё для них меньше кэш-мисов, так как до этого мы сначала брали указатель, а затем шли в память по нему. </p>
<h2><a class="header" href="#Динамические-и-статические-библиотеки-1" id="Динамические-и-статические-библиотеки-1">Динамические и статические библиотеки</a></h2>
<p>Тут нужно вспомнить, что мы говорили про процесс компиляции.</p>
<p>Программы можно объединять в статические и динамические библиотеки. Их используют, например, когда есть общий код, который мы хотим включить в несколько программ (можно скомпилировать один раз и включать в линковку другим программ, но обычно это много объектных файлов),  поэтому кучу объектных файлов объединяют в библиотеку, чтобы одним именем сослаться на них. </p>
<pre><code class="language-c++">// sum.cpp
int sum(int a, int b){
  return a + b;
}
// four.cpp
int sum(int a, int b);
int main(){
  std::cout &lt;&lt; sum(2, 2);
}
// five.cpp
int sum(int a, int b);
int main(){
  std::cout &lt;&lt; sum(2, 2);
}
</code></pre>
<p>Компилируем:</p>
<pre><code class="language-shell">g++ -c sum.cpp -o sum.o
g++ -c four.cpp -o four.o
g++ -c five.cpp -o five.o

g++ four.u sum.o -o four
g++ five.o sum.o -o five
</code></pre>
<p>Предположим, что <code>sum</code> это не один объектных файл, а целая библиотека из кучи файлов. Хочется сослаться на неё одним именем (и распространять тоже один файл, а не кучу объектных). Для этого существуют библиотеки:</p>
<pre><code class="language-shell">ar rcs libsum.a sum.o        # rcs - 
g++ four.o -lsum -L. -o four # -lsum - указывает на имя библиотеки
g++ five.o -lsum -L. -o five #  -L. - каталог (здесь это текущий каталог)
</code></pre>
<p>Это всё было про статическую библиотеку. В таком случае код библиотеки попадал в каждую из программ. Чтобы этого избежать, применяют динамические библиотеки:
Динамические библиотеки должны уметь подгружаться по любому адресу. Для этого нужно компилировать <code>sum</code> было с ключом <code>-fpic</code>:</p>
<pre><code class="language-shell">g++ -fpic -c sum.cpp -o sum.o
g++ -shared sum.o -o libsum.so
</code></pre>
<p>Если сейчас мы попробуем запустить программу <code>four</code>, то получим ошибку <code>file not found</code>. Дело в том, что по умолчанию система ищет библиотеки по системным путям. Есть несколько способов обойти: вшить в бинарник путь или прописать <code>LD_LIBRARY_PATH</code>:</p>
<pre><code class="language-shell">LD_LIBRARY_PATH=... # здесь абсолютный путь к каталогу, где лежит наша библиотека
</code></pre>
<p>Если удалить <code>.so</code> файл и попробовать запустить программы, то получим ошибку, так как они на неё ссылались.
Можно посмотреть, на какие динамические библиотеки ссылается программа:</p>
<pre><code class="language-shell">LD_LIBRARY_PATH=... ldd ./four`
</code></pre>
<p>Библиотеки можно подключать в <code>cmake</code> коммндой <code>add_library</code>.</p>
<p>Полезная статья про динамические библиотеки --- <a href="https://software.intel.com/sites/default/files/m/a/1/e/dsohowto.pdf">How to write shared libraries, Ulrich Drepper</a></p>
<h1><a class="header" href="#Запись-1-8" id="Запись-1-8">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-8" id="Запись-2-8">Запись №2</a></h1>
<h1><a class="header" href="#Шаблоны" id="Шаблоны">Шаблоны</a></h1>
<p>Часто очень хочется делать типизированный класс - например, какую-то структуру данных для разных типов. Здесь и применяются шаблоны.</p>
<p>В Си их не было и было два способа реализовать такое:</p>
<ul>
<li>
<p>Хранить внутри данные &quot;любого типа&quot; как <code>void*</code>, но это неудобно, потому что нельзя хранить ничего, что занимает больше памяти, чем <code>void*</code>.  Можно хранить указатели, но это не очень эффективно из-за кэш-промахов.</p>
</li>
<li>
<p>Через <code>#define</code>:</p>
</li>
</ul>
<pre><code class="language-c++">#define DECLASE_MYVECTOR(vector_name, type)                 \          
struct vector_name {                                        \
	void push_back(type);                                     \
	type operator[](size_t index) const;                      \
}
</code></pre>
<p>У дефайнов несколько проблем: если ссылаться на один тип по-разному через <code>typedef</code>, то будут генериться два разных класса, которые по сути одно и то же. А ещё нельзя создавать с длинными типами типа <code>unsigned short</code>. А ещё может возникнуть дублирование.</p>
<p>Как это делают <del>нормальные люди</del> в С++:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
// template&lt;class T&gt; это то же самое
struct vector {
     void push_back(T const &amp;);
     T const&amp; operator[](size_t index) const;
}
</code></pre>
<p>Функции тоже можно типизировать:</p>
<pre><code class="language-c++">template&lt;typename T&gt;
void swap(T&amp; a, T&amp; b) {
     T tmp = a;
     a = b;
     b = tmp;
}
</code></pre>
<h2><a class="header" href="#Специализации" id="Специализации">Специализации</a></h2>
<p>Иногда для каких-то типов хочется сделать отдельную реализацию. Например, <code>vector&lt;bool&gt;</code>. Это называется специализацией и делается так:</p>
<pre><code class="language-c++">template &lt;&gt;
struct vector&lt;booL&gt; {
	// ...
};
</code></pre>
<p>С точки зрения языка шаблонным параметром может быть любой тип, но, например, вектор из стандартной библиотеке может принимать не любые типы, а, например, только копируемые и присваиваемые. Поэтому, например, <code>vector&lt;const bool&gt;</code> сделать нельзя, так как он не является присваиваемым.</p>
<p>Чтобы &quot;заифать типы&quot; есть <code>std::conditional</code>, концептуально он работает как-то так:</p>
<pre><code class="language-c++">template &lt;bool Cond, typename IfTrue, typename IfFalse&gt;
struct conditional;

template &lt;typename IfTrue1, typename IfFalse1&gt;
struct conditional&lt;false, IfTrue1, IfFalse1&gt; {
	typedef IfFalse1 type;
};
template &lt;typename IfTrue1, typename IfFalse1&gt;
struct conditional&lt;true, IfTrue1, IfFalse1&gt; {
	typedef IfTrue1 type;
};
</code></pre>
<p>Можно делать partial специализацию, например для указателей:</p>
<pre><code class="language-c++">template &lt;typename V&gt;
struct vector&lt;V*&gt; {
	// ...
}
vector&lt;foo*&gt; c; // выберется эта специализация
</code></pre>
<p>Есть ли у функций специализации? Да, но нельзя делать partial и вообще чаще всего достаточно перегрузок.</p>
<pre><code class="language-c++">template&lt;typename T&gt;
void foo(T*);

template&lt;&gt;
void foo&lt;int&gt;(int*);

// void foo(int*); 
</code></pre>
<p>Чем отличаются две последних функции? Например, на таком коде:</p>
<pre><code class="language-c++">int main() {
	foo(nullptr); // не работает со специализацией
}
</code></pre>
<p>Для функций алгоритм выбора такой: </p>
<ol>
<li>Выбирается перегрузка.</li>
<li>Внутри перегрузки выбирается специализация.</li>
</ol>
<p>Подробнее про <strong>Template argument deduction</strong> на <a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">cpprefernce</a>.</p>
<p>Поэтому когда мы подставляем <code>nullptr</code>, то из него нельзя понять, на какой тип он указывает, поэтому <strong>deduction</strong> фейлится и получаем ошибку. Если же есть <code>void foo(int*)</code>, то выбирается он, как единственный подходящий.</p>
<p>Есть ещё одно правило: <em>если есть нешаблонная функция, которая идеально совпадает с шаблонной, то выбирается нешаблонная</em>, аналогично всегда выбирается <code>explicit</code> специализация.</p>
<pre><code class="language-c++">template &lt;typename U, typename V&gt;
struct mytype{};

template &lt;typename U, typename V&gt;
struct mytype&lt;U*, V&gt;{};

template &lt;typename U, typename V&gt;
struct mytype&lt;U, V*&gt;{};

// В таком случае нельзя делать так, будет ошибка ambiguos template instantiation, так как есть два равноправных кандидата
mytype&lt;long*, double*&gt; f;

// если сделать такую специализацию, то выберется она
// template &lt;typename U, typename V&gt;
// struct mytype&lt;U*, V*&gt;{}; 
</code></pre>
<p>Можно делать <em>non-type</em> шаблонные параметры (числа или <code>enum</code>):</p>
<pre><code class="language-c++">template &lt;typename T, size_t N&gt;
struct array {
     T data[N];
}
// можно делать специализацию:
template &lt;typename T&gt;
struct array&lt;T, 0&gt; {};

array&lt;int, 10&gt; a;
array&lt;int, 0&gt; a;
</code></pre>
<p>А ещё есть такое:</p>
<pre><code class="language-c++">template &lt;template &lt;typename T&gt; class C&gt;
struct array {
};

template &lt;typename T&gt; 
struct cc {
     
};

array&lt;cc&gt; a;
</code></pre>
<p>Шаблонные параметры могут иметь дефолтные значения, они работают как и у функций:</p>
<pre><code class="language-c++">struct default_comparer {};
templte&lt;typename T, typename C = default_comparer&gt;
struct set {};

set&lt;int&gt; a; // юзает дефолтный C
</code></pre>
<h2><a class="header" href="#Немного-про-парсер-c" id="Немного-про-парсер-c">Немного про парсер C++</a></h2>
<pre><code class="language-c++">struct foo {
	static float a;
};
(foo::a)-b; // может быть бинарное вычитание или каст -b к типу а, чтобы это различать, компилятору нужно резолвить foo
int a(b); // может быть конструктор или определение функции
a &lt; b &amp;&amp; c &gt; d; // может быть шаблон a&lt;b&amp;&amp;c&gt; d, а может быть буловое выражение
</code></pre>
<p>Как компилятор различает, например, в случае <code>(foo::a)-b</code>? Особенно если это всё не в одной функции. Здесь работает такое правило: <em>по умолчанию считаем, что в скобках не тип</em>.</p>
<p>Пример:</p>
<pre><code class="language-c++">struct foo {
	static float a;
};
struct bar {
	typedef float a;
};

template&lt;typename T&gt;
void f() {
	int b;
	(T::a)-b; // если хотим тип, то нужно писать (typename T::a)
}

int main {
	f&lt;foo&gt;();
	f&lt;bar&gt;(); // не компилируется
}
</code></pre>
<p>Если хотим, чтобы это читалось как каст, то нужно писать <code>(typename T::a)-b</code>. Кстати, в старых компиляторов <em>Microsoft</em> это не было нужно, так как они откладывали токены и парсили только в момент, когда подставляют функцию.</p>
<p>Аналогично для шаблонов по умолчанию считается не шаблоном, иначе нужно писать так:</p>
<pre><code class="language-c++">T::a &lt; b &amp;&amp; c &gt; d; // по умолчанию не шаблон
typename T::template a &lt; b &amp;&amp; c &gt; d; // это шаблон
</code></pre>
<h2><a class="header" href="#Как-это-устроено-внутри" id="Как-это-устроено-внутри">Как это устроено внутри?</a></h2>
<p><em>На лекции очень много <a href="godbolt.org">godbolt.org</a>, поэтому посмотрите <a href="https://www.youtube.com/watch?v=DwDbH7pxzRA">запись</a> или сами покомпилируйте.</em></p>
<p>Начнём с шаблонных функций:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void swap(T&amp; a, T&amp; b) {
	T tmp = a;
	a = b;
	b = tmp;
}
auto p = &amp;swap&lt;int&gt;; 
auto q = &amp;swap&lt;char&gt;; 
</code></pre>
<p>Для каждого типа код функции генерируется отдельно. При этом, например, чтобы сделать <code>sizeof(swap(a, b))</code>, компилятору не обязательно подставлять тело функции.</p>
<h3><a class="header" href="#Немного-про-разные-единицы-трансляции" id="Немного-про-разные-единицы-трансляции">Немного про разные единицы трансляции:</a></h3>
<pre><code class="language-c++">// swap.h:
template&lt;typename T&gt;
int swap(T&amp; a, T&amp; b);

// swap.cpp:
template &lt;typename T&gt;
void swap(T&amp; a, T&amp; b) {
	T tmp = a;
	a = b;
	b = tmp;
}

// main.cpp:
#include &quot;swap.h&quot;
int main(){
	int a, b;
	swap(a, b);
}
</code></pre>
<p>Такое не скомпилируется. Почему? Каждая единица трансляции транслируется отдельно, а потом всё линкуется. Инстанцирование шаблонов (подстановка) происходит до линковки. По этой причине в <code>swap.cpp</code> мы не можем сгенерить <code>swap&lt;int&gt;</code>, потому что не знаем, что он будет использоваться, а в <code>main.cpp</code> не может сгенерить, потому что нет её тела.</p>
<p>Можно определить тело шаблонной функции прямо в <code>swap.h</code> и инклудить в разные файлы. Казалось бы, получим ошибку из-за нескольких определений, но нет. Шаблонные функции помечаются компилятором как <code>inline</code> и не выдаёт ошибку, считая, что они все одинаковые.</p>
<p>Так же нельзя использовать incomplete типы как параметр. А указатели на них можно.</p>
<p>В стандарте прописано, что инстанцирование происходит только когда необходимо. При этом компилятор может делать это в конце единицы трансляции.</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct foo {
	T* a;
	void f();
	void g(){
		T a;
	}
};
int main() {
	foo&lt;void&gt; a; // так скомпилируется
	a.g(); // а так нет, ошибка из-за void a
}
</code></pre>
<p>В примере выше видно, что если в коде нет вызова функции g, то всё компилируется, так как она не инстанцируется.</p>
<p>С классами работает аналогично: полное тело класса не подставляется, если не требуется.</p>
<p>Например:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct foo {
	T a;
};
int main() {
	foo&lt;void&gt;* a; // так скомпилируется
	a-&gt;a; // а так нет, опять ошибка из-за void a
}
</code></pre>
<p>Почему это важно понимать? Ну например, мы не можем использовать <code>std::unique_ptr</code> на incomplete типе. Ну как не можем. Можем, но получим ошибку, если в коде есть вызов деструктора или другие обращение к объекту.</p>
<pre><code class="language-c++">// mytype.h
#include &lt;memory&gt;
struct object;
struct mytype {
	std::unique_ptr&lt;object&gt; obj;
};
// mytype.cpp
struct object {
	object(int, int, int){};
};
mytype::mytype() : obj(new object(1, 2, 3)){}
// main.cpp
#include &quot;mytype.h&quot;
int main(){
	mytype a;
	return 0;
}
</code></pre>
<p>Без <code>main.cpp</code> компилируется, так как у <code>a</code> не вызывался деструктор, поэтому он не инстанцировался. С <code>main.cpp</code> компилятор генерирует деструктор, который вызывает деструкторы всех членов класса, а там <code>unigue_ptr&lt;object&gt;</code>, у которого при компиляции будет инстанцироваться деструктор, а <code>object</code> там <code>incomplete type</code>, поэтому получим ошибку компиляции, так как в <code>unique_ptr</code> есть специальная проверка, что если удаляется <code>incomplete type</code>, то это ошибка. </p>
<p>Как решить проблему? Сделать явное определение деструктора <code>mytype</code> в <code>mytype.cpp</code>, где у нас определён <code>object</code>.</p>
<p>Ещё пример:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct base {
	typename T::mytype a;
};
template &lt;typename T&gt;
struct derived : base&lt;derived&lt;T&gt;&gt; {
	derived* a; // внутри класса можно ссылаться без шаблонного параметра, будет использоваться текущее инстанцирование
	typedef T mytype;
};
derived&lt;int&gt; a; // не скомпилируется
</code></pre>
<p>Почему это не скомпилируется? Посмотрим на пример попроще.</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct base {
	typename T::mytype a;
};
struct derived : base&lt;derived&gt; {
	typedef int mytype;
};
</code></pre>
<p>Тоже не скомпилируется с ошибкой про incomplete type <code>derived</code>. Почему? Ну потому что <code>derived</code> является incomplete типом, когда инстанцируется <code>base&lt;derived&gt;</code>.</p>
<p>В предыдущем примере тот же самый эффект: так как <code>derived</code> шаблонный, то он не инстанцируется сразу, но когда мы инстанцируем <code>derived</code>, то он создаётся как incomplete (complete он станет после подстановки базовых классов), происходит подстановка base и получаем ошибку.</p>
<p><em>Может быть интересно прочитать про идиому <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a></em></p>
<h2><a class="header" href="#Явное-инстанцирование-шаблонов" id="Явное-инстанцирование-шаблонов">Явное инстанцирование шаблонов</a></h2>
<p>Мы не хотим, чтобы одни и те же лишние инстанцирования были в разных единицах трансляции. Чтобы этого избежать, можно делать так:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void foo(T) {
}
template void foo&lt;int&gt;(int); // генерирует тело функции в этом месте
template void foo&lt;float&gt;(float);
template void foo&lt;double&gt;(double);
</code></pre>
<h2><a class="header" href="#Подавление-инстанцирования" id="Подавление-инстанцирования">Подавление инстанцирования</a></h2>
<p>Подавление явного инстанцирования, если знаем, что функции уже где-то инстанцированы и мы не хотим лишних:</p>
<pre><code class="language-c++">extern template void foo&lt;int&gt;(int); 
extern template void foo&lt;float&gt;(float);
</code></pre>
<p>&quot;Выдаём тело наружу и говорим, что уже проинстанцировано, <code>main</code> не будет пытаться инстанцировать функцию, так как увидит <code>extern</code> и будет работать соответствующе.&quot;</p>
<p>Последний пример:</p>
<pre><code class="language-c++">struct arg {
	struct type {};
};
template &lt;typename T&gt;
struct base {
	int a;
	int b;
};
template &lt;typename T&gt; 
struct derived : base&lt;T&gt; {
	void f() {
		typename T::type a; // depended имя - зависит от шаблонного параметра
		a + 1; // не будет ошибки компиляции, так как откладывается до инстанциации
		arg::type b; // не depended
		b + 1; // сразу ошибка компиляции
		x = 5; // является ли depended?
	}
}

int main() {
	// derived&lt;arg&gt; d;
	// d.f(); // из-за этого происходят ошибки компиляции, если в derived что-то не так, так как происходит инстанцирование 
	return 0;
}
</code></pre>
<p>Depended имена компилятор откладывает до инстанцирования.</p>
<p>Является ли <code>x</code> в <code>derived</code> depended? С одной стороны, здесь не участвуют шаблонные параметры, но с другой стороны у нас может быть такая специализация <code>base</code>,  в которой нет его? А ещё этот <code>x</code> может быть глобальной переменной. Тут вопрос, на что мы компилятор должен ссылаться?</p>
<p>По стандарту определяется следующим образом. Компилятор ищет <code>x</code>, игнорируя базовые классы, так как иначе компилятор не мог бы откидывать любые неизвестные переменные. Если хотим ссылаться на <code>x</code> из базы, то нужно писать явно <code>base&lt;T&gt;::x</code> или <code>this-&gt;x</code>. Тогда он будет depended: если писать <code>base&lt;T&gt;::x</code>, то очевидно, почему, если <code>this-&gt;x</code>, то понятно, что <code>this</code> зависит от шаблонного параметра. При этом компилятор всё равно откладывает это до инстанцирования, даже на таком не выдает ошибку:</p>
<pre><code class="language-c++">// внутри derived
		void* x;
		void f() {
			this-&gt;x = 5;
		}
</code></pre>
<p>Компилятор имеет право выдавать ошибку, если при подстановке любого типа будет ошибка инстанцирования.</p>
<p>На эту тему можно почитать про <a href="http://blog.llvm.org/2009/12/dreaded-two-phase-name-lookup.html">two-phase name lookup</a>.</p>
<h1><a class="header" href="#Шаблоны-1" id="Шаблоны-1">Шаблоны</a></h1>
<p>Часто очень хочется делать типизированный класс - например, какую-то структуру данных для разных типов. Здесь и применяются шаблоны.</p>
<p>В Си их не было и было два способа реализовать такое:</p>
<ul>
<li>
<p>Хранить внутри данные &quot;любого типа&quot; как <code>void*</code>, но это неудобно, потому что нельзя хранить ничего, что занимает больше памяти, чем <code>void*</code>.  Можно хранить указатели, но это не очень эффективно из-за кэш-промахов.</p>
</li>
<li>
<p>Через <code>#define</code>:</p>
</li>
</ul>
<pre><code class="language-c++">#define DECLASE_MYVECTOR(vector_name, type)                 \          
struct vector_name {                                        \
	void push_back(type);                                     \
	type operator[](size_t index) const;                      \
}
</code></pre>
<p>У дефайнов несколько проблем: если ссылаться на один тип по-разному через <code>typedef</code>, то будут генериться два разных класса, которые по сути одно и то же. А ещё нельзя создавать с длинными типами типа <code>unsigned short</code>. А ещё может возникнуть дублирование.</p>
<p>Как это делают <del>нормальные люди</del> в С++:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
// template&lt;class T&gt; это то же самое
struct vector {
     void push_back(T const &amp;);
     T const&amp; operator[](size_t index) const;
}
</code></pre>
<p>Функции тоже можно типизировать:</p>
<pre><code class="language-c++">template&lt;typename T&gt;
void swap(T&amp; a, T&amp; b) {
     T tmp = a;
     a = b;
     b = tmp;
}
</code></pre>
<h2><a class="header" href="#Специализации-1" id="Специализации-1">Специализации</a></h2>
<p>Иногда для каких-то типов хочется сделать отдельную реализацию. Например, <code>vector&lt;bool&gt;</code>. Это называется специализацией и делается так:</p>
<pre><code class="language-c++">template &lt;&gt;
struct vector&lt;booL&gt; {
	// ...
};
</code></pre>
<p>С точки зрения языка шаблонным параметром может быть любой тип, но, например, вектор из стандартной библиотеке может принимать не любые типы, а, например, только копируемые и присваиваемые. Поэтому, например, <code>vector&lt;const bool&gt;</code> сделать нельзя, так как он не является присваиваемым.</p>
<p>Чтобы &quot;заифать типы&quot; есть <code>std::conditional</code>, концептуально он работает как-то так:</p>
<pre><code class="language-c++">template &lt;bool Cond, typename IfTrue, typename IfFalse&gt;
struct conditional;

template &lt;typename IfTrue1, typename IfFalse1&gt;
struct conditional&lt;false, IfTrue1, IfFalse1&gt; {
	typedef IfFalse1 type;
};
template &lt;typename IfTrue1, typename IfFalse1&gt;
struct conditional&lt;true, IfTrue1, IfFalse1&gt; {
	typedef IfTrue1 type;
};
</code></pre>
<p>Можно делать partial специализацию, например для указателей:</p>
<pre><code class="language-c++">template &lt;typename V&gt;
struct vector&lt;V*&gt; {
	// ...
}
vector&lt;foo*&gt; c; // выберется эта специализация
</code></pre>
<p>Есть ли у функций специализации? Да, но нельзя делать partial и вообще чаще всего достаточно перегрузок.</p>
<pre><code class="language-c++">template&lt;typename T&gt;
void foo(T*);

template&lt;&gt;
void foo&lt;int&gt;(int*);

// void foo(int*); 
</code></pre>
<p>Чем отличаются две последних функции? Например, на таком коде:</p>
<pre><code class="language-c++">int main() {
	foo(nullptr); // не работает со специализацией
}
</code></pre>
<p>Для функций алгоритм выбора такой: </p>
<ol>
<li>Выбирается перегрузка.</li>
<li>Внутри перегрузки выбирается специализация.</li>
</ol>
<p>Подробнее про <strong>Template argument deduction</strong> на <a href="https://en.cppreference.com/w/cpp/language/template_argument_deduction">cpprefernce</a>.</p>
<p>Поэтому когда мы подставляем <code>nullptr</code>, то из него нельзя понять, на какой тип он указывает, поэтому <strong>deduction</strong> фейлится и получаем ошибку. Если же есть <code>void foo(int*)</code>, то выбирается он, как единственный подходящий.</p>
<p>Есть ещё одно правило: <em>если есть нешаблонная функция, которая идеально совпадает с шаблонной, то выбирается нешаблонная</em>, аналогично всегда выбирается <code>explicit</code> специализация.</p>
<pre><code class="language-c++">template &lt;typename U, typename V&gt;
struct mytype{};

template &lt;typename U, typename V&gt;
struct mytype&lt;U*, V&gt;{};

template &lt;typename U, typename V&gt;
struct mytype&lt;U, V*&gt;{};

// В таком случае нельзя делать так, будет ошибка ambiguos template instantiation, так как есть два равноправных кандидата
mytype&lt;long*, double*&gt; f;

// если сделать такую специализацию, то выберется она
// template &lt;typename U, typename V&gt;
// struct mytype&lt;U*, V*&gt;{}; 
</code></pre>
<p>Можно делать <em>non-type</em> шаблонные параметры (числа или <code>enum</code>):</p>
<pre><code class="language-c++">template &lt;typename T, size_t N&gt;
struct array {
     T data[N];
}
// можно делать специализацию:
template &lt;typename T&gt;
struct array&lt;T, 0&gt; {};

array&lt;int, 10&gt; a;
array&lt;int, 0&gt; a;
</code></pre>
<p>А ещё есть такое:</p>
<pre><code class="language-c++">template &lt;template &lt;typename T&gt; class C&gt;
struct array {
};

template &lt;typename T&gt; 
struct cc {
     
};

array&lt;cc&gt; a;
</code></pre>
<p>Шаблонные параметры могут иметь дефолтные значения, они работают как и у функций:</p>
<pre><code class="language-c++">struct default_comparer {};
templte&lt;typename T, typename C = default_comparer&gt;
struct set {};

set&lt;int&gt; a; // юзает дефолтный C
</code></pre>
<h2><a class="header" href="#Немного-про-парсер-c-1" id="Немного-про-парсер-c-1">Немного про парсер C++</a></h2>
<pre><code class="language-c++">struct foo {
	static float a;
};
(foo::a)-b; // может быть бинарное вычитание или каст -b к типу а, чтобы это различать, компилятору нужно резолвить foo
int a(b); // может быть конструктор или определение функции
a &lt; b &amp;&amp; c &gt; d; // может быть шаблон a&lt;b&amp;&amp;c&gt; d, а может быть буловое выражение
</code></pre>
<p>Как компилятор различает, например, в случае <code>(foo::a)-b</code>? Особенно если это всё не в одной функции. Здесь работает такое правило: <em>по умолчанию считаем, что в скобках не тип</em>.</p>
<p>Пример:</p>
<pre><code class="language-c++">struct foo {
	static float a;
};
struct bar {
	typedef float a;
};

template&lt;typename T&gt;
void f() {
	int b;
	(T::a)-b; // если хотим тип, то нужно писать (typename T::a)
}

int main {
	f&lt;foo&gt;();
	f&lt;bar&gt;(); // не компилируется
}
</code></pre>
<p>Если хотим, чтобы это читалось как каст, то нужно писать <code>(typename T::a)-b</code>. Кстати, в старых компиляторов <em>Microsoft</em> это не было нужно, так как они откладывали токены и парсили только в момент, когда подставляют функцию.</p>
<p>Аналогично для шаблонов по умолчанию считается не шаблоном, иначе нужно писать так:</p>
<pre><code class="language-c++">T::a &lt; b &amp;&amp; c &gt; d; // по умолчанию не шаблон
typename T::template a &lt; b &amp;&amp; c &gt; d; // это шаблон
</code></pre>
<h2><a class="header" href="#Как-это-устроено-внутри-1" id="Как-это-устроено-внутри-1">Как это устроено внутри?</a></h2>
<p><em>На лекции очень много <a href="godbolt.org">godbolt.org</a>, поэтому посмотрите <a href="https://www.youtube.com/watch?v=DwDbH7pxzRA">запись</a> или сами покомпилируйте.</em></p>
<p>Начнём с шаблонных функций:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void swap(T&amp; a, T&amp; b) {
	T tmp = a;
	a = b;
	b = tmp;
}
auto p = &amp;swap&lt;int&gt;; 
auto q = &amp;swap&lt;char&gt;; 
</code></pre>
<p>Для каждого типа код функции генерируется отдельно. При этом, например, чтобы сделать <code>sizeof(swap(a, b))</code>, компилятору не обязательно подставлять тело функции.</p>
<h3><a class="header" href="#Немного-про-разные-единицы-трансляции-1" id="Немного-про-разные-единицы-трансляции-1">Немного про разные единицы трансляции:</a></h3>
<pre><code class="language-c++">// swap.h:
template&lt;typename T&gt;
int swap(T&amp; a, T&amp; b);

// swap.cpp:
template &lt;typename T&gt;
void swap(T&amp; a, T&amp; b) {
	T tmp = a;
	a = b;
	b = tmp;
}

// main.cpp:
#include &quot;swap.h&quot;
int main(){
	int a, b;
	swap(a, b);
}
</code></pre>
<p>Такое не скомпилируется. Почему? Каждая единица трансляции транслируется отдельно, а потом всё линкуется. Инстанцирование шаблонов (подстановка) происходит до линковки. По этой причине в <code>swap.cpp</code> мы не можем сгенерить <code>swap&lt;int&gt;</code>, потому что не знаем, что он будет использоваться, а в <code>main.cpp</code> не может сгенерить, потому что нет её тела.</p>
<p>Можно определить тело шаблонной функции прямо в <code>swap.h</code> и инклудить в разные файлы. Казалось бы, получим ошибку из-за нескольких определений, но нет. Шаблонные функции помечаются компилятором как <code>inline</code> и не выдаёт ошибку, считая, что они все одинаковые.</p>
<p>Так же нельзя использовать incomplete типы как параметр. А указатели на них можно.</p>
<p>В стандарте прописано, что инстанцирование происходит только когда необходимо. При этом компилятор может делать это в конце единицы трансляции.</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct foo {
	T* a;
	void f();
	void g(){
		T a;
	}
};
int main() {
	foo&lt;void&gt; a; // так скомпилируется
	a.g(); // а так нет, ошибка из-за void a
}
</code></pre>
<p>В примере выше видно, что если в коде нет вызова функции g, то всё компилируется, так как она не инстанцируется.</p>
<p>С классами работает аналогично: полное тело класса не подставляется, если не требуется.</p>
<p>Например:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct foo {
	T a;
};
int main() {
	foo&lt;void&gt;* a; // так скомпилируется
	a-&gt;a; // а так нет, опять ошибка из-за void a
}
</code></pre>
<p>Почему это важно понимать? Ну например, мы не можем использовать <code>std::unique_ptr</code> на incomplete типе. Ну как не можем. Можем, но получим ошибку, если в коде есть вызов деструктора или другие обращение к объекту.</p>
<pre><code class="language-c++">// mytype.h
#include &lt;memory&gt;
struct object;
struct mytype {
	std::unique_ptr&lt;object&gt; obj;
};
// mytype.cpp
struct object {
	object(int, int, int){};
};
mytype::mytype() : obj(new object(1, 2, 3)){}
// main.cpp
#include &quot;mytype.h&quot;
int main(){
	mytype a;
	return 0;
}
</code></pre>
<p>Без <code>main.cpp</code> компилируется, так как у <code>a</code> не вызывался деструктор, поэтому он не инстанцировался. С <code>main.cpp</code> компилятор генерирует деструктор, который вызывает деструкторы всех членов класса, а там <code>unigue_ptr&lt;object&gt;</code>, у которого при компиляции будет инстанцироваться деструктор, а <code>object</code> там <code>incomplete type</code>, поэтому получим ошибку компиляции, так как в <code>unique_ptr</code> есть специальная проверка, что если удаляется <code>incomplete type</code>, то это ошибка. </p>
<p>Как решить проблему? Сделать явное определение деструктора <code>mytype</code> в <code>mytype.cpp</code>, где у нас определён <code>object</code>.</p>
<p>Ещё пример:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct base {
	typename T::mytype a;
};
template &lt;typename T&gt;
struct derived : base&lt;derived&lt;T&gt;&gt; {
	derived* a; // внутри класса можно ссылаться без шаблонного параметра, будет использоваться текущее инстанцирование
	typedef T mytype;
};
derived&lt;int&gt; a; // не скомпилируется
</code></pre>
<p>Почему это не скомпилируется? Посмотрим на пример попроще.</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct base {
	typename T::mytype a;
};
struct derived : base&lt;derived&gt; {
	typedef int mytype;
};
</code></pre>
<p>Тоже не скомпилируется с ошибкой про incomplete type <code>derived</code>. Почему? Ну потому что <code>derived</code> является incomplete типом, когда инстанцируется <code>base&lt;derived&gt;</code>.</p>
<p>В предыдущем примере тот же самый эффект: так как <code>derived</code> шаблонный, то он не инстанцируется сразу, но когда мы инстанцируем <code>derived</code>, то он создаётся как incomplete (complete он станет после подстановки базовых классов), происходит подстановка base и получаем ошибку.</p>
<p><em>Может быть интересно прочитать про идиому <a href="https://en.wikipedia.org/wiki/Curiously_recurring_template_pattern">CRTP</a></em></p>
<h2><a class="header" href="#Явное-инстанцирование-шаблонов-1" id="Явное-инстанцирование-шаблонов-1">Явное инстанцирование шаблонов</a></h2>
<p>Мы не хотим, чтобы одни и те же лишние инстанцирования были в разных единицах трансляции. Чтобы этого избежать, можно делать так:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void foo(T) {
}
template void foo&lt;int&gt;(int); // генерирует тело функции в этом месте
template void foo&lt;float&gt;(float);
template void foo&lt;double&gt;(double);
</code></pre>
<h2><a class="header" href="#Подавление-инстанцирования-1" id="Подавление-инстанцирования-1">Подавление инстанцирования</a></h2>
<p>Подавление явного инстанцирования, если знаем, что функции уже где-то инстанцированы и мы не хотим лишних:</p>
<pre><code class="language-c++">extern template void foo&lt;int&gt;(int); 
extern template void foo&lt;float&gt;(float);
</code></pre>
<p>&quot;Выдаём тело наружу и говорим, что уже проинстанцировано, <code>main</code> не будет пытаться инстанцировать функцию, так как увидит <code>extern</code> и будет работать соответствующе.&quot;</p>
<p>Последний пример:</p>
<pre><code class="language-c++">struct arg {
	struct type {};
};
template &lt;typename T&gt;
struct base {
	int a;
	int b;
};
template &lt;typename T&gt; 
struct derived : base&lt;T&gt; {
	void f() {
		typename T::type a; // depended имя - зависит от шаблонного параметра
		a + 1; // не будет ошибки компиляции, так как откладывается до инстанциации
		arg::type b; // не depended
		b + 1; // сразу ошибка компиляции
		x = 5; // является ли depended?
	}
}

int main() {
	// derived&lt;arg&gt; d;
	// d.f(); // из-за этого происходят ошибки компиляции, если в derived что-то не так, так как происходит инстанцирование 
	return 0;
}
</code></pre>
<p>Depended имена компилятор откладывает до инстанцирования.</p>
<p>Является ли <code>x</code> в <code>derived</code> depended? С одной стороны, здесь не участвуют шаблонные параметры, но с другой стороны у нас может быть такая специализация <code>base</code>,  в которой нет его? А ещё этот <code>x</code> может быть глобальной переменной. Тут вопрос, на что мы компилятор должен ссылаться?</p>
<p>По стандарту определяется следующим образом. Компилятор ищет <code>x</code>, игнорируя базовые классы, так как иначе компилятор не мог бы откидывать любые неизвестные переменные. Если хотим ссылаться на <code>x</code> из базы, то нужно писать явно <code>base&lt;T&gt;::x</code> или <code>this-&gt;x</code>. Тогда он будет depended: если писать <code>base&lt;T&gt;::x</code>, то очевидно, почему, если <code>this-&gt;x</code>, то понятно, что <code>this</code> зависит от шаблонного параметра. При этом компилятор всё равно откладывает это до инстанцирования, даже на таком не выдает ошибку:</p>
<pre><code class="language-c++">// внутри derived
		void* x;
		void f() {
			this-&gt;x = 5;
		}
</code></pre>
<p>Компилятор имеет право выдавать ошибку, если при подстановке любого типа будет ошибка инстанцирования.</p>
<p>На эту тему можно почитать про <a href="http://blog.llvm.org/2009/12/dreaded-two-phase-name-lookup.html">two-phase name lookup</a>.</p>
<h1><a class="header" href="#Запись-1-9" id="Запись-1-9">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-9" id="Запись-2-9">Запись №2</a></h1>
<h1><a class="header" href="#Практика-3" id="Практика-3">Практика №3</a></h1>
<h1><a class="header" href="#Обзор-stl-tag-dispatching-sfinae-пространства-имён" id="Обзор-stl-tag-dispatching-sfinae-пространства-имён">Обзор STL, tag-dispatching, SFINAE, пространства имён</a></h1>
<h1><a class="header" href="#Обзор-stl-tag-dispatching-sfinae-пространства-имён-1" id="Обзор-stl-tag-dispatching-sfinae-пространства-имён-1">Обзор STL, tag-dispatching, SFINAE, пространства имён</a></h1>
<h1><a class="header" href="#Запись-1-10" id="Запись-1-10">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-10" id="Запись-2-10">Запись №2</a></h1>
<h1><a class="header" href="#Пространства-имён-using-декларации-using-директивы-adl" id="Пространства-имён-using-декларации-using-директивы-adl">Пространства имён, using-декларации, using-директивы, ADL.</a></h1>
<h2><a class="header" href="#Пространства-имён" id="Пространства-имён">Пространства имён</a></h2>
<p>В Си в библиотеках у функций обычно есть префикс названия библиотеки, например, <code>mpz_add</code> в GMP. Это нужно, чтобы не было двух разных функций с одинаковым именем.</p>
<p>В C++ для такого используется механизм <code>namespace</code>.</p>
<pre><code class="language-c++">namespace somelib {
  struct foo {};
  void bar();
}
namespace somelib { // можно несколько раз открывать
  void baz(foo*);
}
</code></pre>
<p>Внутри неймспейса можно ссылаться на что угодно из него. Синтаксис обращения снаружи: <code>somelib::foo</code>, где <code>somelib::</code> - квалификатор. Такие имена называются квалифицированными. </p>
<p>Неймспейсы могут быть вложенными:</p>
<pre><code class="language-c++">namespace somelib {
  namespace nested {
    struct foo {};
  }
  void bar (nested::foo const&amp;);
}
</code></pre>
<p>Тогда ссылаться надо так: <code>somelib::nested::foo</code>.</p>
<p>Как такие ищутся без квалификаторов? Поднимаемся по фигурным скобкам (неймспейсам) вплоть до глобального.</p>
<p>Если функции на разных уровнях неймспейсов называются по-разному, то выберется первая найденная. Чтобы обратиться к имени из глобального неймспейса, нужно использовать пустой квалификатор <code>::foo</code>. Но это всё про одну единицу трансляции, а что если их несколько?</p>
<p>Как мы помним, имя, которое передаётся линковщику кодируется и содержит в себе параметры, принимаемые функцией. Если функция в неймспейсе, то в её имени кодируется название неймспейса. Линковщик дальше работает уже с этими декорированными именами, поэтому объявление и определение работают так же, как и без неймспейсов.</p>
<p>Для неймспейсов можно создавать alias'ы: <code>namespace fs = std::filesystem</code>. Редко используется по причина аналогичным неиспользованию тайпдефов.
Можно использовать, например, когда поменяли имя неймспейса, но не хотим ломать код, который уже ссылается на старое.</p>
<h2><a class="header" href="#using-декларация" id="using-декларация">Using-декларация</a></h2>
<pre><code class="language-c++">namespace ns {
  void foo(int);
}
using ns:foo; // на классы тоже можно
</code></pre>
<p>Using-декларация берёт сущность, на которую ссылаемся и как бы объявляет её ещё раз в неймспейсе, в котором она написана.</p>
<p>При этом правило ODR (one defenition) сохраняется:</p>
<pre><code class="language-c++">struct bar{};
using ns::bar; // так нельзя
</code></pre>
<p>Для перегрузок функций всё работает как надо.</p>
<pre><code class="language-c++">namespace ns {
  void foo(int);
}
namespace ns2 {
  void foo(float);
}
int main() {
  using ns::foo;
  using ns2::foo;
  foo(42.5f); 
  return 0;
}
</code></pre>
<p>Using можно применять не только для неймспейсов, но и для классов.</p>
<pre><code class="language-c++">struct base1 {
  void foo(int);
};
struct base2 {
  void foo(float);
};
struct derived : base1, base2 {
  using base1::foo;
  using base2::foo;
};
int main() {
  derived d;
  d.foo(42); // без using не делается overload resolution и будет ошибка, так как два кандидата из разных баз
  return 0;
}
</code></pre>
<p>Ещё можно применить так:</p>
<pre><code class="language-c++">struct base {
  void foo(int);
};
struct derived : private base {
  using base::foo;
};
int main() {
  derived d;
  d.foo(42);
  return 0;
}
</code></pre>
<p>Аналогично можно и с конструкторами:</p>
<pre><code class="language-c++">struct my_error : std::runtime_error {
  using runtime_error::runtime_error;
};
</code></pre>
<p>Можно подключать полностью весь неймспейс: <code>using namespace somelib;</code>. То, что было до этого, называлось <em>using-декларациями</em>, это называется <em>using-директива</em>. По сути, оно говорит при поиске в неймспейсе, где она написана, искать в неймспейсе <code>somelib</code>. Они немного отличаются:</p>
<pre><code class="language-c++">namespace somelib {
  struct foo {};
  void  bar();
}
struct foo {};
// using somelib::foo; такой using приведет к ошибке
// using somelib::bar; 
using namespace somelib; // к ошибке компиляции не приводит
int main() {
  bar(); // так работает
  foo(); // а так ошибка компиляции из-за неоднозначности
}
</code></pre>
<p>Если бы namespace, который мы подключили через директиву, подключал в себе ещё какой-то namespace, то мы бы искали в их замыкании.</p>
<blockquote>
<p>Понятно, что то, что я привожу, это примеры не жизненные, так лучше не писать.</p>
</blockquote>
<pre><code class="language-c++">namespace ns2 {};
namespace ns1 {
  struct foo {};
  using namespace ns2; // юзингает весь неймспейс, то есть в него можно дописать что-то ниже, по смыслу это просто &quot;ссылка&quot; на неймспейс
}
namespace ns2 {
  struct foo {};
  using namespace ns1;
}
using namespace ns1;
int main() {
  foo a; // ошибка, так как поднялись в глобал, зашли в ns1, там using namespace ns2, в их замыкании находим два foo
  ns1::foo a; // это работает, объяснение ниже
}
</code></pre>
<p>Из примеры выше видно, что квалифированные имена работают немного иначе, оно ищет не в замыкании, а сначала ищет в самом неймспейсе, если же в нём нет, то переходит по using namespace. Обычно мы это не заметим, так как неймспейсы используются не так активно и так вообще вряд ли нужно будет писать.</p>
<p>Когда пишем using и alias в хедерах, то они работают везде, куда инклудят этот хедер, что мы редко хотим, поэтому есть такое правило - в хедерах юзинг-директивы и декларации не писать, так как почти никогда не хотим использовать их для пользователя.</p>
<p>Сложный пример:</p>
<pre><code class="language-c++">namespace ns1 {
  uint32_t const a = 1;
  uint32_t const b = 1;
}
namespace ns2 {
  uint32_t const a = 2;
  uint32_t const b = 2;
  namespace nested {
    using ns1::a;
    using ns2::b;
    void foo() {
      std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\n'; // 1 2
    }
  }
}
</code></pre>
<p>А если подключать не декларациями, а <code>using namespace ns1;</code>, то выведет &quot;2 2&quot;. Почему так? Они ищутся не сразу, когда видят директиву, а только когда дойдём до наименьшего общего предка между тем неймспейсом, из которого ищем и тем, которого поюзингали.</p>
<h2><a class="header" href="#adl" id="adl">ADL</a></h2>
<pre><code class="language-c++">namespace somelib {
  struct big_integer {};
  big_integer operator+(big_integer const&amp;, big_integer const&amp;);
  void swap(big_intger&amp;, big_integer&amp;);
}
int main() {
  somelib::big_integer a;
  a + a;
  swap(a, a);
}
</code></pre>
<p>Казалось бы, оператор <code>+</code> не должен находиться, как и <code>swap</code>. Если бы это работало так, то пришлось бы везде писать <code>somelib::operator+</code> или делать using.</p>
<p>Кроме поиска имён, который мы обсудили ранее, есть Argument Depended Lookup. Здесь применяется он тоже: он смотрит на типы аргументов и ищет по неймспейсу, из которого эти типы. Такой поиск запускается только для имён, у которых неквалифицированное имя. У поиска ADL и обычного нет приоритетов, они запускаются оба и кандидаты из обоих уходят в overload resolution. Обычно они либо оба найдут одно и то же, либо обычный не найдет ничего и возьмется из ADL (логично?).</p>
<p>При этом ADL ищет по неймспейсу, в котором класс <code>big_integer</code> был определен. Если мы спрячем определение в неймспейс, а функции сделаем в другом месте, то он их не найдёт.</p>
<p>Стандартная практика применения: когда есть перегруженные операции или функции типа <code>swap</code>. </p>
<pre><code class="language-c++">template &lt;typename U, typename V&gt;
struct my_pair {
  void swap(my_pair&amp; other) { 
    using std::swap;
    swap(u, other.u);
    swap(v, other.v);
  }
}
</code></pre>
<p>В таком случае будет запускаться ADL для пользовательских классов и будет находиться их <code>swap</code>. А для встроенных типов будет <code>std::swap</code> добавлять кандидатом.</p>
<h2><a class="header" href="#Анонимные-неймспейсы" id="Анонимные-неймспейсы">Анонимные неймспейсы</a></h2>
<p>На лекции про компиляцию мы обсуждали модификатор <code>static</code> для функций.</p>
<pre><code class="language-c++">static void foo() {}
</code></pre>
<p>Такой <code>static</code> делал функции локальными для единицы трансляции. А что с классами?</p>
<p>Если мы хотим две разных структуры с одинаковым именем, которые не вытаскиваются из своих хедеров, то просто так может что-то сломаться, так как у них будут, например, генерироваться конструктор, деструктор с одинаковыми именами. А ещё их special member функции генерируютя с модификатором inline и тут какие-то из них линковщик просто выкинет.</p>
<p>А ещё для них будут инстанцироваться шаблоны с одинаковыми декорированными именами, но структуры то разные. Поэтому по стандарту разныъ объявлений классов с одинаковыми именами быть не должно. </p>
<p>Чтобы такого не происходило, существуют анонимные неймспейсы, которые работают следующим образом.</p>
<pre><code class="language-c++">namespace {
  struct my_local_type {
    double b;
  };
  void foo() {}
  const int a = 42;
}
void foo() {
  std::vector&lt;my_local_type&gt; v;
  v.push_back(my_local_type());
}
</code></pre>
<p>Такой код эквивалентен:</p>
<pre><code class="language-c++">namespace XXX {
  struct my_local_type {
    double b;
  };
  void foo() {}
  const int a = 42;
}
using namespace XXX;
void foo() {
  std::vector&lt;my_local_type&gt; v;
  v.push_back(my_local_type());
}
</code></pre>
<p>К чему это приводит: имя таких классов декорируется именем неймспейса, поэтому не будет конфликтов при линковке. Аналогично, как видно, можно делать для функций и для переменных. В общем, это нужно, чтобы делать сущности локальными.</p>
<p>Почему это имеет смысл для функций и переменных:</p>
<pre><code class="language-c++">namespace {
  int a;
  int b;
  int c;
}
mytype&lt;&amp;a&gt; va; // здесь это не как шаблон от целочисленного числа, оно сохраняет именно на какую переменную ссылается параметр
mytype&lt;&amp;b&gt; vb;
mytype&lt;&amp;c&gt; vc;
</code></pre>
<p>В этом примере не будет проблемы, если где-то есть ещё такие объявления, как у <code>va, vb, vc</code>, потому что в этом случае после инстанцирования шаблонов в именах функций закодирован namespace.</p>
<h2><a class="header" href="#static" id="static">static</a></h2>
<pre><code class="language-c++">static void foo(); // локальный для единицы трансляции, обсуждали
struct foo {
  // могут быть private
  static void bar(); // нет параметра *this, можно вызывать foo:bar()
  static int a; // как глобальная переменная, но с именем foo:a, хранится не в каждом экземпляре типа
};
int foo() {
  static int x = 42; // создаётся при первом заходе в функцию, живёт до конца программы и значения будут 43, 44, ...
  ++x;
  return x;
}
</code></pre>
<p>Можно словить рекурсивную инициализацию, это UB, какие-то компиляторы выдают исключение, какие-то зацикливаются, какие-то выдают 0:</p>
<pre><code class="language-c++">int&amp; f();
int g() {
  return f()
}
int&amp; f() {
  static int x = g();
  return x;
}
int main() {
  f();
}
</code></pre>
<h1><a class="header" href="#Пространства-имён-using-декларации-using-директивы-adl-1" id="Пространства-имён-using-декларации-using-директивы-adl-1">Пространства имён, using-декларации, using-директивы, ADL.</a></h1>
<h2><a class="header" href="#Пространства-имён-1" id="Пространства-имён-1">Пространства имён</a></h2>
<p>В Си в библиотеках у функций обычно есть префикс названия библиотеки, например, <code>mpz_add</code> в GMP. Это нужно, чтобы не было двух разных функций с одинаковым именем.</p>
<p>В C++ для такого используется механизм <code>namespace</code>.</p>
<pre><code class="language-c++">namespace somelib {
  struct foo {};
  void bar();
}
namespace somelib { // можно несколько раз открывать
  void baz(foo*);
}
</code></pre>
<p>Внутри неймспейса можно ссылаться на что угодно из него. Синтаксис обращения снаружи: <code>somelib::foo</code>, где <code>somelib::</code> - квалификатор. Такие имена называются квалифицированными. </p>
<p>Неймспейсы могут быть вложенными:</p>
<pre><code class="language-c++">namespace somelib {
  namespace nested {
    struct foo {};
  }
  void bar (nested::foo const&amp;);
}
</code></pre>
<p>Тогда ссылаться надо так: <code>somelib::nested::foo</code>.</p>
<p>Как такие ищутся без квалификаторов? Поднимаемся по фигурным скобкам (неймспейсам) вплоть до глобального.</p>
<p>Если функции на разных уровнях неймспейсов называются по-разному, то выберется первая найденная. Чтобы обратиться к имени из глобального неймспейса, нужно использовать пустой квалификатор <code>::foo</code>. Но это всё про одну единицу трансляции, а что если их несколько?</p>
<p>Как мы помним, имя, которое передаётся линковщику кодируется и содержит в себе параметры, принимаемые функцией. Если функция в неймспейсе, то в её имени кодируется название неймспейса. Линковщик дальше работает уже с этими декорированными именами, поэтому объявление и определение работают так же, как и без неймспейсов.</p>
<p>Для неймспейсов можно создавать alias'ы: <code>namespace fs = std::filesystem</code>. Редко используется по причина аналогичным неиспользованию тайпдефов.
Можно использовать, например, когда поменяли имя неймспейса, но не хотим ломать код, который уже ссылается на старое.</p>
<h2><a class="header" href="#using-декларация-1" id="using-декларация-1">Using-декларация</a></h2>
<pre><code class="language-c++">namespace ns {
  void foo(int);
}
using ns:foo; // на классы тоже можно
</code></pre>
<p>Using-декларация берёт сущность, на которую ссылаемся и как бы объявляет её ещё раз в неймспейсе, в котором она написана.</p>
<p>При этом правило ODR (one defenition) сохраняется:</p>
<pre><code class="language-c++">struct bar{};
using ns::bar; // так нельзя
</code></pre>
<p>Для перегрузок функций всё работает как надо.</p>
<pre><code class="language-c++">namespace ns {
  void foo(int);
}
namespace ns2 {
  void foo(float);
}
int main() {
  using ns::foo;
  using ns2::foo;
  foo(42.5f); 
  return 0;
}
</code></pre>
<p>Using можно применять не только для неймспейсов, но и для классов.</p>
<pre><code class="language-c++">struct base1 {
  void foo(int);
};
struct base2 {
  void foo(float);
};
struct derived : base1, base2 {
  using base1::foo;
  using base2::foo;
};
int main() {
  derived d;
  d.foo(42); // без using не делается overload resolution и будет ошибка, так как два кандидата из разных баз
  return 0;
}
</code></pre>
<p>Ещё можно применить так:</p>
<pre><code class="language-c++">struct base {
  void foo(int);
};
struct derived : private base {
  using base::foo;
};
int main() {
  derived d;
  d.foo(42);
  return 0;
}
</code></pre>
<p>Аналогично можно и с конструкторами:</p>
<pre><code class="language-c++">struct my_error : std::runtime_error {
  using runtime_error::runtime_error;
};
</code></pre>
<p>Можно подключать полностью весь неймспейс: <code>using namespace somelib;</code>. То, что было до этого, называлось <em>using-декларациями</em>, это называется <em>using-директива</em>. По сути, оно говорит при поиске в неймспейсе, где она написана, искать в неймспейсе <code>somelib</code>. Они немного отличаются:</p>
<pre><code class="language-c++">namespace somelib {
  struct foo {};
  void  bar();
}
struct foo {};
// using somelib::foo; такой using приведет к ошибке
// using somelib::bar; 
using namespace somelib; // к ошибке компиляции не приводит
int main() {
  bar(); // так работает
  foo(); // а так ошибка компиляции из-за неоднозначности
}
</code></pre>
<p>Если бы namespace, который мы подключили через директиву, подключал в себе ещё какой-то namespace, то мы бы искали в их замыкании.</p>
<blockquote>
<p>Понятно, что то, что я привожу, это примеры не жизненные, так лучше не писать.</p>
</blockquote>
<pre><code class="language-c++">namespace ns2 {};
namespace ns1 {
  struct foo {};
  using namespace ns2; // юзингает весь неймспейс, то есть в него можно дописать что-то ниже, по смыслу это просто &quot;ссылка&quot; на неймспейс
}
namespace ns2 {
  struct foo {};
  using namespace ns1;
}
using namespace ns1;
int main() {
  foo a; // ошибка, так как поднялись в глобал, зашли в ns1, там using namespace ns2, в их замыкании находим два foo
  ns1::foo a; // это работает, объяснение ниже
}
</code></pre>
<p>Из примеры выше видно, что квалифированные имена работают немного иначе, оно ищет не в замыкании, а сначала ищет в самом неймспейсе, если же в нём нет, то переходит по using namespace. Обычно мы это не заметим, так как неймспейсы используются не так активно и так вообще вряд ли нужно будет писать.</p>
<p>Когда пишем using и alias в хедерах, то они работают везде, куда инклудят этот хедер, что мы редко хотим, поэтому есть такое правило - в хедерах юзинг-директивы и декларации не писать, так как почти никогда не хотим использовать их для пользователя.</p>
<p>Сложный пример:</p>
<pre><code class="language-c++">namespace ns1 {
  uint32_t const a = 1;
  uint32_t const b = 1;
}
namespace ns2 {
  uint32_t const a = 2;
  uint32_t const b = 2;
  namespace nested {
    using ns1::a;
    using ns2::b;
    void foo() {
      std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b &lt;&lt; '\n'; // 1 2
    }
  }
}
</code></pre>
<p>А если подключать не декларациями, а <code>using namespace ns1;</code>, то выведет &quot;2 2&quot;. Почему так? Они ищутся не сразу, когда видят директиву, а только когда дойдём до наименьшего общего предка между тем неймспейсом, из которого ищем и тем, которого поюзингали.</p>
<h2><a class="header" href="#adl-1" id="adl-1">ADL</a></h2>
<pre><code class="language-c++">namespace somelib {
  struct big_integer {};
  big_integer operator+(big_integer const&amp;, big_integer const&amp;);
  void swap(big_intger&amp;, big_integer&amp;);
}
int main() {
  somelib::big_integer a;
  a + a;
  swap(a, a);
}
</code></pre>
<p>Казалось бы, оператор <code>+</code> не должен находиться, как и <code>swap</code>. Если бы это работало так, то пришлось бы везде писать <code>somelib::operator+</code> или делать using.</p>
<p>Кроме поиска имён, который мы обсудили ранее, есть Argument Depended Lookup. Здесь применяется он тоже: он смотрит на типы аргументов и ищет по неймспейсу, из которого эти типы. Такой поиск запускается только для имён, у которых неквалифицированное имя. У поиска ADL и обычного нет приоритетов, они запускаются оба и кандидаты из обоих уходят в overload resolution. Обычно они либо оба найдут одно и то же, либо обычный не найдет ничего и возьмется из ADL (логично?).</p>
<p>При этом ADL ищет по неймспейсу, в котором класс <code>big_integer</code> был определен. Если мы спрячем определение в неймспейс, а функции сделаем в другом месте, то он их не найдёт.</p>
<p>Стандартная практика применения: когда есть перегруженные операции или функции типа <code>swap</code>. </p>
<pre><code class="language-c++">template &lt;typename U, typename V&gt;
struct my_pair {
  void swap(my_pair&amp; other) { 
    using std::swap;
    swap(u, other.u);
    swap(v, other.v);
  }
}
</code></pre>
<p>В таком случае будет запускаться ADL для пользовательских классов и будет находиться их <code>swap</code>. А для встроенных типов будет <code>std::swap</code> добавлять кандидатом.</p>
<h2><a class="header" href="#Анонимные-неймспейсы-1" id="Анонимные-неймспейсы-1">Анонимные неймспейсы</a></h2>
<p>На лекции про компиляцию мы обсуждали модификатор <code>static</code> для функций.</p>
<pre><code class="language-c++">static void foo() {}
</code></pre>
<p>Такой <code>static</code> делал функции локальными для единицы трансляции. А что с классами?</p>
<p>Если мы хотим две разных структуры с одинаковым именем, которые не вытаскиваются из своих хедеров, то просто так может что-то сломаться, так как у них будут, например, генерироваться конструктор, деструктор с одинаковыми именами. А ещё их special member функции генерируютя с модификатором inline и тут какие-то из них линковщик просто выкинет.</p>
<p>А ещё для них будут инстанцироваться шаблоны с одинаковыми декорированными именами, но структуры то разные. Поэтому по стандарту разныъ объявлений классов с одинаковыми именами быть не должно. </p>
<p>Чтобы такого не происходило, существуют анонимные неймспейсы, которые работают следующим образом.</p>
<pre><code class="language-c++">namespace {
  struct my_local_type {
    double b;
  };
  void foo() {}
  const int a = 42;
}
void foo() {
  std::vector&lt;my_local_type&gt; v;
  v.push_back(my_local_type());
}
</code></pre>
<p>Такой код эквивалентен:</p>
<pre><code class="language-c++">namespace XXX {
  struct my_local_type {
    double b;
  };
  void foo() {}
  const int a = 42;
}
using namespace XXX;
void foo() {
  std::vector&lt;my_local_type&gt; v;
  v.push_back(my_local_type());
}
</code></pre>
<p>К чему это приводит: имя таких классов декорируется именем неймспейса, поэтому не будет конфликтов при линковке. Аналогично, как видно, можно делать для функций и для переменных. В общем, это нужно, чтобы делать сущности локальными.</p>
<p>Почему это имеет смысл для функций и переменных:</p>
<pre><code class="language-c++">namespace {
  int a;
  int b;
  int c;
}
mytype&lt;&amp;a&gt; va; // здесь это не как шаблон от целочисленного числа, оно сохраняет именно на какую переменную ссылается параметр
mytype&lt;&amp;b&gt; vb;
mytype&lt;&amp;c&gt; vc;
</code></pre>
<p>В этом примере не будет проблемы, если где-то есть ещё такие объявления, как у <code>va, vb, vc</code>, потому что в этом случае после инстанцирования шаблонов в именах функций закодирован namespace.</p>
<h2><a class="header" href="#static-1" id="static-1">static</a></h2>
<pre><code class="language-c++">static void foo(); // локальный для единицы трансляции, обсуждали
struct foo {
  // могут быть private
  static void bar(); // нет параметра *this, можно вызывать foo:bar()
  static int a; // как глобальная переменная, но с именем foo:a, хранится не в каждом экземпляре типа
};
int foo() {
  static int x = 42; // создаётся при первом заходе в функцию, живёт до конца программы и значения будут 43, 44, ...
  ++x;
  return x;
}
</code></pre>
<p>Можно словить рекурсивную инициализацию, это UB, какие-то компиляторы выдают исключение, какие-то зацикливаются, какие-то выдают 0:</p>
<pre><code class="language-c++">int&amp; f();
int g() {
  return f()
}
int&amp; f() {
  static int x = g();
  return x;
}
int main() {
  f();
}
</code></pre>
<h1><a class="header" href="#Запись-1-11" id="Запись-1-11">Запись №1</a></h1>
<h1><a class="header" href="#move-семантика-rvalue-ссылки" id="move-семантика-rvalue-ссылки">Move-семантика, rvalue-ссылки</a></h1>
<h2><a class="header" href="#rvo-nrvo" id="rvo-nrvo">RVO, NRVO</a></h2>
<p>Часто можно услышать, что передавать параметры по значению и возвращать результат из функции по значению дорого. Но это не всегда так.</p>
<p>Начнём с того, как передаются параметры в функцию. Например, в ABI линукса прописано, что если структура помещается в два регистра, то она передаётся через них. Если структура занимает больше, то есть два варианта:</p>
<pre><code class="language-c++">void f(mytype x) { // как передаётся параметр?
    x.a = 42; 
}
// псевдокод:
void f(mytype const&amp; x) {
    mytype x_copy = x;
    x_copy.a = 42;
}
// вызывающая сторона делает копию и передаёт ссылку
void f(mytype&amp; x) {
    x.a = 42;
}
</code></pre>
<p>Можно посмотреть, во что компилируется функция <code>f</code> и увидеть, что это похоже на второй вариант. </p>
<p>Этот вариант даёт возможность соптимизировать и избегать лишних копирований. Например, в таком случае:</p>
<pre><code class="language-c++">void g() {
    f(mytype(1, 2, 3));
    f(h());
}
</code></pre>
<p>Если в функцию передаётся <code>rvalue</code>, то компилятор не будет делать лишнюю копию. Таким образом, копия делается, только если функция принимает по значению и в неё передаётся <code>lvalue</code>.</p>
<p>Как работает возвращение по значению:</p>
<pre><code class="language-c++">mytype f() {
	return mytype(1, 2, 3);    
}
// компилится во что-то, похожее на:
void f(void* result) {
    mytype_ctor(result, 1, 2, 3);
}
</code></pre>
<p>Эта оптимизация называется <em>Return value optimization</em>: если из функции возвращается <code>rvalue</code>, то копия не создаётся и объект конструируется уже на месте, куда возвращается значение. Начиная с <strong>C++17</strong> эта оптимизация обязательна для компилятора и вошла в стандарт под названием <em>Copy elision</em>.</p>
<p>Помимо этого, есть оптимизация <em>NRVO (named RVO)</em>, которая позволяет избежать копирования при возврате automatic storage duration объекта. На данный момент эта оптимизация необязательная, но уже есть <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2025r0.html">proposal</a> на внедрение этого в стандарт</p>
<pre><code class="language-c++">std::string f() {
    std::string tmp;
    for (;;) {
        tmp += ...;
    }
    return tmp;
}
// можно разместить tmp уже на result-е, псевдокод:
void f(void* result) {
    string_ctor(result, &quot;abc&quot;);
    for (;;) {
        *result += ...;
    }
}
</code></pre>
<p>Применить её можно не во всех случаях. Например:</p>
<pre><code class="language-c++">std::string g() {
    std::string a(&quot;abc&quot;);
    std::string b(&quot;def&quot;);
    if (flag) {
        return a;
    } else {
        return b;
    }
}
</code></pre>
<p>Ещё один пример, когда избегается копирование:</p>
<pre><code class="language-c++">void g() {
    mytype a = f(); // здесь не будет вызван конструктор копирования
}
</code></pre>
<p>Так всё работало ещё в <strong>C++03</strong>, в <strong>C++11</strong> помимо оптимизаций, появилась <em>move-семантика</em></p>
<h2><a class="header" href="#move-семантика" id="move-семантика">Move-семантика</a></h2>
<p>Многие контейнеры требуют от объектов наличие конструктора копирования. Например, вектору он нужен для увеличения буфера. При этом объект нельзя скопировать побайтово через <code>memcpy</code>, потому что это изменит его адрес, что возможно не для всех объектов (например, для тех, которые передают куда-нибудь наружу указатель <code>this</code>).</p>
<p>Но есть такие объекты, у которых дорогое копирование, которого можно избежать (например, <code>std::string</code> с буфером), а ещё те, у которых копирование в принципе нельзя определить (как <code>unique_ptr</code>).</p>
<p>Эту проблему решает семантика перемещений. Она реализуется при помощи перемещающего конструктора (<code>move constructor</code>) и перемещающего оператора присваивания (<code>move assignment</code>).</p>
<p>Передача объекта в такой конструктор может испортить передаваемый объект, но этот объект должен остаться в таком согласованном состоянии, что у него можно вызвать деструктор. При этом это состояние в общем случае unspecified и полагаться на него не следует.</p>
<pre><code class="language-c++">struct string {
    // ...
    string(string&amp;&amp; other) {
        data = other.data; // копируем указатель вместо самих данных
        other.data = nullptr;
        size = other.size;
        other.size = 0;
    }
    private:
    char* data;
}
</code></pre>
<p>Move в C++ называется &quot;недеструктивным&quot;, так как объект остаётся валидным, просто в unspecified состоянии.</p>
<p>Для упрощения синтаксиса в язык были введены <em>rvalue-ссылки</em>, чтобы move оператор и конструктор срабатывал автоматически и не нужно было указывать это как-то явно.</p>
<h3><a class="header" href="#Ссылки" id="Ссылки">Ссылки</a></h3>
<p>Начиная с <strong>C++11</strong> обычные ссылки называются lvalue-ссылками. Для rvalue-ссылок свойства ссылок сохраняются, но, они биндятся только к rvalue.</p>
<pre><code class="language-c++">int main() {
    int a;
    int&amp; b = a;
    int&amp; c = 42;
    int&amp;&amp; d = a; // ошибка
    int&amp;&amp; e = 42;
}
</code></pre>
<p>Теперь можно делать перегрузки для rvalue-ссылок:</p>
<pre><code class="language-c++">template&lt;typename T&gt;
struct vector {
    void push_back(T const&amp;);
    void push_back(T&amp;&amp;);
}
</code></pre>
<p>В каждом месте, где делается <code>push_back</code> от rvalue, будет вызываться перегрузка именно для rvalue-ссылки.</p>
<p>Важный принцип: именованные переменные они всегда lvalue, независимо от того, какой у неё тип. </p>
<pre><code class="language-c++">struct person {
    person(std::string&amp;&amp; name) {
        // здесь name - lvalue
        // this.name = name; - простое копирование
        this.name = std::move(name); // вызовет move-конструктор
    }
}
</code></pre>
<p>Что такое <code>std::move</code>? Это почти что <code>static_cast</code>. Её сигнатура похожа на следующее:</p>
<pre><code class="language-c++">template&lt;typename T&gt;
T&amp;&amp; move(T&amp; obj) {
    return static_cast&lt;T&amp;&amp;&gt;(obj);
}
</code></pre>
<p>В стандартной библиотеке у move сигнатура немного отличается. Написанная выше функция не может принимать rvalue (например, <code>std::move(42)</code> не скомпилируется), в стандартной библиотеке move устроен таким образом, что он работает и для rvalue тоже.</p>
<p>Если мы хотим у конструктора, описанного выше, больше параметров, то делать перегрузки на каждую комбинацию сложно. Какое поведение конструктора мы ожидаем? Для параметров, переданных как lvalue, сделать копию, а rvalue переместить. В языке уже есть конструкция, которая делает то же самое - можно просто принять параметр по значению.</p>
<pre><code class="language-c++">struct person {
    person(std::string name, std::string surname)
        : name(std::move(name)), 
    	  surname(std::move(surname)) {}
}
</code></pre>
<p>Так мы получим нужно поведение за исключением того, что иногда move-конструктор вызовется лишний раз (когда делаем копию и вызываем move). Обычно это оптимизируется и не влияет на производительность, но при необходимости  можно сделать разные перегрузки.</p>
<p><strong>Не стоит использовать move там, где он не нужен</strong>:</p>
<p>Иногда может возникать желание написать похожую конструкцию:</p>
<pre><code class="language-c++">std::string&amp;&amp; foo() {
    std::string res;
    res += &quot;abc&quot;;
    return std::move(res); 
}
</code></pre>
<p>Из-за move такое, скорее всего, скомпилируется, но работать не будет, так как ссылка указывает на локальную переменную, которая уничтожится после выхода из функции.</p>
<p>Есть правило, что если даже NRVO не сработало, то при возвращении по значению вызовется move.</p>
<pre><code class="language-c++">std::string foo() {
    std::string res;
    res += &quot;abc&quot;;
    return res; // вызовет move при возврате, если не сработало NRVO
}
</code></pre>
<h2><a class="header" href="#value-category-в-c11" id="value-category-в-c11">Value category в C++11</a></h2>
<p>В C++11 <a href="https://blog.panicsoftware.com/value-categories-gl-l-x-r-prvalues/">категории значений</a> были расширены. Кроме lvalue и rvalue, появилось xvalue.</p>
<p><img src="images/09.05_value_category.jpg" alt="img" /></p>
<p><code>prvalue</code> - то, что раньше мы называли <code>rvalue</code></p>
<p><code>xvalue</code> - то, что для перегрузок <code>rvalue</code>, а для copy elision `glvalue``</p>
<pre><code class="language-c++">struct mytype {};
mytype lvalue;
mytype&amp; lvalue();
mytype prvalue();
mytype&amp;&amp; xvalue(); // overloading: rvalue, copy elision: lvalue
void test() {
    mytype c = lvalue; // mytype(mytype)
    mytype b = prvalue(); // copy elision
    mytype a = xvalue(); // mytype(mytype&amp;&amp;)
}
mytype test2() {
    return xvalue(); 
}
</code></pre>
<p>С одной стороны, <code>xvalue</code> возвращает rvalue, но мы не можем применить RVO. Поэтому функция <code>xvalue</code> для перегрузок работает как rvalue, а с точки зрения copy elision как lvalue.</p>
<p>В C++03 время жизни объекта, который биндится к <code>const&amp;</code>, продлевалось для rvalue. В C++11 xvalue ведутся себя подобно lvalue: время жизни объекта продлить нельзя, так как мы его  никак не контролируем.</p>
<pre><code class="language-c++">void foo() {
    mytype const&amp; a = prvalue(); // объект живёт столько, сколько эта ссылка
    mytype&amp;&amp; a = prvalue(); // аналогично продлевает время жизни
    
    mytype&amp; a = lvalue(); // не продлевает
    mytype&amp;&amp; a = xvalue(); // не продлевает
}
</code></pre>
<h1><a class="header" href="#move-семантика-rvalue-ссылки-1" id="move-семантика-rvalue-ссылки-1">Move-семантика, rvalue-ссылки</a></h1>
<h2><a class="header" href="#rvo-nrvo-1" id="rvo-nrvo-1">RVO, NRVO</a></h2>
<p>Часто можно услышать, что передавать параметры по значению и возвращать результат из функции по значению дорого. Но это не всегда так.</p>
<p>Начнём с того, как передаются параметры в функцию. Например, в ABI линукса прописано, что если структура помещается в два регистра, то она передаётся через них. Если структура занимает больше, то есть два варианта:</p>
<pre><code class="language-c++">void f(mytype x) { // как передаётся параметр?
    x.a = 42; 
}
// псевдокод:
void f(mytype const&amp; x) {
    mytype x_copy = x;
    x_copy.a = 42;
}
// вызывающая сторона делает копию и передаёт ссылку
void f(mytype&amp; x) {
    x.a = 42;
}
</code></pre>
<p>Можно посмотреть, во что компилируется функция <code>f</code> и увидеть, что это похоже на второй вариант. </p>
<p>Этот вариант даёт возможность соптимизировать и избегать лишних копирований. Например, в таком случае:</p>
<pre><code class="language-c++">void g() {
    f(mytype(1, 2, 3));
    f(h());
}
</code></pre>
<p>Если в функцию передаётся <code>rvalue</code>, то компилятор не будет делать лишнюю копию. Таким образом, копия делается, только если функция принимает по значению и в неё передаётся <code>lvalue</code>.</p>
<p>Как работает возвращение по значению:</p>
<pre><code class="language-c++">mytype f() {
	return mytype(1, 2, 3);    
}
// компилится во что-то, похожее на:
void f(void* result) {
    mytype_ctor(result, 1, 2, 3);
}
</code></pre>
<p>Эта оптимизация называется <em>Return value optimization</em>: если из функции возвращается <code>rvalue</code>, то копия не создаётся и объект конструируется уже на месте, куда возвращается значение. Начиная с <strong>C++17</strong> эта оптимизация обязательна для компилятора и вошла в стандарт под названием <em>Copy elision</em>.</p>
<p>Помимо этого, есть оптимизация <em>NRVO (named RVO)</em>, которая позволяет избежать копирования при возврате automatic storage duration объекта. На данный момент эта оптимизация необязательная, но уже есть <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2025r0.html">proposal</a> на внедрение этого в стандарт</p>
<pre><code class="language-c++">std::string f() {
    std::string tmp;
    for (;;) {
        tmp += ...;
    }
    return tmp;
}
// можно разместить tmp уже на result-е, псевдокод:
void f(void* result) {
    string_ctor(result, &quot;abc&quot;);
    for (;;) {
        *result += ...;
    }
}
</code></pre>
<p>Применить её можно не во всех случаях. Например:</p>
<pre><code class="language-c++">std::string g() {
    std::string a(&quot;abc&quot;);
    std::string b(&quot;def&quot;);
    if (flag) {
        return a;
    } else {
        return b;
    }
}
</code></pre>
<p>Ещё один пример, когда избегается копирование:</p>
<pre><code class="language-c++">void g() {
    mytype a = f(); // здесь не будет вызван конструктор копирования
}
</code></pre>
<p>Так всё работало ещё в <strong>C++03</strong>, в <strong>C++11</strong> помимо оптимизаций, появилась <em>move-семантика</em></p>
<h2><a class="header" href="#move-семантика-1" id="move-семантика-1">Move-семантика</a></h2>
<p>Многие контейнеры требуют от объектов наличие конструктора копирования. Например, вектору он нужен для увеличения буфера. При этом объект нельзя скопировать побайтово через <code>memcpy</code>, потому что это изменит его адрес, что возможно не для всех объектов (например, для тех, которые передают куда-нибудь наружу указатель <code>this</code>).</p>
<p>Но есть такие объекты, у которых дорогое копирование, которого можно избежать (например, <code>std::string</code> с буфером), а ещё те, у которых копирование в принципе нельзя определить (как <code>unique_ptr</code>).</p>
<p>Эту проблему решает семантика перемещений. Она реализуется при помощи перемещающего конструктора (<code>move constructor</code>) и перемещающего оператора присваивания (<code>move assignment</code>).</p>
<p>Передача объекта в такой конструктор может испортить передаваемый объект, но этот объект должен остаться в таком согласованном состоянии, что у него можно вызвать деструктор. При этом это состояние в общем случае unspecified и полагаться на него не следует.</p>
<pre><code class="language-c++">struct string {
    // ...
    string(string&amp;&amp; other) {
        data = other.data; // копируем указатель вместо самих данных
        other.data = nullptr;
        size = other.size;
        other.size = 0;
    }
    private:
    char* data;
}
</code></pre>
<p>Move в C++ называется &quot;недеструктивным&quot;, так как объект остаётся валидным, просто в unspecified состоянии.</p>
<p>Для упрощения синтаксиса в язык были введены <em>rvalue-ссылки</em>, чтобы move оператор и конструктор срабатывал автоматически и не нужно было указывать это как-то явно.</p>
<h3><a class="header" href="#Ссылки-1" id="Ссылки-1">Ссылки</a></h3>
<p>Начиная с <strong>C++11</strong> обычные ссылки называются lvalue-ссылками. Для rvalue-ссылок свойства ссылок сохраняются, но, они биндятся только к rvalue.</p>
<pre><code class="language-c++">int main() {
    int a;
    int&amp; b = a;
    int&amp; c = 42;
    int&amp;&amp; d = a; // ошибка
    int&amp;&amp; e = 42;
}
</code></pre>
<p>Теперь можно делать перегрузки для rvalue-ссылок:</p>
<pre><code class="language-c++">template&lt;typename T&gt;
struct vector {
    void push_back(T const&amp;);
    void push_back(T&amp;&amp;);
}
</code></pre>
<p>В каждом месте, где делается <code>push_back</code> от rvalue, будет вызываться перегрузка именно для rvalue-ссылки.</p>
<p>Важный принцип: именованные переменные они всегда lvalue, независимо от того, какой у неё тип. </p>
<pre><code class="language-c++">struct person {
    person(std::string&amp;&amp; name) {
        // здесь name - lvalue
        // this.name = name; - простое копирование
        this.name = std::move(name); // вызовет move-конструктор
    }
}
</code></pre>
<p>Что такое <code>std::move</code>? Это почти что <code>static_cast</code>. Её сигнатура похожа на следующее:</p>
<pre><code class="language-c++">template&lt;typename T&gt;
T&amp;&amp; move(T&amp; obj) {
    return static_cast&lt;T&amp;&amp;&gt;(obj);
}
</code></pre>
<p>В стандартной библиотеке у move сигнатура немного отличается. Написанная выше функция не может принимать rvalue (например, <code>std::move(42)</code> не скомпилируется), в стандартной библиотеке move устроен таким образом, что он работает и для rvalue тоже.</p>
<p>Если мы хотим у конструктора, описанного выше, больше параметров, то делать перегрузки на каждую комбинацию сложно. Какое поведение конструктора мы ожидаем? Для параметров, переданных как lvalue, сделать копию, а rvalue переместить. В языке уже есть конструкция, которая делает то же самое - можно просто принять параметр по значению.</p>
<pre><code class="language-c++">struct person {
    person(std::string name, std::string surname)
        : name(std::move(name)), 
    	  surname(std::move(surname)) {}
}
</code></pre>
<p>Так мы получим нужно поведение за исключением того, что иногда move-конструктор вызовется лишний раз (когда делаем копию и вызываем move). Обычно это оптимизируется и не влияет на производительность, но при необходимости  можно сделать разные перегрузки.</p>
<p><strong>Не стоит использовать move там, где он не нужен</strong>:</p>
<p>Иногда может возникать желание написать похожую конструкцию:</p>
<pre><code class="language-c++">std::string&amp;&amp; foo() {
    std::string res;
    res += &quot;abc&quot;;
    return std::move(res); 
}
</code></pre>
<p>Из-за move такое, скорее всего, скомпилируется, но работать не будет, так как ссылка указывает на локальную переменную, которая уничтожится после выхода из функции.</p>
<p>Есть правило, что если даже NRVO не сработало, то при возвращении по значению вызовется move.</p>
<pre><code class="language-c++">std::string foo() {
    std::string res;
    res += &quot;abc&quot;;
    return res; // вызовет move при возврате, если не сработало NRVO
}
</code></pre>
<h2><a class="header" href="#value-category-в-c11-1" id="value-category-в-c11-1">Value category в C++11</a></h2>
<p>В C++11 <a href="https://blog.panicsoftware.com/value-categories-gl-l-x-r-prvalues/">категории значений</a> были расширены. Кроме lvalue и rvalue, появилось xvalue.</p>
<p><img src="images/09.05_value_category.jpg" alt="img" /></p>
<p><code>prvalue</code> - то, что раньше мы называли <code>rvalue</code></p>
<p><code>xvalue</code> - то, что для перегрузок <code>rvalue</code>, а для copy elision `glvalue``</p>
<pre><code class="language-c++">struct mytype {};
mytype lvalue;
mytype&amp; lvalue();
mytype prvalue();
mytype&amp;&amp; xvalue(); // overloading: rvalue, copy elision: lvalue
void test() {
    mytype c = lvalue; // mytype(mytype)
    mytype b = prvalue(); // copy elision
    mytype a = xvalue(); // mytype(mytype&amp;&amp;)
}
mytype test2() {
    return xvalue(); 
}
</code></pre>
<p>С одной стороны, <code>xvalue</code> возвращает rvalue, но мы не можем применить RVO. Поэтому функция <code>xvalue</code> для перегрузок работает как rvalue, а с точки зрения copy elision как lvalue.</p>
<p>В C++03 время жизни объекта, который биндится к <code>const&amp;</code>, продлевалось для rvalue. В C++11 xvalue ведутся себя подобно lvalue: время жизни объекта продлить нельзя, так как мы его  никак не контролируем.</p>
<pre><code class="language-c++">void foo() {
    mytype const&amp; a = prvalue(); // объект живёт столько, сколько эта ссылка
    mytype&amp;&amp; a = prvalue(); // аналогично продлевает время жизни
    
    mytype&amp; a = lvalue(); // не продлевает
    mytype&amp;&amp; a = xvalue(); // не продлевает
}
</code></pre>
<h1><a class="header" href="#Запись-1-12" id="Запись-1-12">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-11" id="Запись-2-11">Запись №2</a></h1>
<h1><a class="header" href="#Интрузивные-контейнеры" id="Интрузивные-контейнеры">Интрузивные контейнеры</a></h1>
<p>В лекции часто упоминается статья <a href="https://www.codeofhonor.com/blog/avoiding-game-crashes-related-to-linked-lists">&quot;Avoiding game crashes related to linked lists&quot;</a> про то, как в Starcarft применяли интрузивные списки, и статья <a href="https://www.data-structures-in-practice.com/intrusive-linked-lists/">Intrusive linked lists in practice</a></p>
<p>Так же может быть полезно смотреть на <a href="slides/intrusive.pdf">слайды к лекции</a>.</p>
<hr />
<h2><a class="header" href="#Мотивационный-пример" id="Мотивационный-пример">Мотивационный пример</a></h2>
<p>Задача: есть набор юнитов, нужно хранить подмножество каких-то выделенных. Наивное решение такое:</p>
<pre><code class="language-c++">struct unit {
    unit* prev;
    unit* next;
}
std:unordered_set&lt;unit*&gt; selected;
</code></pre>
<p><img src="images/09.12_nonintrusive_units.png" alt="non-intrusive units" /></p>
<p>Как оптимально хранить это? Одно из решений - для каждого юнита хранить <code>selected_next</code> и <code>selected_prev</code>.</p>
<pre><code class="language-c++">struct unit {
    unit* prev;
    unit* next;
    unit* selected_prev;
    unit* selected_next;
}
</code></pre>
<p><img src="images/09.12_intrusive_units.png" alt="intrusive units" /></p>
<p>Зачем это нужно? Удаление таких элементов из списка будет работать за константу без поиска, так как сам <code>unit</code> является узлом списка.</p>
<p>Преимущества такой реализации:</p>
<ul>
<li>Нет аллокаций при вставке/удалении</li>
<li>Двусвязный список использовать &quot;дешевле&quot;, чем хеш-таблицу</li>
<li>Локальность ссылок при итерации по элементам</li>
</ul>
<p>Но тратим больше памяти - храним по два указателя на каждый юнит, а не только выбранный.</p>
<p>Всё это обобщается на другие структуры данных: двусвязные списки, деревья, хеш-таблицы со списками. </p>
<p>Например, так можно реализовать LRU-кэш:</p>
<pre><code class="language-c++">Value f(Key key);

std::unordered_map&lt;Key, Value&gt; cache;
</code></pre>
<p>Хотим ограничить размер кэша. Для этого элементы провяжем двусвязным списком и будем удалять самый давний по использованию.</p>
<pre><code class="language-c++">struct node {
    Key key;
    Value value;
    // ordered by key
    node* left;
    node* right;
    node* parent;
    // ordered by value
    node* next;
    node* prev;
}
</code></pre>
<p>Тогда при обращении к элементу из кэша, он будет перекидываться в хвост, а при нехватке места, будет удалять элемент из головы списка.</p>
<h2><a class="header" href="#Обобщение-до-контейнера" id="Обобщение-до-контейнера">Обобщение до контейнера</a></h2>
<h3><a class="header" href="#c-style-подход" id="c-style-подход">C-style подход</a></h3>
<pre><code class="language-c">struct list_element {
    list_element* prev;
    list_element* next;
};
struct unit {
    list_element all_units_node;
    // ...
    list_element selected_node;
    // ...
};
</code></pre>
<p><img src="images/09.12_intrusive_c.png" alt="C-style unit" /></p>
<p>У такого подхода есть недостаток - перебор по контейнеру идёт по <code>list_element</code> и получить сам <code>unit</code> не так тривиально:</p>
<pre><code class="language-c++">#define container_of(ptr, type, member) \
	((type*)((char*)(ptr) - offsetof(type, member)))
</code></pre>
<p>По стандарту такое корректно только для C-style структур (например, без виртуальных функций). Иначе это работает, но будет ворнинг, что это нарушает стандарт.</p>
<h3><a class="header" href="#c-подход" id="c-подход">C++ подход</a></h3>
<p>Как сделать такое корректно средствами C++? Использовать базовых классы, так как каст к ним работает аналогично.</p>
<pre><code class="language-c++">struct list_element {
    list_element* prev;
    list_element* next;
};
struct unit : list_element {};
</code></pre>
<p>Проблема возникает в том случае, если мы хотим вставить <code>unit</code> в несколько списков, то есть сделать ему несколько базовых классов <code>list_element</code>. На помощь приходят шаблоны:</p>
<pre><code class="language-c++">template &lt;typename Tag&gt;
struct list_element {
    list_element* prev;
    list_element* next;
};
struct all_units_tag {};
struct selected_units_tag {};
struct unit : list_element&lt;all_units_tag&gt;, list_element&lt;selected_units_tag&gt; {};
</code></pre>
<p>В <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0406r1.html">proposal</a> в стандартную библиотеку использовался именно такой приём.</p>
<p>Замечание: не обязательно типы тегов должны быть полными. Кроме того, их можно объявить прямо в объявлении <code>unit</code>.</p>
<pre><code class="language-c++">struct unit : list_element&lt;struct all_units_tag&gt;, list_element&lt;struct selected_units_tag&gt; {};
</code></pre>
<p>Реализация intrusive контейнеров есть в <a href="https://www.boost.org/doc/libs/1_71_0/doc/html/intrusive.html">библиотеке Boost</a>. Для контейнеров из буста можно задать разное поведение <code>list_element</code> при разрушении <code>unit</code>:</p>
<ul>
<li>Ничего не делать (пользователь обязан удалить юнит из списков перед тем, как удалять его)</li>
<li>Safe hook - проверяет, что элемент удалился из всех списков</li>
<li>Unlink hook - отвязывает элемент от всех списков, в которых он находится</li>
</ul>
<h2><a class="header" href="#Полезное-применение" id="Полезное-применение">Полезное применение:</a></h2>
<pre><code class="language-c++">struct person {
    std::string name;
    std::string id;
    std::string company_name;
    int min;
}
</code></pre>
<p>Можно хранить объекты и искать, например, по имени и по id, при помощи <a href="https://www.boost.org/doc/libs/1_62_0/libs/multi_index/doc/index.html">boost.multi_index</a>.</p>
<p><img src="images/09.12_boost_multi_index.png" alt="boost multi_index" /></p>
<h2><a class="header" href="#intrusive_ptr" id="intrusive_ptr">intrusive_ptr</a></h2>
<p>Похож на <code>shared_ptr</code>, но счётчик ссылок хранится в самом объекте (похоже на <code>make_shared</code>, при использовании которого счётчик ссылок и объект создавались рядом в памяти). В отличие от <code>shared_ptr</code>, позволяет без динамических аллокаций реализовать разделённое владение объектом. </p>
<p>Каждый новый инстанс <code>intrusive_ptr</code> увеличивает счетчик ссылок вызовом функции <code>intrusive_ptr_add_ref</code>, которая должна быть определена у объекта, при удалении вызывает у объекта функцию <code>intrusive_ptr_release</code>, которая отвечает за разрушение объекта, если счетчик ссылок стал равен нулю.</p>
<p>В библиотеке есть вспомогательный базовый класс <code>intrusive_ref_counter</code>, от которого можно наследовать пользовательские типы, чтобы реализовать поддержку <code>intrusive_ptr</code>.</p>
<p>Подробнее можно почитать в <a href="https://www.boost.org/doc/libs/1_60_0/libs/smart_ptr/intrusive_ptr.html">документации Boost</a></p>
<h1><a class="header" href="#Интрузивные-контейнеры-1" id="Интрузивные-контейнеры-1">Интрузивные контейнеры</a></h1>
<p>В лекции часто упоминается статья <a href="https://www.codeofhonor.com/blog/avoiding-game-crashes-related-to-linked-lists">&quot;Avoiding game crashes related to linked lists&quot;</a> про то, как в Starcarft применяли интрузивные списки, и статья <a href="https://www.data-structures-in-practice.com/intrusive-linked-lists/">Intrusive linked lists in practice</a></p>
<p>Так же может быть полезно смотреть на <a href="slides/intrusive.pdf">слайды к лекции</a>.</p>
<hr />
<h2><a class="header" href="#Мотивационный-пример-1" id="Мотивационный-пример-1">Мотивационный пример</a></h2>
<p>Задача: есть набор юнитов, нужно хранить подмножество каких-то выделенных. Наивное решение такое:</p>
<pre><code class="language-c++">struct unit {
    unit* prev;
    unit* next;
}
std:unordered_set&lt;unit*&gt; selected;
</code></pre>
<p><img src="images/09.12_nonintrusive_units.png" alt="non-intrusive units" /></p>
<p>Как оптимально хранить это? Одно из решений - для каждого юнита хранить <code>selected_next</code> и <code>selected_prev</code>.</p>
<pre><code class="language-c++">struct unit {
    unit* prev;
    unit* next;
    unit* selected_prev;
    unit* selected_next;
}
</code></pre>
<p><img src="images/09.12_intrusive_units.png" alt="intrusive units" /></p>
<p>Зачем это нужно? Удаление таких элементов из списка будет работать за константу без поиска, так как сам <code>unit</code> является узлом списка.</p>
<p>Преимущества такой реализации:</p>
<ul>
<li>Нет аллокаций при вставке/удалении</li>
<li>Двусвязный список использовать &quot;дешевле&quot;, чем хеш-таблицу</li>
<li>Локальность ссылок при итерации по элементам</li>
</ul>
<p>Но тратим больше памяти - храним по два указателя на каждый юнит, а не только выбранный.</p>
<p>Всё это обобщается на другие структуры данных: двусвязные списки, деревья, хеш-таблицы со списками. </p>
<p>Например, так можно реализовать LRU-кэш:</p>
<pre><code class="language-c++">Value f(Key key);

std::unordered_map&lt;Key, Value&gt; cache;
</code></pre>
<p>Хотим ограничить размер кэша. Для этого элементы провяжем двусвязным списком и будем удалять самый давний по использованию.</p>
<pre><code class="language-c++">struct node {
    Key key;
    Value value;
    // ordered by key
    node* left;
    node* right;
    node* parent;
    // ordered by value
    node* next;
    node* prev;
}
</code></pre>
<p>Тогда при обращении к элементу из кэша, он будет перекидываться в хвост, а при нехватке места, будет удалять элемент из головы списка.</p>
<h2><a class="header" href="#Обобщение-до-контейнера-1" id="Обобщение-до-контейнера-1">Обобщение до контейнера</a></h2>
<h3><a class="header" href="#c-style-подход-1" id="c-style-подход-1">C-style подход</a></h3>
<pre><code class="language-c">struct list_element {
    list_element* prev;
    list_element* next;
};
struct unit {
    list_element all_units_node;
    // ...
    list_element selected_node;
    // ...
};
</code></pre>
<p><img src="images/09.12_intrusive_c.png" alt="C-style unit" /></p>
<p>У такого подхода есть недостаток - перебор по контейнеру идёт по <code>list_element</code> и получить сам <code>unit</code> не так тривиально:</p>
<pre><code class="language-c++">#define container_of(ptr, type, member) \
	((type*)((char*)(ptr) - offsetof(type, member)))
</code></pre>
<p>По стандарту такое корректно только для C-style структур (например, без виртуальных функций). Иначе это работает, но будет ворнинг, что это нарушает стандарт.</p>
<h3><a class="header" href="#c-подход-1" id="c-подход-1">C++ подход</a></h3>
<p>Как сделать такое корректно средствами C++? Использовать базовых классы, так как каст к ним работает аналогично.</p>
<pre><code class="language-c++">struct list_element {
    list_element* prev;
    list_element* next;
};
struct unit : list_element {};
</code></pre>
<p>Проблема возникает в том случае, если мы хотим вставить <code>unit</code> в несколько списков, то есть сделать ему несколько базовых классов <code>list_element</code>. На помощь приходят шаблоны:</p>
<pre><code class="language-c++">template &lt;typename Tag&gt;
struct list_element {
    list_element* prev;
    list_element* next;
};
struct all_units_tag {};
struct selected_units_tag {};
struct unit : list_element&lt;all_units_tag&gt;, list_element&lt;selected_units_tag&gt; {};
</code></pre>
<p>В <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0406r1.html">proposal</a> в стандартную библиотеку использовался именно такой приём.</p>
<p>Замечание: не обязательно типы тегов должны быть полными. Кроме того, их можно объявить прямо в объявлении <code>unit</code>.</p>
<pre><code class="language-c++">struct unit : list_element&lt;struct all_units_tag&gt;, list_element&lt;struct selected_units_tag&gt; {};
</code></pre>
<p>Реализация intrusive контейнеров есть в <a href="https://www.boost.org/doc/libs/1_71_0/doc/html/intrusive.html">библиотеке Boost</a>. Для контейнеров из буста можно задать разное поведение <code>list_element</code> при разрушении <code>unit</code>:</p>
<ul>
<li>Ничего не делать (пользователь обязан удалить юнит из списков перед тем, как удалять его)</li>
<li>Safe hook - проверяет, что элемент удалился из всех списков</li>
<li>Unlink hook - отвязывает элемент от всех списков, в которых он находится</li>
</ul>
<h2><a class="header" href="#Полезное-применение-1" id="Полезное-применение-1">Полезное применение:</a></h2>
<pre><code class="language-c++">struct person {
    std::string name;
    std::string id;
    std::string company_name;
    int min;
}
</code></pre>
<p>Можно хранить объекты и искать, например, по имени и по id, при помощи <a href="https://www.boost.org/doc/libs/1_62_0/libs/multi_index/doc/index.html">boost.multi_index</a>.</p>
<p><img src="images/09.12_boost_multi_index.png" alt="boost multi_index" /></p>
<h2><a class="header" href="#intrusive_ptr-1" id="intrusive_ptr-1">intrusive_ptr</a></h2>
<p>Похож на <code>shared_ptr</code>, но счётчик ссылок хранится в самом объекте (похоже на <code>make_shared</code>, при использовании которого счётчик ссылок и объект создавались рядом в памяти). В отличие от <code>shared_ptr</code>, позволяет без динамических аллокаций реализовать разделённое владение объектом. </p>
<p>Каждый новый инстанс <code>intrusive_ptr</code> увеличивает счетчик ссылок вызовом функции <code>intrusive_ptr_add_ref</code>, которая должна быть определена у объекта, при удалении вызывает у объекта функцию <code>intrusive_ptr_release</code>, которая отвечает за разрушение объекта, если счетчик ссылок стал равен нулю.</p>
<p>В библиотеке есть вспомогательный базовый класс <code>intrusive_ref_counter</code>, от которого можно наследовать пользовательские типы, чтобы реализовать поддержку <code>intrusive_ptr</code>.</p>
<p>Подробнее можно почитать в <a href="https://www.boost.org/doc/libs/1_60_0/libs/smart_ptr/intrusive_ptr.html">документации Boost</a></p>
<h1><a class="header" href="#Запись-1-13" id="Запись-1-13">Запись №1</a></h1>
<h1><a class="header" href="#Разбор-практики-по-intrusive_list" id="Разбор-практики-по-intrusive_list">Разбор практики по intrusive_list</a></h1>
<h1><a class="header" href="#Код-intrusive_list" id="Код-intrusive_list">Код intrusive_list</a></h1>
<h1><a class="header" href="#smart-pointers-unique_ptr-shared_ptr-weak_ptr" id="smart-pointers-unique_ptr-shared_ptr-weak_ptr">Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></h1>
<h1><a class="header" href="#smart-pointers-unique_ptr-shared_ptr-weak_ptr-1" id="smart-pointers-unique_ptr-shared_ptr-weak_ptr-1">Smart pointers: unique_ptr, shared_ptr, weak_ptr</a></h1>
<h1><a class="header" href="#Запись-1-14" id="Запись-1-14">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-12" id="Запись-2-12">Запись №2</a></h1>
<h1><a class="header" href="#perfect-forwarding" id="perfect-forwarding">Perfect forwarding</a></h1>
<p>Когда мы говорили про <code>shared_ptr</code>, у нас была функция <code>make_shared</code>, которая принимала какие-то аргументы и передавала их в конструктор. </p>
<p>Посмотрим на возможные реализацию такой функции (для упрощения на примере одного параметра):</p>
<pre><code class="language-c++">template&lt;typename T&gt;
void g1(T a){
    f(a);
}
template&lt;typename T&gt;
void g2(T const&amp; a){
    f(a);
}
template&lt;typename T&gt;
void g3(T&amp; a){
    f(a);
}
</code></pre>
<p>Все 3 случая не подходят:</p>
<ul>
<li>Принимать по значению неприятно, если объект дорого копировать</li>
<li>Принимать по <code>const&amp;</code> не получится, если на самом деле функция <code>f</code> принимает ссылку</li>
<li>Принимать по <code>&amp;</code> нельзя, так как она не биндится к <code>rvalue</code></li>
</ul>
<p>Можно было бы сделать перегрузку с <code>&amp;</code> и <code>const&amp;</code>, но тогда нужно 2^n перегрузок для n параметров, что не очень удобно.</p>
<p><strong>Perfect forwarding</strong> - принять аргументы и передать их куда-то с теми свойствами, с которыми они пришли (rvalue/lvalue, cv). В C++11 есть специальный механизм для решения этой проблемы. Чтобы понять, как оно работает, нужно познакомиться с правилами вывода ссылок в C++11.</p>
<h2><a class="header" href="#reference-collapsing-rule" id="reference-collapsing-rule">Reference collapsing rule</a></h2>
<p>В C++ нельзя сделать ссылку на ссылку, поэтому ссылки схлопываются (коллапсятся):</p>
<pre><code class="language-c++">typedef int&amp; mytype1;
typedef mytype1&amp; mytype2;
static_assert(std::is_same_v&lt;mytype2, mytype1&gt;); // true

template &lt;typename T&gt;
void foo(T&amp;);

int main() {
    foo&lt;int&amp;&gt;(); // void foo(int&amp;)
}
</code></pre>
<p>Это было в языке всегда с момента появления ссылок. Когда появились rvalue ссылки, правила схлопывания ссылок доопределили:</p>
<pre><code class="language-plain">&amp; &amp; -&gt; &amp;
&amp; &amp;&amp; -&gt; &amp;
&amp;&amp; &amp; -&gt; &amp;
&amp;&amp; &amp;&amp; -&gt; &amp;&amp;
</code></pre>
<h2><a class="header" href="#universal-reference" id="universal-reference">Universal reference</a></h2>
<p>Чтобы сделать perfect forwarding, нужно как-то запомнить, передавалось в шаблон rvalue или lvalue. В C++11 правила вывода шаблонных параметров были определены специальным образом, который позволяет сохранить эту информацию:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void g(T&amp;&amp; a) {
    f(a);
}

int main {
    g(42); // rvalue: T -&gt; int, void g(int&amp;&amp;)
    int a;
    g(a); // lvalue: T -&gt; int&amp;, void g(int&amp;)
}
</code></pre>
<p>Такие ссылки (шаблонный параметр + rvalue-ссылка) называются <em>универсальными</em>. </p>
<h2><a class="header" href="#stdforward" id="stdforward">std::forward</a></h2>
<p>Как передавать параметр дальше? Внутри тела функции параметр это именованная переменная, поэтому она lvalue (ситуация очень похожа на то, как вводили <code>std::move</code>).  Для этого передачи параметра так, как он пришёл, существует <code>std::forward</code>. </p>
<p>Можно сделать так:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void g(T&amp;&amp; a) {
    f(static_cast&lt;T&amp;&amp;&gt;(a));
}

int main {
    g(42); // rvalue: T -&gt; int, void g(int&amp;&amp;), f(static_cast&lt;int&amp;&amp;&gt;(a))
    int a;
    g(a); // lvalue: T -&gt; int&amp;, void g(int&amp;), f(static_cst&lt;int&amp;&gt;(a))
}
</code></pre>
<p>Библиотечная функция написана примерно так:</p>
<pre><code class="language-c++">template&lt;typename T&gt;
T&amp;&amp; forward(T&amp; obj) {
    return static_cast&lt;T&amp;&amp;&gt;(obj);
}

template &lt;typename T&gt;
void g(T&amp;&amp; a) {
    f(forward&lt;T&gt;(a));
}
</code></pre>
<p>Такой <code>forward</code> может быть не очень хорошим по нескольким причинам:</p>
<ul>
<li>Если забыть написать тип явно в вызове, то он будет выводится и выведется не так, как нам надо. </li>
</ul>
<p>Это фиксится следующим образом:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct type_identity {
    typedef T type;
};

template &lt;typename T&gt;
T&amp;&amp; forward(typename type_identity&lt;T&gt;::type&amp; obj) {
    return static_cast&lt;T&amp;&amp;&gt;(obj);
}
</code></pre>
<p>В STL вместо <code>type_identity</code> используется <code>remove_reference</code>. Так же есть перегрузка для rvalue (<code>T&amp;&amp;</code>), которая применяется, например, для форварда значения, возвращаемого функцией.</p>
<h2><a class="header" href="#variadic-template" id="variadic-template">Variadic template</a></h2>
<p>Осталось понять, как делать функцию, принимающую произвольное число шаблонных параметров. Для этого в C++ сделали специальный синтаксис:</p>
<pre><code class="language-c++">template &lt;typename... T&gt;
void g(T&amp;&amp; ...args) {
    f(std::forward&lt;T&gt;(args)...);
}
</code></pre>
<p>Можно думать, что <code>...</code> пишутся там, где обычно аргументы перечисляются через запятую.</p>
<h1><a class="header" href="#perfect-forwarding-1" id="perfect-forwarding-1">Perfect forwarding</a></h1>
<p>Когда мы говорили про <code>shared_ptr</code>, у нас была функция <code>make_shared</code>, которая принимала какие-то аргументы и передавала их в конструктор. </p>
<p>Посмотрим на возможные реализацию такой функции (для упрощения на примере одного параметра):</p>
<pre><code class="language-c++">template&lt;typename T&gt;
void g1(T a){
    f(a);
}
template&lt;typename T&gt;
void g2(T const&amp; a){
    f(a);
}
template&lt;typename T&gt;
void g3(T&amp; a){
    f(a);
}
</code></pre>
<p>Все 3 случая не подходят:</p>
<ul>
<li>Принимать по значению неприятно, если объект дорого копировать</li>
<li>Принимать по <code>const&amp;</code> не получится, если на самом деле функция <code>f</code> принимает ссылку</li>
<li>Принимать по <code>&amp;</code> нельзя, так как она не биндится к <code>rvalue</code></li>
</ul>
<p>Можно было бы сделать перегрузку с <code>&amp;</code> и <code>const&amp;</code>, но тогда нужно 2^n перегрузок для n параметров, что не очень удобно.</p>
<p><strong>Perfect forwarding</strong> - принять аргументы и передать их куда-то с теми свойствами, с которыми они пришли (rvalue/lvalue, cv). В C++11 есть специальный механизм для решения этой проблемы. Чтобы понять, как оно работает, нужно познакомиться с правилами вывода ссылок в C++11.</p>
<h2><a class="header" href="#reference-collapsing-rule-1" id="reference-collapsing-rule-1">Reference collapsing rule</a></h2>
<p>В C++ нельзя сделать ссылку на ссылку, поэтому ссылки схлопываются (коллапсятся):</p>
<pre><code class="language-c++">typedef int&amp; mytype1;
typedef mytype1&amp; mytype2;
static_assert(std::is_same_v&lt;mytype2, mytype1&gt;); // true

template &lt;typename T&gt;
void foo(T&amp;);

int main() {
    foo&lt;int&amp;&gt;(); // void foo(int&amp;)
}
</code></pre>
<p>Это было в языке всегда с момента появления ссылок. Когда появились rvalue ссылки, правила схлопывания ссылок доопределили:</p>
<pre><code class="language-plain">&amp; &amp; -&gt; &amp;
&amp; &amp;&amp; -&gt; &amp;
&amp;&amp; &amp; -&gt; &amp;
&amp;&amp; &amp;&amp; -&gt; &amp;&amp;
</code></pre>
<h2><a class="header" href="#universal-reference-1" id="universal-reference-1">Universal reference</a></h2>
<p>Чтобы сделать perfect forwarding, нужно как-то запомнить, передавалось в шаблон rvalue или lvalue. В C++11 правила вывода шаблонных параметров были определены специальным образом, который позволяет сохранить эту информацию:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void g(T&amp;&amp; a) {
    f(a);
}

int main {
    g(42); // rvalue: T -&gt; int, void g(int&amp;&amp;)
    int a;
    g(a); // lvalue: T -&gt; int&amp;, void g(int&amp;)
}
</code></pre>
<p>Такие ссылки (шаблонный параметр + rvalue-ссылка) называются <em>универсальными</em>. </p>
<h2><a class="header" href="#stdforward-1" id="stdforward-1">std::forward</a></h2>
<p>Как передавать параметр дальше? Внутри тела функции параметр это именованная переменная, поэтому она lvalue (ситуация очень похожа на то, как вводили <code>std::move</code>).  Для этого передачи параметра так, как он пришёл, существует <code>std::forward</code>. </p>
<p>Можно сделать так:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
void g(T&amp;&amp; a) {
    f(static_cast&lt;T&amp;&amp;&gt;(a));
}

int main {
    g(42); // rvalue: T -&gt; int, void g(int&amp;&amp;), f(static_cast&lt;int&amp;&amp;&gt;(a))
    int a;
    g(a); // lvalue: T -&gt; int&amp;, void g(int&amp;), f(static_cst&lt;int&amp;&gt;(a))
}
</code></pre>
<p>Библиотечная функция написана примерно так:</p>
<pre><code class="language-c++">template&lt;typename T&gt;
T&amp;&amp; forward(T&amp; obj) {
    return static_cast&lt;T&amp;&amp;&gt;(obj);
}

template &lt;typename T&gt;
void g(T&amp;&amp; a) {
    f(forward&lt;T&gt;(a));
}
</code></pre>
<p>Такой <code>forward</code> может быть не очень хорошим по нескольким причинам:</p>
<ul>
<li>Если забыть написать тип явно в вызове, то он будет выводится и выведется не так, как нам надо. </li>
</ul>
<p>Это фиксится следующим образом:</p>
<pre><code class="language-c++">template &lt;typename T&gt;
struct type_identity {
    typedef T type;
};

template &lt;typename T&gt;
T&amp;&amp; forward(typename type_identity&lt;T&gt;::type&amp; obj) {
    return static_cast&lt;T&amp;&amp;&gt;(obj);
}
</code></pre>
<p>В STL вместо <code>type_identity</code> используется <code>remove_reference</code>. Так же есть перегрузка для rvalue (<code>T&amp;&amp;</code>), которая применяется, например, для форварда значения, возвращаемого функцией.</p>
<h2><a class="header" href="#variadic-template-1" id="variadic-template-1">Variadic template</a></h2>
<p>Осталось понять, как делать функцию, принимающую произвольное число шаблонных параметров. Для этого в C++ сделали специальный синтаксис:</p>
<pre><code class="language-c++">template &lt;typename... T&gt;
void g(T&amp;&amp; ...args) {
    f(std::forward&lt;T&gt;(args)...);
}
</code></pre>
<p>Можно думать, что <code>...</code> пишутся там, где обычно аргументы перечисляются через запятую.</p>
<h1><a class="header" href="#Запись-1-15" id="Запись-1-15">Запись №1</a></h1>
<h1><a class="header" href="#Запись-2-13" id="Запись-2-13">Запись №2</a></h1>
<h1><a class="header" href="#contributing" id="contributing">CONTRIBUTING</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>

# Ещё немного про классы
[Примеры к лекции](https://github.com/sorokin/cpp-course/blob/gh-pages/demos/string-demo/main.cpp)

## Special member функции

- Default constructor - сгенерированный компиляторов конструктор, пустой, создается только если нет других конструкторов. Вы

- Destructor - вызывается при выходите из области видимости, должен чистить память. Вызываются в обратном порядке по отношению к порядку вызовов конструктора.

	```c++
	~my_string(){
	     free(data_);
	}
	```

	

- Copy constructor:

  ```c++
  my_string(my_string const& other){
       size_ = other.size_;
       capacity_ = other.capacity_;
       data_ = (char*)malloc(size_ + 1);
       memcpy(data_, other.data_, size_ + 1);	
  }
  ```

  Если конструктор копирования не написан, то сгенерируется компилятором, но копировать будет указатели без выделения новой памяти. Так, например, у двух объектов `my_string` будут одинаковые указатели на `data_` и при выходе из области видимости, оба деструктора вызовут `free(data_)`. 

- Assignment operator - похоже на конструктор копирования, но не создает объект, а меняет уже существующий.
	
	```c++
	my_string& operator=(my_string const& other){
	     if (this != &other){ 
	          // важно проверить, что не присваиваем a = a
	          // иначе почистим data_ у себя же
	          free(data_);
	          size_ = other.size_;
	          capacity_ = other.capacity_;
	          data_ = (char*)malloc(size_ + 1);
	          memcpy(data_, other.data_, size_ + 1);	
	     }
	     return *this;
	}
	```

Как запретить копирования и присваивания?

```c++
my_string& operator=(my_string const&) = delete;
my_string(my_string const&) = delete;
```

Также можно явно создать дефолтный конструктор (например, если есть уже какой-то другой и из-за него дефолтный не сгенерируется):

```c++
my_string() = default;
my_string(my_string const&) = default;
```

Так ещё может быть полезно писать, чтобы явно документировать, что дефолтный подходит.

Отличается ли чем-то пустой конструктор от дефолтного?  Пустой конструктор - это *user-defined* конструктор. Структура с *default* конструктором - это  *trivially constructible*. Для них, например, при создании массива не будут вызываться конструкторы.

### Список инициализации

Позволяет инициализировать поля без лишних вызовов операторов присваивания (например, `name = "Ivan"` это то же самое, что `name = my_string("Ivan")`)

```c++
person() : name("Ivan"), surname ("Sorokin") {
	...
}
```

Хорошее правило - порядок инициализации такой же, как порядок объявления полей.

## Выделение памяти

```c++
void * p = malloc(42); // выделяем 42 байта
free(p); // чистит память, выделенную по указателю p
free(p); // так плохо
p = nullptr;
free(p); // так можно, ничего не произойдет
```

### new, delete

`new` выделяет память под объект и вызывает конструктор, `delete`вызывает деструктор и освобождает память

```c++
person* p = new person[10]; // выделяет память на 10 объектов person и вызывает их дефолтные конструкторы
delete[] p; // если new вызывался с []
```

## Препроцессор

Препроцессор смотрит целиком токены и не будет заменять, например, часть названия переменной.

Можно использовать function-like макросы:

```c++
#define check(pred) pred + 2
check(x) /// заменится на x + 2
```

Препроцессор ничего не знает про язык и работает только с макросами, поэтому нужно аккуратно следить за приоритетом операций.

Препроцессор не заменяет ничего в других макросах, при этом подстановка работает только один раз:

```c++
#define hello hello
hello // не зациклится, подставит только один раз
```


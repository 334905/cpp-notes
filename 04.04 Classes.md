# Классы, абстракция данных
[Примеры к лекции](https://github.com/sorokin/cpp-course/blob/gh-pages/demos/string-demo/main.cpp)

## Структуры

С помощью структур можно создавать свои типы. У структуры есть поля и методы. У полей и методов есть модификаторы доступа `public`, `private`, `protected`. По дефолту все поля и методы структуры - `public`.

Классы отличаются от структур только тем, что в классах по умолчанию все `private`, а в структурах `public`. Далее всё будет называться классами

К полям класса можно обращать сразу через указатель на экземпляр:

```c++
complex * c;
c->im // то же самое, что (*c).im
```

В отличие от языка `C`, в `C++` можно объявлять методы у структур.

```c++
struct complex {
	void conjugate() {	
		im = -im;
	}
private:
	double re;
     double im;
};
```
Чем отличается метод внутри класса от такой функции?

```C++
void conjugate(complex* c) {
     c->im = -c->im; 
}
```

- У метода есть неявный параметр - указатель `this` на текущий экземпляр

- Метод имеет доступ к приватным полям, внешняя функция - нет

#### Что должно быть `private`, а что `public`?

Инвариант класса - сохраняющиеся свойства класса. Например, инварианты структуры данных.
> То, что может испортить инвариант класса, должно быть private

**Важно**: писать объявления функций стоит в `class.h`, а определения в `class.cpp`, чтобы не было проблем с тем, что определение попадает в несколько единиц трансляции.

```c++
// struct.h:
struct complex {
     void conjugate();
private:
     double re;
     double im;
}
// struct.cpp:
void complex::conjugate(){
     im = -im;
}
```

## Конструкторы и деструкторы

Классы можно создавать через конструкторы:

```c++
struct complex {
     complex(re, im) {
          this.re = re;
          this.im = im;
     }
	void conjugate() {	
		im = -im;
	}
private:
	double re;
     double im;
};
```
Если в классе есть конструктор от одного аргумента, то может происходить неявное приведение типов (например, `big_integer a = 42`, если конструктор принимает `int`). Чтобы подавить такое поведение, конструктор нужно объявить с модификатором `explicit`.  

Так же существуют деструкторы, освобождающие память при не использовании объекта. Они вызываются когда объект выходит из "зоны видимости":

```C++
	~string()
	{
		free(data);
		...
	}
```
## Немного про const

Ключевое слово `const` - неизменяемое.
```c++
	int const PI = 3;
	int const* q = &PI; 
	//int *q = &PI; - кинет ошибку
	*q = 4;
	
	int		 *		 a; - указатель на int
	int	const*		 b; - указатель на константный int
	int		 * const b; - константный указатель на int
	int const* const c; - константный указатель на константный int
```

В функцию, которая принимает указатель, нельзя передать указатель на `const`

## Операторы

В С++ есть возможность определять собственные операторы для классов:
```c++
complex operator+(complex a, complex b)
{
	return complex(a.re + b.re, a.im + a.im)
}
```
Если вы пишете какой то оператор, то хотя бы 1 из его элементов должен быть пользовательским типом (нельзя переопределить оператор для `int, int`)
Еще пример:

```c++
complex operator+=(complex a, complex b) {}
```
Мы такое сделать не можем, так как нужно поменять а => передать его по указателю. `&a += b`, что не естественно.
Сделать такое можно, использкя ссылки:


|указатель		|	ссылка			|
|---------------|-------------------|
|`int* p = &a;`	|	`int& r = a;`	|
|`*p = 5;`		|	`r = 5;`		|
|`int *pp = p`	|	`int* pr = &r;`	|
|`p->foo`|	`p.foo;`	|
|`p = &b;`		|	`//такого нет`	|
Нужно делать так:
```c++
complex& operator+=(complex &a, complex b)
{
	return a = a + b;
}
```
То все будет работать.

Если мы принимаем экземпляр класса и нам не нужно его менять, можно передавать его по константной ссылке, тогда мы избегаем лишних копирований:

```C++
std::ostream& operator<<(std::ostream& os, complex const& a){
     os << a.real << " + " << a.im << "i";
     return os;
}
```

При этом если функция принимает `const&`, то в неё можно передавать временный объект (rvalue). 

#### Перегрузка операторов внутри класса и снаружи:

У операторов, перегруженных как функция, может срабатывать неявное приведение типов (если есть не `explicit` конструктор), для методов - нет.

При этом если первый аргумент оператора встроенный тип, то его нужно перегрузить как функцию.

Некоторые операторы необходимо перегружать внутри класса: `(type), [], (), ->, ->*, =`

### Еще немного про указатели:

Если функция принимает массив: `void f(int a[10])`, то на самом деле она принимает `int *` и длина игнорируется.
Но если функция принимает указатель на многомерный массив: `void g(int (*p)[10])`, то она принимает указатель на массив длины 10. Все размерности, кроме внешней, должны быть определены, так как являются частью типа элемента.

Важно:` int *p[10]` - массив указателей, `int (*p)[10]` - указатель на массив длины 10.

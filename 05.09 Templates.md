## Шаблоны

Часто очень хочется делать типизированный класс - например, какую-то структуру данных для разных типов. Здесь и применяются шаблоны.

В Си их не было и было два способа реализовать такое:

- Хранить внутри данные "любого типа" как `void*`, но это неудобно, потому что нельзя хранить ничего, что занимает больше памяти, чем `void*`.  Можно хранить указатели, но это не очень эффективно из-за кэш-промахов.

- Через `#define`:

	```c++
	#define DECLASE_MYVECTOR(type)              \
	strict my_vector_##(type)                   \
	{                                           \
	     void push_back(type);                  \
		type operator[](size_t index) const;   \
	}                                             
	```

	У дефайнов несколько проблем: если ссылать на один тип по-разному через `typedef`, то будут генериться два разных класса, которые по сути одно и то же. А ещё нельзя с длинными типами типа `unsigned short`. А ещё может возникнуть дублирование.

Как это делают ~~нормальные люди~~ в С++:

```c++
template <typename T>
// template<class T> это то же самое
struct vector {
     void push_back(T const &);
     T const& operator[](size_t index) const;
}
```

Функции тоже можно типизировать:

```c++
template<typename T>
void swap(T& a, T& b) {
     T tmp = a;
     a = b;
     b = tmp;
}
```

### Специализации

Иногда для каких-то типов хочется сделать отдельную реализацию. Например, `vector<bool>`. Это называется специализацией и делается так:

```c++
template <>
struct vector<booL> {
     // ...
};
```

Можно делать partial специализацию, например для указателей:

```c++
template <typename V>
struct vector<V*> {
     // ...
}
vector<foo*> c; // выберется эта специализация
```

Есть ещё `std::conditional`, чтобы "заифать типы".

Есть ли у функций специализации? Да, но нельзя делать patial и вообще чаще всего достаточно перегрузок.

```c++
template<typename T>
void foo(T*);

template<>
void foo<int>(int*);
// void foo(int*); 
```

Чем отличаются две последних функции? Например, на таком коде:

```c++
int main() {
     foo(nullptr); // не работает со специализацией
}
```

Для функций алгоритм выбора такой: 

1. Выбирается перегрузка.
2. Внутри перегрузки выбирается специализация.

Подробнее про **Template argument deduction** в [доке](https://en.cppreference.com/w/cpp/language/template_argument_deduction).

Поэтому когда мы подставляем `nullptr`, то из него нельзя понять, на какой тип он указывает, поэтому **deduction** фейлится и получаем ошибку. Если же есть `void foo<int>(int*)`, то выбирается он, как единственный подходящий.

Есть ещё одно правило: *если есть нешаблонная функция, которая идеально совпадает с шаблонной, то выбирается нешаблонная*.

```c++
template <typename U, typename V>
struct mytype{};

template <typename U, typename V>
struct mytype<U*, V>{};

template <typename U, typename V>
struct mytype<U, V*>{};

// В таком случае нельзя делать так:
mytype<long*, double*> f;
```

Можно делать *non-type* шаблонные параметры:

```c++
template <typename T, size_t N>
struct array {
     T data[N];
}
// можно делать специализацию:
template <typname T>
struct array<T, 0> {};

array<int, 10> a;
array<int, 0> a;
```

А ещё есть такое:

```c++
template <template <typename T> class C>
struct array {
};

template <typename T> 
struct cc {
     
};

array<cc> a;
```

Шаблонные параметры могут иметь дефолтные значения:

```c++
struct default_comparer {};
templte<typename T, typename C = default_comparer>
struct set {};

set<int> a; // юзает дефолтный C
```

### Немного про парсер C++

```c++
(foo::a)-b; // может быть бинарное вычитание или каст -b к типу а
int a(b); // может быть конструктор или определение функции
a < b && c > d; // может быть шаблон a<b&&c> d, а может быть буловое выражение
```

Как компилятор различает, например, в случае `(foo::a)-b`? Особенно если это всё не в одной функции. Здесь работает такое правило: *по умолчанию считаем, что в скобках не тип*.

Пример:

```c++
struct foo {
     static float a;
};
struct bar {
     typedef float a;
};

template<typename T>
void f(){
     int b;
     (T::a)-b;
}

int main{
     f<foo>();
     f<bar>(); // не компилируется
}
```

Если хотим, чтобы это читалось как каст, то нужно писать `(typename T::a)-b`. Кстати, в старых компиляторов *Microsoft* это не было нужно, так как они откладывали токены и парсили только в момент, когда подставляют функцию.

Аналогично для шаблонов по умолчанию считается не шаблоном, иначе нужно писать так:

```c++
T::a < b && c > d; // по умолчанию не шаблон
T::template a < b && c > d; // а это шаблон
```




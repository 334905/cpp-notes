## Прерывания

Почему программа с вечным циклом не повесит нам весь компьютер? (даже если 1 ядро)
Как ОС работает с устройствами?

- _Polling_ - процессор сам опрашивает устройства, когда необходимо
- _Interrupt_ (прерывание) - устройство само говорит об изменении, процессор вызывает обработчик прерываний.

**Local timer interrupt** - прерывание, ОС может сделать:

- Продолжить выполнение процесса
- Сохранить состояние первого процесса и запустить вторую

Как ОС работает с памятью? Ядро ОС придерживается 2 принципов:

- _hardware abstraction_ - мышка может быть подключена по-разному подключенной, но программе всё равно
- _isolation process_ - программа не может повлиять на другие программы (записать в их память)

Как это достигается:

__Физическая память__ - реальный модуль памяти (как на ЭВМ)

__Виртуальная память__ - пространство памяти процессов. Обращение по адресу памяти в программе - обращение по адресу в виртуальной памяти. 
Процесс преобразования из виртуальной в физическую называется *страничной адресацией*.

## Страничная адресация

Память процесса может лежать в физической памяти в любом порядке:

![иллюстрация разобщенности памяти процессов](https://lh3.googleusercontent.com/3bjis4tFuLLCGRN9sWvT--CDxBqX90ePws2PA10Z4dAEFjZoQ20rPxe9TD9CwHecKRbxU5wH1a9N)

Адресация реализуется через _PageTables_.

Вместо массива на много элементов храним массив (_каталог страниц_) размера 1024 из указателей на массивы размерами по 1024 (_таблицы страниц_). Почему это удобнее? Некоторые таблицы можно не хранить, если нужно выделить не все.

Это выглядит как-то так:

![страничная адресация](https://lh3.googleusercontent.com/Ab3UYTM8rGYbDegvJgYfX0dwrEud8KBbuFzydkEnW-knxajrZrc0kdqI5hWLzacxnyVn51DxOMwl)



Подробнее можно прочитать тут: https://wiki.osdev.org/Paging

## Механизм адресации на уровне процессора:

**Пример адреса:**
Virtual adress - 0x123456789A

Младшие 12 бит виртуального адреса: смещение внутри страницы. Следующие 10 бит - индекс в таблице страниц, старшие 10 бит - индекс в каталоге страниц.  

```c++
typedef uint32_t page_table_element;
typedef uint32_t virtual_address;
struct page_directory
{
     uint32_t translate(virtual_address);
     private:
     	page_table_element data[1024];
};
```

Альтернативы:

* _Хеш-таблица_: плохо взаимодействует с кэшем. Использовалась в PowerPC

Это всё было про _32-битную архитектуру_. На _64-битной_ числа так красиво не сходятся. Используют следующее: добавляется ещё один уровень (можно и не один, на самом деле), массивы делают по 512. 

Пример: процессор может транслировать только 48 бит (соответствует размеру дерева из уровней). Физической памяти - 39 бит. Почему? "Сколько пинов у процессора есть, чтобы обращаться к памяти, столько и бит". 
Остальные биты в 64-битном адресе заполнены одинаковыми значениями и мы их не используем.

В регистре **CR3** хранится указатель на каталог страниц для процесса.

## Про стек вызовов и frame pointer

**rip** - регистр, в котором хранится указатель на текущую инструкцию (?)

```nasm
main:
	mov		rdx, 42
	push		43
	push		44
	call		bar
bar:	sub		rsp, 40
	; 
	add		rsp,40
	ret
```

Как понять, кто вызывал функцию?

В скомпилированном коде рядом с ним хранится информация о том, как получать *return address*.

На https://godbolt.org можно посмотреть, скомпилировав с флагами `-O2  -fno-omit-frame-pointer` следующий код:

```nasm
int foo(char const*);

int bar()
{
    char arr[40];
    return foo(arr) + 1;
}
```

Компилируется во что-то такое:

```nasm
bar:
	push		rbp
	mov		rbp, rsp
	sub		rbp, 40
	;
	mov		rsp, rbp
	pop		rbp
	ret
```

**rbp** - регистр, который используется для указания на frame стека. По нему компилятор может восстановить стек вызовов (выглядит как односвязный список).




## Прерывания

Почему программа с вечным циклом не повесит нам весь компьютер? (даже если 1 ядро)
Как ОС работает с устройствами?

- _Polling_ - процессор сам опрашивает устройства, когда необходимо
- _Interrupt_ (прерывание) - устройство само говорит об изменении, процессор вызывает обработчик прерываний.

**Local timer interrupt** - прерывание, ОС может сделать:

- Продолжить выполнение процесса
- Сохранить состояние первого процесса и запустить вторую

Как ОС работает с памятью? Ядро ОС придерживается 2 принципов:

- _hardware abstraction_ - мышка может быть подключена по-разному подключенной, но программе всё равно
- _isolation process_ - программа не может повлиять на другие программы (записать в их память)

Как это достигается:

__Физическая память__ - реальный модуль памяти (как на ЭВМ)

__Виртуальная память__ - пространство памяти процессов. Обращение по адресу памяти в программе - обращение по адресу в виртуальной памяти. 
Процесс преобразования из виртуальной в физическую называется *страничной адресацией*.

## Страничная адресация

Память процесса может лежать в физической памяти в любом порядке:

![иллюстрация разобщенности памяти процессов](https://lh3.googleusercontent.com/3bjis4tFuLLCGRN9sWvT--CDxBqX90ePws2PA10Z4dAEFjZoQ20rPxe9TD9CwHecKRbxU5wH1a9N)

Адресация реализуется через _PageTables_.

Вместо массива на много элементов храним массив (_каталог страниц_) размера 1024 из указателей на массивы размерами по 1024 (_таблицы страниц_). Почему это удобнее? Некоторые таблицы можно не хранить, если нужно выделить не все.

Это выглядит как-то так:

![страничная адресация](https://lh3.googleusercontent.com/Ab3UYTM8rGYbDegvJgYfX0dwrEud8KBbuFzydkEnW-knxajrZrc0kdqI5hWLzacxnyVn51DxOMwl)



Подробнее можно прочитать тут: https://wiki.osdev.org/Paging

## Механизм адресации на уровне процессора:

**Пример адреса:**
Virtual adress - 0x123456789A

Младшие 12 бит виртуального адреса: смещение внутри страницы. Следующие 10 бит - индекс в таблице страниц, старшие 10 бит - индекс в каталоге страниц.  

```c++
typedef uint32_t page_table_element;
typedef uint32_t virtual_address;
struct page_directory
{
     uint32_t translate(virtual_address);
     private:
     	page_table_element data[1024];
};
```

Альтернативы:

* _Хеш-таблица_: плохо взаимодействует с кэшем. Использовалась в PowerPC

Это всё было про _32-битную архитектуру_. На _64-битной_ числа так красиво не сходятся. Используют следующее: добавляется ещё один уровень (можно и не один, на самом деле), массивы делают по 512. 

Пример: процессор может транслировать только 48 бит (соответствует размеру дерева из уровней). Физической памяти - 39 бит. Почему? "Сколько пинов у процессора есть, чтобы обращаться к памяти, столько и бит". 
Остальные биты в 64-битном адресе заполнены одинаковыми значениями и мы их не используем.

# Кэш, Branch prediction и другое
Как работает `malloc - free`? ОС выделяет 4Кб и "откусывает" понемногу оттуда. Как "откусывает"?
Уточним модель процессора:
```
for i = 0..n				for i=0..n
	for j=0..n					for j=0..n
		a[i][j] = 0 				a[j][i] = 0
```
У этих 2 кодов большая разница из-за процессорного кэша.
**Кэши** реализованы через хэштаблицы (дискр. размера) ключ - адрес памяти, значение - что лежит
Линии кэша ~64байта : ассоциативность кэша - кол-во buckets.
**Аппаратное предсказане** - подгрузка в кэш заранее

## Конвейер (Pipelining)
Что мы делаем при условных переходах? Выполняем какую-то ветку и если угададли - ок, иначе отменим.
**Branch prediction** - прогнозирование, выполняем одну ветку if, если не угадали - откатываем

> Written with [StackEdit](https://stackedit.io/).
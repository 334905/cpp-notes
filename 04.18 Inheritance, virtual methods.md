# Наследование и виртуальные функции



```c++
struct vehicle {
     std::string registration_number;
};
struct bus : vehicle {
     int32_t route_number;
     std::string next_stop() const;
};
struct truck : vehicle {
     double cargo_mass;
};
```
`bus` содержит и `route_number`, и `registration_number`.
Компилятор ищет методы и поля сначала внутри последнего, наследовавшего класса. Поэтому обращение к одинаковым полям класса будет возвращать поле последнего.
Если поля классов совпадают в названии, то обратиться к полю другого можно либо через приведение, либо через `classname:field`.
Наследующий класс можно приводить к любому наследуемому классу и наоборот.
С методами в наследовании работают точно так же как и с полями:

```c++
struct base {
	void g();
};
struct derived : base {
	void g();
};
int main() {
	derived d;
	d.g(); // запустит g() из derived
	d.base::g(); // запустит g() из base
}
```
При создании объектов класса-наследника вызывается дефолтный конструктор базового класса (в порядке от базового к производному, деструкторы наоборот). Если хотим вызывать какой-то определённый конструктор, то можно вызывать его через списки инициализации:

```c++
struct bus : vehicle {
     bus(std::string const& registration_number, std::string const& next_stop_name) 
          : vehicle(registration_number), next_stop_name(next_stop_name){}
}
```

**Как не нужно наследоваться**: если вы не добавляете новых данных, то, возможно, вам не нужно наследование и хватит просто функций.

### Виртуальные функции

Зачем нужно наследование? Чаще всего его используют вместе с такими конструкциями, как виртуальные функции. Реализованы они через так называемую таблицу виртуальных функций.

Функции можно пометить кодовым словом `virtual`. Если функция `virtual`, то вызывается функция в соответствии динамическим, а не статическим типом (определяется в рантайме).

```c++
struct vehicle {
     virtual void print_name(){
          std::cout << "vehicle" << std::endl;
     }
}
struct bus : vehicle {
	void print_name() {
          std::cout << "bus" << std::endl;
     }
}
void f (vehicle& a) {
     a.print_name();
}
int main() {
     bus b;
     b.print_name();
     f(b); // выведет bus, так как print_name виртуальный
}
```
Чаще всего для базового класса тяжело разумно определить копирование и присваивание, поэтому помечаем их `delete`.

Деструктор базового класса лучше объявлять виртуальным: в таком случае обеспечивается правильное разрушение объектов (чтобы всегда вызывался конструктор производного класса).

### Множественное наследование
В C++ у класса может быть несколько базовых:
```c++
struct base1 {int a;};
struct base2 {int a;};
struct base3 : base1, base2{int d;};
int main() {
	base3 z;
     z.a; // нескомпилируется
	z.base2::a = 1; // возьмет поле base2
}
```

### Абстрактные методы (и классы):

Если в классе есть хотя бы одна абстрактная функция (ещё их называют чистыми виртуальными), то класс считается абстрактным и создавать объекты такого типа нельзя.

```c++
struct output_device {
     void write(void const* data, size_t size) = 0; // обязательство реализации у наследников
};
struct speakers : output_device {};
struct twitch_stream : output_device {};
struct null_output : output_device {};
```

### Ещё немного про виртуальные деструкторы:

```c++
struct base1 {
     int a;
};
struct base2 {
     int b;
};
struct derived : base1, bae2 {};
int main () {
     derived* d = new derived();
     base2* b = d;
     delete b; // UB, скорее всег получим ошибку о том, что b - невалидный указатель
}
```

Почему ошибка именно такая? Это из-за того, как наследование реализовано внутри: по указателю на `derived` подряд лежат `base1` и `base2` (можно понять, если посмотреть, во что компилируется приведение к ним). По сути, в `delete b` мы пытаемся освободить не то, что аллоцировали, а то, что лежит по указателю `derived+4`. 

Ещё забавно: приведение ссылок и указателей компилируются по-разному, потому что `nullptr` после приведения должен оставаться `nullptr`.

### Чуть-чуть про приведение типов (cast):

Представим, что у нас получился такой код (такое иногда бывает, если части приходят из разных хедеров):

```c++
struct base1 {
     int a;
};
struct base2 {
     int b;
};
struct derived;
derived& to_derived(base2& b) {
     return (derived&)b;
}
struct derived : base1, base2 {};
derived& to_derived_2(base2& b) {
     return (derived&)b;
}
```

Функции `to_derived` и `to_derived_2` скомпилируются в разный код, потому что на момент компиляции `to_derived` типы `base2` и `derived` - несвязанные и Си-шные касты втупую приводят указатели для них.

Как такого избежать (хотя бы словить ошибку)? Использовать C++-style касты:

```c++
derived& to_derived(base2& b) {
     return static_cast<derived&>(b); // синтаксис шаблонов
}
```

Если это будет написано в том же месте, то словим ошибку компиляции, если после определения `derived`, то проблем не будет.

Всего есть 4 разных `cast`:

- `static_cast` - то, что нам нужно в 99% случаев. В основном это те касты, которые адекватно прописаны в стандарте.

- `reinterpret_cast` - касты, которые зависят от реализации компилятором. Редко бывает полезен, стоит избегать. Например, может приводить указатели к числам.

- `const_cast` - тоже редко хотим использовать. Например:

	```c++
	int a;
	int const& b = a;
	int& c = const_cast<int&>(b); // "снимает const", редко нужно, например, если в библиотеке забыли пометить аргумент функции const, а хотим передать что-то константно
	```

- `dynamic_cast` - *не успели*
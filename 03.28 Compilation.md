# Процесс компиляции программ
![Compilation graph](./images/03.28_compilation_graph.png)

Классическая схема этапов компиляции. 
Есть [похожая статья на хабре](https://habr.com/ru/post/478124/).

**Preprocessing**
`g++ -E -P 1.cpp -o 1.i`

Выполняет директивы (`#define`, `#include` и другие).

`#include` - вставляет текст из указанного файла
`#define` - задает макрос

**Translation**
`g++ -S -masm=intel 1.i -o 1.s`

Трансляция кода в ассемблер.

**Assembling**
`g++ -C 1.s -o 1.o`

Транслирует ассемблерный код в машинный код.

`*.o` - объектный файл
**Linking**
`g++ 1.o -o program`

Связывает все объектные файлы и библиотеки в один исполняемый файл.
После этого этапа можно запускать `./program`.

`*.cpp` файлы так же называют единицами трансляции

Пример линкования файликов:

```c++
a.cpp:						b.cpp:
int main() {					#include<cstdio>
	f();						void f() {prinf("Hello world");}
}
```
Это не скомпилится, так как на этапе до линковки компилятор не знает о существовании `f()` где то вне a.cpp, поэтому ее надо объявить:

```c++
a.cpp:						b.cpp:
void f();						#include<cstdio>
int main() {					void f() {prinf("Hello world");}
	f();						
}
```
Для линковки вместе`g++ a.o b.o`

- Функцию нужно объявлять до её вызова.
- Если в обеих прогах есть main, то невозможно будет слинковать (какой main запускать?)
- Можно писать функцию на ассемблере и вызывать из `*.cpp` файла, потому что на этапе линковки нет разницы.
- В одной единице трансляции может быть только одно объявление, во всех единицах трансляции только одно определение.

### Некоторые ключевые слова
**`static`** - переменная или функция - "не предоставляется наружу", видна только в одной единице трансляции

**`extern int a`** - переменная где-то (объявление)

**`int a`** - определение переменной

**`extern "C" f`** - чтобы использовать сишное имя функции

**`inline`** - рекомендация компилятору заинлайнить функцию (подставить её тело). Начинаются проблемы, если определение функции в одном файле, а вызов в другом. Решается определением таких функций в header.
При этом возможно повторное определение функции, а линковщик оставит только одно, предполагая, что они все одинаковые.

### Headers
`2.h` - файлы не участвующие в компиляции, в них пишут объявления функций. Нельзя `#include .cpp`, а в `.h` нельзя определять функции.

Их идея - можно подключать в разные `.cpp` и не будет проблем с тем, что у функции несколько определений.

Структуры пишем в `.h`.

## Что происходит на preprocessing
```c++
x.h:
struct x {}; 
y.h:
#include "x.h"
z.h:
#include "x.h"

a.cpp:							
#include "y.h"		-->		struct x{};
#include "z.h"				struct x{}; //ошибка компиляции
```
Решение:
1. `#include "x.h"` не писать в хедерах, а только по необходимости в .cpp (не очень решение)
2. ```c++ 
	x.h:
	#ifndef X_H
	#define X_H		// - макрос
	struct x{};
	#endif
	```
	Это решение называется **include guard**
	Тогда при `#include x.h` будет проверка, заинклудили ли его уже и не будет проблем.
3. Директива  `#pragma once` - стандарт не поддерживает, но поддерживают, кажется, все компиляторы. Эффект как у **include guard**, но проще писать и нет проблемы с тем, что можем еще где-то сделать лишний `#define X_H`

Если меняется *header*, то необходимо перекомпилировать все файлы, которые подключают его (даже не непосредственно)
```c++
#define PI 3.14 
// препроцессор подставляет вместо PI 3.14
```
Макросы обычно пишут капсом

### Про структуры

Хотим две структуры в разных хедерах `a.h` и `b.h`. В структуре `a` указатель на структуру `b` и наоборот.  

```c++
main.cpp:
#include "a.h"
#include "b.h"
```

Если в `a.h` инклудится `b.h` и наоборот, то получим ошибку во время компиляции. Как фиксить? 

Если нам не требуется знать, что находится внутри структуры, можно использовать **forward declaration**. Например, `a.h` будет выглядеть так:

```c++
struct b;
struct a
{
	b* bb;
};
```

**Важно**: избегайте циклических инклудов, чаще всего это приводит к ошибкам.

Пока структуру не определили, структура - это **incomplete type**. Например, на момент объявление `struct b;` в коде выше, `b` - incomplete. 
Все, что можно с ними делать - это объявлять функции с их использованим и использовать указатель. 
Становится полным типом после определения.

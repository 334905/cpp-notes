## Кэш-память
Одинаково ли по времени будет работать следующий код?
```python
for i = 0..n:				for i=0..n:
	for j=0..n:				for j=0..n:
		a[i][j] = 0 				a[j][i] = 0
```
У этих двух кодов большая разница из-за процессорного кэша. Первый цикл обращается к памяти последовательно, а второй "скачет" по ней. Поэтому обращения к памяти первого цикла попадают в кэш, а второго - нет. С ростом **N** видна разница между уровнями кэша на графике времени обработки одного элемента:

*// TODO: вставить график*

Небольшие пики - скачки из-за попадания в разные кэш-линии (заметно на степенях двойки), сильное изменение времени работы происходит, когда данные перестают попадать в кэш какого-то уровня.

**Кэш** реализован через хэш-таблицы (дискретного размера), где ключ - адрес в памяти.
Линии кэша примерно по *64 байта* разделенные на группы (buckets), размеры которых называются ассоциативностью кэша.

Подробнее про кэш  можно прочитать в [конспектах по ЭВМ](https://github.com/DespairedController/computer-architecture/blob/master/1_4/1_4.pdf) 

**Prefetching** - если много кэш-промахов, запрашиваем заранее подгрузить в кэш. Это работает на уровне кэш-подсистемы (вроде).

*Пример*: хранение хэш-таблицы с открытой адресацией. Два варианта: 

*// TODO: Паша, вставь картинку со слайда*

- Если ожидаются частые попадания, то хранить полезнее данные рядом с ключом.

- Если ожидаются редкие попадания, то лучше хранить ключи и данные отдельно.

### TLB - translation lookaside buffer

Зачем нужен? Это кэш для ускорения трансляции виртуального адреса в физический. Так же, как и обычный, может быть нескольких уровней.

### Huge Pages

*Идея*: отображать страницу памяти в лежащую подряд физическую память. Тогда проще обходить каталог страниц. Например, если программе нужно прочитать 1 Мбайт непрерывных данных, которых нет в *TLB* кэше, то нужно сделать обращение к 256 страницам.

Но использовать тяжело, так как с ними тяжело делать *swap* (подкачка страниц). Например, в *Windows* требуются специальные права, чтобы выделять не-swappable память

**Swap** - хотим выделить памяти больше, чем у нас есть физической (оперативной). Особенно было актуально раньше, когда оперативной памяти было мало. Некоторые страницы из оперативной памяти записывались на диск и помечались недоступными, но при необходимости можно было вытеснить другую страницу и выгрузить нужную с диска.


## Конвейер (Pipelining)

Что мы делаем при условных переходах? Выполняем какую-то ветку и если угададли - ок, иначе отменим.
**Branch prediction** - прогнозирование, выполняем одну ветку if, если не угадали - откатываем
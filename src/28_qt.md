# Qt

- [Запись лекции №1](https://www.youtube.com/watch?v=91tudrUjP-4) 
- [Qt documentation](https://doc.qt.io/)
- [Запись лекции №2](https://www.youtube.com/watch?v=K79JvMSXNdM) 

Qt - C++ фреймворк для работы с графическим интерфейсом (в основном).

## Как устроены Qt-программы?

Так выглядит пустое окно:

```c++
int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    QMainWindow w;
    w.show();
    return a.exec();
}
```

- `QApplication` — глобальная инициализация/деинициализация, надо создать его тогда, когда хотите использовать QT и не использовать QT после его удаления.
- `QWinget` — любая хрень; любые кнопочки, например, наследуются от него.
- Функция `exec` внутри достаёт сообщения из очереди (в очередь кладутся ивенты типа кликов мыши, нажатий на клавиатуру и т.д.) и обрабатывает их. По умолчанию `exec` выходит, когда закрывается последнее окно, основное время программа проводит внутри этой функции.

Добавим кнопку:

```c++
int main(int argc, char *argv[]) {
    QApplication a(argc, argv);
    QMainWindow w;
    QPushButton* button = new QPushButton(&w);
    button->setText("hello world");
    w.show();
    return a.exec();
}
```

В Qt все элементы интерфейса называются виджетами ([Qt Widgets](https://doc.qt.io/qt-5/qtwidgets-index.html)). Помимо способа создавать их руками (как написано выше), виджеты можно создавать в редакторе (встроен в [Qt Creator](https://www.qt.io/product/development-tools)), который просто генерирует `.xml` файлы. Вместе с Qt поставляется UI-compiler, который транслирует эти `.xml` в плюсовый код.

## `QObject`.

Если посмотреть на иерархию Qt-шных объектов, то многие из них наследуются от `QObject`. Одна из вещей, которую он предоставляет — иерархия *parent-child*. У каждого объекта может быть какой-то родитель и несколько дочерних объектов. Когда удаляется ребёнок, то он отписывается от своего родителя, а родитель при удалении удаляет все свои дочерние объекты. Именно поэтому в примере выше есть `new`, но не нужен `delete`, так как за удаление `QPushButton button` ответственен его родитель — `QMainWindow w`.

Можно не использовать это и при создании объекта не указывать у него родителя. Кроме того, можно явно удалять объекты, у которых указан родитель. Это может быть удобно, если к долгоживущему объекту привязан короткоживущий, то без явного удаления он будет жить, пока жив родительский объект, что можно считать мемори-ликом.

Кроме функционала владения, `QObject` предоставляет сигналы и слоты 

```c++
namespace Ui {
    class MainWindow;
}
class MainWindow : public QMainWindow {
	Q_OBJECT
public:
    explicit MainWindow(QWidget* parent = nullptr) :
    	QMainWindow(parent),
    	ui(new Ui::MainWindow) {
            ui->setupUi(this);
            connect(ui->pushButton, &QPushButton::clicked, this, 	
                    &MainWindow::buttonClicked);
    }
    ~MainWindow() {
        delete ui;
    }
private slots:
    void buttonClicked() {
        ui->plainTextEdit->setPlainText("hello, world!");
    }
signals:
    void mysignal;
private:
    Ui::MainWindow* ui;
}
```

Можно заметить, что в Qt много своих макросов (`Q_OBJECT`, `slots`, `signals`). Некоторые из них, например, `slots` и `signals` раскрываются в ничего/`public:`. Помимо компилятора для XML в Qt есть Meta-Object Compiler, который генерит вместо этих макросов дополнительный код. Во многом, это всё пережиток прошлого, потому что Qt писалась ещё до появления шаблонов в языке, кроме того, MOC всё равно нужен для внутренностей Qt (reflection и др.), а сигналы в таком виде компилируются быстрее (по сравнению с известными попытками переписать это на современный C++). Кстати, в `QObject` встроенный механизм слотов разрывает `connection` между сигналом и слотом, если один из них умирает, поэтому не нужно делать вручную `disconnect`.

### Многопоточка.

У `QObject` есть ещё одно интересно свойство - они знают, какому потоку они принадлежат (`thread affinity`). Основная операция, которая от этого зависит — операция `connect`. У неё есть параметр `ConnectionType`, который по умолчанию `AutoConnection`. Но у неё могут быть и другие значения:

- AutoConnection — если объект живёт в потоке, который `emit`ит сигнал, используется `DirectConnection`, иначе `QueuedConnection`.
- `DirectConnection` — при `emit`е сигнала вызывает все слоты. Слот выполняется в потоке сигнала.
- `QueuedConnection` — вместо прямого вызова функции, в очередь сообщений потока, которому принадлежит объект, добавляется сообщение о том, что нужно вызвать слот (требуется, чтобы в том потоке крутился event loop).
- `BlockingQueuedConnection` — добавляет в очередь и ждёт, пока отработает.

## Пример: факторизация чисел

Дальше на лекции рассматривается [пример программы](https://github.com/sorokin/qfactor), которая считает факторизацию введённого в формочку числа. Лучше посмотреть [запись](https://youtu.be/91tudrUjP-4?t=2852), это небольшой пересказ происходящего:

### qfactor1

В `qfactor1` при вводе числа считается его факторизация в том же потоке. Факторизация тут является блокирующей операцией, поэтому UI фризится, пока она не досчитается, а все ивенты, происходящие в это время, просто кладутся в очередь.

### qfactor2

В `qfactor2` попробовали это пофиксить, сделав отдельный поток (в данном случае это `QThread`, который позволяет создать поток и крутить в нём *event (message) loop*), запрос на факторизацию и результат передаются с помощью сигналов. 
Стоит обратить внимание на `worker_obj.moveToThread(&worker_thread)` - это привязывает объект к другому потоку, что сказывается на работе коннекта. Теперь UI перестал фризить, но есть другая проблема - если какое-то число уже начало считаться, то следующие введённые не будут считаться, пока не досчитаются предыдущие. Хоть и UI перестаёт зависать, лучше от этого не стало - особенно это проявляется в том, что при закрытии UI, рабочий поток продолжает считать факторизации. Вывод: нужно как-то отменять вычисления.
Ещё стоит обратить внимание, что невалидные запросы в коде тоже добавляются в очередь. Можно было бы сразу на них выводить ошибку и делать `return`, но тогда может произойти следующее: в очередь добавилось большое число, пока оно считалось, ввели неверный запрос и получили ошибку в выводе, а затем только пришёл и вывелся ответ на большое число.

### qfactor3

В `qfactor3` применяется следующая идея: сделали класс `factoring_worker`, который внутри себя хранит поток, конструктор его запускает, деструктор отменяет. У него есть функции `set_input` и `get_output` (по названиям понятно, что они делают). Понятно, что `get_output` можно вызывать, только когда результат готов, для этого делаем сигнал `output_changed`, который сообщает о готовности результата. Можно заметить ещё следующую оптимизацию: в каждый момент в очереди событий для UI хранится не более одного аутпута (для этого используется булевый флаг `notify_output_changed`), благодаря этому очередь событий UI-потока не забивается уведомлениями о результате, что могло бы приводить к фризам.

### qfactor4

Наконец, в `qfactor4` применяется следующая идея. В качестве примера можно посмотреть на такую программу:

```c++
void MainWindow::buttonClicked() {
    QString filename = QFileDialog::getOpenFileName(this, tr("Open File"));
    if (!filename.isEmpty()) {
        QMessageBox::information(this, "Demo file", "File Selected");
    } else {
        QMessageBox::warning(this, "Demo file" "No file selected")
    }
}
```

Функция `getOpenFileName` крутит свой встроенный event (message) loop, открывая диалог выбора файла (он называется модальным), до закрытия которого не происходит выхода из функции.

Теперь, зная такуя идею, попробуем усовершенствовать программу с факторизацией чисел - проблема в `qfactor1` была именно в том, что не прокручивался event loop. В Qt есть функция, которая называется `processEvents`, она пампит event loop и передаёт обработчику сообщения, если они там есть. Можно воткнуть её во все циклы в `qfactor1` и тогда UI перестанется фризить, но вылезет следующий баг: какие-то ответы могут начать заменяться более старыми (понятно, почему - внутри факторизации числа `x` вызовется факторизация числа `y`, введённого позже, выведется ответ на неё, а потом перезапишется ответом на `x`) - напоминает проблему *reentrancy*. Можно пофиксить это, делая проверку после `processEvents` и отменять текущую факторизацию, если пришёл какой-то ивент на новые входные данные.

Итог: часто используется способ, как в `qfactor3`, потому что код как в `qfactor4` может показаться непривычным и раздутым, хотя в некоторых случаях он несложный и успешно подходит (например, в этом примере с факторизацией).

## Рисование в окне на Qt (для ДЗ).

Если мы хотим нарисовать в окне множество Мандельброта, то мы пока не знаем, что делать. А делать вот что: надо переопределить **paint event**. Paint event — это то, что вызывается, когда содержимое окна надо перерисовать. То есть когда вы изменили его размер, например.

```c++
void main_window::paintEvent(QPaintEvent* event) {
    QPainter p(this);
    p.drawLine(QLine(50, 50, 100, 100));
}
```

Конкретно нам надо рисовать попиксельно. Делается это так:

```c++
void main_window::paintEvent(QPaintEvent* event) {
    QPainter p(this);
    QImage img(width(), height(), QImage::Format_RGB888);
    for (int y = 0; y < img.height; y++)
        for (int x = 0; x < img.width; x++)
            img.bits[...] = ...;
    p.drawImage(0, 0, img);
}
```

`bits` — массив битов, в котором ещё и дырки между строками могут быть. Размер строки целиком — `img.bytesPerLine()`. То есть заполнение выглядит примерно так:

```c++
void fill(QImage& img) {
    uchar* image_start = img.bits();
    for (int y = 0; y < img.height; y++) {
        uchar* p = image_start + y * img.bitsPerLine();
        for (int x = 0; x < img.width; x++) {
            *p++ = red_component;
            *p++ = green_component;
            *p++ = blue_component;
        }
    }
}
```

Очевидно, если честно рисовать Мандельброта, нам никакого времени не хватит. Поэтому имеет смысл сначала рисовать его очень пиксельно, а потом уточнять.

Ещё нам понадобится `wheelEvent`, `mousePressEvent`, `mouseMoveEvent` и `mouseReleaseEvent`, чтобы реализовать перетаскивание и масштабирование, а также `resizeEvent`, чтобы масштабирование работало.

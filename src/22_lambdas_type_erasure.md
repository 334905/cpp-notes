# Анонимные функции, type erasure, std::function

- [Статья про девиртуализацию](http://hubicka.blogspot.com/2014/01/devirtualization-in-c-part-1.html)
- [Запись лекции №1](https://www.youtube.com/watch?v=ItNnt_7D5w0)
- [Запись лекции №2](https://www.youtube.com/watch?v=bTVLDJjEMlU)
- [Запись лекции №3](https://www.youtube.com/watch?v=4yLK5vv_-Jc)
- [Код std::function](https://github.com/sorokin/function)
-  [Презентация про type erasure](https://files.meetup.com/1455470/Type%20Erasure.pdf)

---

## Статический и динамический полиморфизм.

Давайте напишем сортировку и передадим в неё в качестве компаратора одну из двух следующих сущностей:

```c++
bool int_less(int a, int b) {
    return a < b;
}

template <typename T>
struct less {
    bool operator()(T const& a, T const& b) const {
        return a < b;
    }
};

int foo(std::vector<int>& v) {
    std::sort(v.begin(), v.end(), less<int>());
    std::sort(v.begin(), v.end(), &int_less);
}
```

Вопрос: какой вариант будет быстрее?

Оказывается, что первый вариант работает процентов на 30 быстрее (это для случайных массивов), а в случае изначально отсортированного массива (когда большую часть времени занимает именно что вызов сравнения, а не какие-то дейтсвия сортировки), то вообще более чем вдвое быстрее. Почему?

Это происходит за счёт того, что когда в `sort` передаётся объект, на этапе компиляции известно тело функции, которая будет вызываться, и его можно за'inline'ить. Когда передаётся указатель на функцию, компилятору не известно, куда он ссылается, поэтому ничего не остаётся, кроме как сделать безусловный переход на по указателю на функции. Кстати, дело тут не только в inlining'е, но ещё и в том, что когда компилятор знает всё про функцию, он может видеть, что она не пишет ничего в память, а значит после её вызова можно ничего не перечитывать.

Знатоки парадигм программирования скажут, что тут у нас концептуально два вида полиморфизма: когда мы на этапе компиляции знаем, что делать, — статический, иначе — динамический.

|Преимущества статического полиморфизма.|Недостатки статического полиморфизма.|
|-|-|
|Возможность оптимизации на этапе компиляции.|Возможность получить большое количество копий одинаковых сущностей.|
||Невозможность выбирать сущность на этапе исполнения.|

Понятно, что у компиляторов есть способ бороться с недостатками динамического полиморфизма.
- Например, GCC под [LTO](./13_tools.md#lto) может анализировать, какие аргументы приходят к Вам в сортировку, и если они всегда одни и те же, то inline'ить. При этом с `-O3` может произойти так, что даже если передавать указатели на разные функции, время работы будет одинаковым.
- Также GCC под `-O3` может совершить трюк, который называется `-fipa-cp-clone`. Если GCC видит, что для какого-то конкретного параметра, который вы передаёте, функция хорошо оптимизируется, то он создаёт копию этой функции, куда передаётся именно он. Почему эти оптимизации не включены по умолчанию? Из-за них может ухудшаться производительность. Например, эта оптимизация может создать много копий функции, что заметно увеличит размер бинарного файла, а больше бинарник — меньше свободного места в кэше.\
Оптимизация, которая заменяет вызов функции по указателю (или виртуальной функции) на вызов самой функции, называется [*девиртуализацией*](http://hubicka.blogspot.com/2014/01/devirtualization-in-c-part-1.html).
- Помимо этого, девиртуализация может быть "спекулятивной" (в GCC она называется `-fdevirtualize-speculatively`), эта оптимизация генерирует примерно такой код:

```c++
bool int_less(int a, int b) {
    return a < b;
}

void sort(int* a, bool(*comp)(int, int)) {
    // ...
    if (comp == &int_less) {
        int_less(a[4], a[5]);
    } else {
        comp(a[4], a[5]);
    }
}
```

Такая оптимизация может быть выгодной, если `if` находится в цикле и его условие не меняется, тогда ветвление можно вынести из цикла, и будет всё хорошо.

Такая оптимизация даёт выигрыш, если использовать её с [*profile-guided optimization*](./13_tools.md#pgo) — техникой оптимизации, которая заключается в запуске программы на каких-то репрезентативных данных с попутным сбором статистики, исходя из которой можно будет оптимизировать программу (после её перекомпиляции). Например, если чаще всего компаратор — это `int_less`, то применение спекулятивной девиртуализации (как в коде выше) будет выгодно и, скорее всего, применится.

## Анонимные функции (a.k.a. лямбда-функции).

До C++11 при необходимости отсортировать контейнер по кастомному компаратору, нужно было писать структуру с оператором `()` или функцию. Это неудобно, да и раскидано определение компаратора от использования далеко. Поэтому начиная с C++11, это можно делать следующим образом:

```c++
int main() {
    std::vector<int> v;
    std::sort(v.begin(), v.end(), [](int a, int b) -> bool {
        return a % 10 < b % 10;
    });
}
```

На самом деле, это генерит почти такой же код, как определение структуры и передача её инстанса по значению. Компилятор генерит [локальный класс](https://en.cppreference.com/w/cpp/language/class#Local_classes) с `operator()`. При этом в лямбде можно не указывать тип возвращаемого значения, тогда он выводится из типов возвращаемых значений (как в случае с `auto`).

### Синтаксис.

Что написано в круглых и фигурных скобках, понятно, аргументы и тело соответственно, а зачем нужны квадратные? Давайте представим, что мы хотим хотим сравнивать не по модулю 10, а по модулю `mod`. Можно было бы так и написать:

```c++
struct mod_comparer {
    mod_comparer(int mod) : mod(mod) {}
    
    bool operator()(int a, int b) const {
        return a % mod < b % mod;
    }
private:
    int mod;
}

void foo(int mod) {
    std::vector<int> v;
    std::sort(v.begin(), v.end(), mod_comparer(mod));
}
```

То же самое можно написать и с лямбда-функцией:

```c++
void foo(int mod) {
    std::vector<int> v;
    std::sort(v.begin(), v.end(), [mod](int a, int b) {
        return a % mod < b % mod;
    });
}
```

Захват в примере выше происходит по значению, но можно захватывать и по ссылке: для этого надо написать `[&mod]`. Кроме того, можно захватить весь контекст: `[&]` — по ссылке, `[=]` — по значению. И ещё можно захватить почти всё по значению, а некоторые переменные по ссылке (`[=, &n]`) или наоборот.

```c++
int main() {
    int x, y, z;
    [x, &y, z](){}; // y - по ссылке, остальные по значению
    [=](){}; // всё по значению
    [=, &y](){}; // всё по значению, y - по ссылке
    [&](){}; // всё по ссылке
    [&, x](){}; // всё по ссылке, x - по значению
}
```

На самом деле в примере `[&](){}` выше не захватится ничего, потому что на самом деле `[&]` и `[=]` захватывают не всё, а только то, что в лямбде используется.

Вопрос на 3'000'000 рублей: можно захватить глобальную переменную? Нет, нельзя, к ней и так обратиться можно, зачем её захватывать.

А теперь на 5'000'000 рублей: поля класса можно? Нет, тоже нельзя, **можно захватывать только локальные переменные и параметры функции**. Поэтому если вы хотите поля, захватите `this`. Если в теле лямбды, которая объявлена внутри класса, используется `this`, то это `this`, который соответствует структуре, а не внутреннему представлению лямбды. Это происходит из-за того, что все имена резолвятся в коде ещё до создания структуры. 

Раз уж `this` — это указатель, объект вам не скопируют, а если вы хотите, чтобы скопировали, пишите `[*this]`. Важно знать, что `[=]` захватывает `[this]`, а не `[*this]`. Поэтому, по причине асимметрии, это на данный момент deprecated, и лучше Вам явно писать `[=, this]` или `[=, *this]`.

В общем случае, синтаксис лямбды выглядит одним из 4 способов (тут указано для C++23, для прошлых версий смотри ):

```c++
// Полная форма.
[captures] (params) specifiers exception-specification attrs -> return-type requires { body }

// Форма без аргументов.
[captures] specifiers exception-specification attrs -> return-type { body }

// Полная шаблонная форма.
[captures] <tparams> requires (params) specifiers exception-specification attrs -> return-type requires { body }

// Шаблонная Форма без аргументов.
[captures] <tparams> requires specifiers exception-specification attrs -> return-type { body }
```

- *captures* — список захвата, о котором рассказано выше. 

  Кроме упомянутых возможностей захвата, в C++14 появилась возможность захватывать новую переменную с заданным значением (`[x = 2 + 3]` или move-only типы `[x = std::move(x)]`), а так же захватывать ссылки по новому имени (`[&x = a]`), где `a` может быть любой ссылкой, например, элементом массива. В частности, это позволяет захватывать объекты по константной ссылке `&cr = std::as_const(x)`.

  По умолчанию переменные, захваченные по значению, нельзя изменять в теле лямбды (см. *specifiers*).

- *tparams* — что может быть лучше, чем шаблонная лямбда. Шаблон применяется к оператору `()`, а не к классу.

- *requires* — [понятно, кто такой](./28_concepts.md). Можно не указывать.

- *params* — список параметров, при этом параметры по умолчанию появились только в C++14

- *specifiers* — спецификаторы. Например, `mutable` позволяет изменять переменные, захваченные по значению, и вызывать у них не-const методы. При этом значение переменной снаружи не изменится, так как при захвате по значению они копируются. Также можно указать `constexpr`, `consteval` и `static`. Последний делает `operator()` статическим методом класса.

- *exception-specification* — спецификаторы `throw` или `noexcept` (как у обычных функций). Можно опустить.

- *return-type* — тип возвращаемого значения. Можно опустить, тогда он будет выведен таким же образом, как и для функции с возвращаемым типом `auto` (со всеми вытекающими отсюда правилами и ограничениями, см. [конспект по этой теме](./21_decltype_auto_nullptr.md#auto)).

Смотреть на то, во что разворачиваются лямбды, можно на [C++ insights](https://cppinsights.io/).

Кстати, о шаблонах внутри лямбд. Cинтаксис вида

```c++
[]<typename T>(T const& a, T const& b){ /* ... */ }
```

Появился в C++20. Но лямбды могли быть шаблонными ещё в C++17:

```c++
[](auto a, auto b){ /* ... */ }
```

Тут всё просто — каждое `auto` в аргументах — независимый шаблонный type-параметр. Кстати, начиная с C++20 тот же синтаксис перенести и на обычные функции:

```c++
void foo(auto x) {
    // ...
}

int main() {
    foo<int>(23);
}
```

### Свойства лямбд.

Так как лямбды — это некоторые классы (типы), то имеет смысл рассуждать про свойства этих классов.

- Есть `operator()`.
- Есть конструктор копирования и перемещения.
- Нет присваивания (никакого из двух).
- До C++20 запрещён дефолтный конструктор, в C++20 разрешён, если лямбда ничего не захватывает.
- Незахватывающие лямбды имеют оператор конверсии в указатель на функцию:

    ```c++
    int main {
        auto b = [](int x) -> bool {
            // ...
        };
        bool (*a)(int);
        a = b;
    }
    ```

    Шаблонные лямбды тоже можно присваивать в указатели на функции по тем же правилам, что и обычные шаблонные функции.

    ```c++
    void (*p)(int) = []<typename T>(T x) { /* ... */ }; // выведено T = int.
    ```

- При копировании лямбды, копируются все захваченные по значению переменные, а захват по ссылке не продлевает время жизни объектов. Такой код не работает:

    ```c++
    auto foo() {
        std::vector<int> v;
        return [&v] {
            // ...
        };
    } // v уничтожится при выходе из функции, обращение внутри лямбды - UB
    ```
  

- *Мем:* в C++ есть оператор `+` (унарный), который для чисел и указателей не меняет их. Но если применить его к лямбде, то она сконвертится в указатель на функцию, и он применится к ней.

## Type erasure. `std::function`

В некоторых случаях может захотеться сохранить в переменную лямбду, в зависимости от условия.

```c++
void (bool flag) {
    ??? func;
    if (flag) {
        func = [](){};
    } else {
        func = [](){};
    }
}
```

Так как `func` присваиваются объекты разных типов, в зависимости от `flag`, то не понятно, каким типом должен быть`func`.

Для такого в стандартной библиотеке есть `std::function`. Единственное ограничение - ему нужна сигнатура функции.

```c++
void (bool flag) {
    std::function<void (int, int)> func;
    if (flag) {
        func = [](int a, int b){};
    } else {
        func = [](int a, int b){};
    }
}
```

`std::function` может оборачивать любой функциональный объект, который можно копировать и вызывать, используя [`INVOKE<R>`](https://en.cppreference.com/w/cpp/named_req/Callable). Это может быть не только лямбда, но и честно созданная структура, указатель на функцию или даже указатель на метод или поле. Да, указатель на поле тоже считается функциональным объектом.

Чтобы понять, как эта чёрная магия работает, сначала разберёмся, что такое `void (int, int)` в параметре шаблона. А это тип-функция. Как указатель на функцию, только без указателя.  И дальше понятно, как это в шаблон засунуть:

```c++
template <class T>
struct function;

template <class R, class... Args>
struct function<R (Args...) {
    /* ... */
};
```

Теперь ближе к делу. Как это реализовать?

### Type erasure.

Что `std::function` должен уметь? Создаваться от любого функционального объекта и вызываться. Как создаваться, примерно ясно, шаблонный конструктор, но вот что мы будет сохранять?

Можно было бы делать в хипе копию объекта, от которого создаётся `function` и сохранять на неё указатель. Но тогда не понятно, как его удалять, так как нужно скастить обратно к типу, который пришёл. Чтобы удалять, нужно знать, какой деструктор вызывать, поэтому можно сохранить функцию, которая  будет удалять объект. Аналогично придётся сделать для того, чтобы вызывать объект.

Пример для двух аргументов и без возвращаемого значения:

```c++
template <typename F>
void delete_func(void* obj) {
    delete static_cast<F*>(obj);
}

template <typename F>
void invoke_func(void* obj, int a, int b) {
    return static_cast<F*>(obj)(a, b);
}

struct function {
    typedef void (*deleter_t)(void*);
    typedef void (*invoker_t)(void*, int, int);
    
    function(); 
    template <typename F>
    function (F f) 
        : obj(new F(f)),
    	  deleter(delete_func<F>),
    	  invoker(invoke_func<F>)
	{}
    
    void operator()(int a, int b) {
        return invoker(obj a, b);
    }
    
    ~function() {
        deleter(obj);
    }
  private:
    void* obj;
    deleter_t deleter;
    invoker_t invoker;
}
```

Ну а дальше понятно, что делать. Написать ещё два указателя на функции под копирование и перемещение и заменить конкретные аргументы на шаблонные. Общий случай можно почитать [тут](https://github.com/sorokin/function).

## Вспомогательные функции.

### `std::mem_fn`.

Указатель на метод нельзя вызывать просто через круглые скобки, так как его нужно вызывать на определённом объекте.

```c++
struct mytype {
    void myfunc(int a);
}

void foo() {
    void (mytype::* f)(int) = &mytype::myfunc;
    mytype t;
    mytype* p;

    (t.*f)(42);
    (p->*f)(42);
    std::invoke(f, t);
}
```

В C++11 появилась вспомогательная функция `std::mem_fn`, превращающая указатель на функцию в объект, у которого есть `()`. Причём этот `operator()` можно вызывать и от указателя и от ссылки на тип:

```c++
void foo() {
    void (mytype::* f)(int) = &mytype::myfunc;
    mytype t;
    mytype* p;

    auto g = std::mem_fn(f);
    g(t, 42);
    g(p, 42);
}
```

### `std::bind`.

`std::bind` позволяет "запомнить" аргументы для функции и частично реализован примерно так:

```c++
template <typename F, typename... Args>
auto bind(F f, Args... args) {
    return [f, args...]() {
        return f(args...);
    }
}
```

На самом деле, там [немного сложнее](https://en.cppreference.com/w/cpp/utility/functional/bind): можно закреплять конкретные аргументы, а остальные принимать при вызове при помощи `std::placeholders`.

## Рекурсивный вызов лямбд.

`std::function` позволяет решить проблему рекурсивного вызова лямбд.

Лямбда-функции можно вызывать рекурсивно, но следующий код не скомпилируется:

```c++
int main() {
    auto fib = [&fib] (int n) {
        return (n <= 1) ? 1 : fib(n - 1) + fib(n - 2);
    };
    std::cout << fib(4) << std::endl;
}
```

Это происходит из-за того, что тип переменной `fib` ещё не выведен в момент её использования, а указать его явно мы не может. Это решается несколькими способами: можно передавать лямбде её же как параметр, а можно сохранить её в `std::function`:

```c++
int main() {
    std::function<int (int)> fib = [&fib](int n) {
        return (n <= 1) ? 1 : fib(n - 1) + fib(n - 2);
    };
    std::cout << fib(4) << std::endl;
}
```

Казалось бы, в этом месте мы захватываем ссылку на ещё несконструированный объект, но так делать можно. Идейно это работает так же, как передача в конструктор объекта ссылку на него самого же:

```c++
struct mytype {
    mytype(mytype&) {}
};

int main() {
    mytype a = a; // OK
}
```

Поэтому `fib` можно безопасно захватывать по ссылке, но нельзя по значению, так как в момент захвата переменной `fib` ещё не присвоено значение.

## `std::any`.

Продолжая тему *type erasure* — в стандартной библиотеке есть тип `std::any`, который может хранить внутри себя объект любого типа.

```c++
int main() {
    std::any a = 42;
    int v = any_cast<int&>(a);
    
    a = std::string("hello");
    std::string s = any_cast<std::string&>(a);
    
    a = mytype();
}
```

При `any_cast` к неправильному типу, получим исключение `bad_any_cast`.

### Реализация `std::any`.

`std::any` можно реализовать аналогично реализации `std::function`, которая приведена выше. Но можно реализовать проще через динамический полиморфизм: 

```c++
struct any {
    struct base_concept {
        virtual ~base_concept() {}
        
        virtual base_concept* clone() = 0;
    };
    
    template <typename T>
    struct model : base_concept {
        model(T value)
            : value(std::move(value)) {}
        model<T>* clone() override {
            return new model<T>(value);
        }
        T value;
    }
    
    template <typename T>
    any(T val) 
    	: obj(new model<T>(val)) {}
    
    any(any const& other) 
        : obj(other.obj ? other.obj->clone : nullptr) {}
	~any() {
        delete obj;
    }
  private:
    base_concept* obj;
    
    template <typename T>
    friend T* any_cast(any* a);
};
template <typename T>
T* any_cast(any* a) {
	if (a) {
		// if (model<T>* m = dynamic_cast<model<T>*>(a->obj)) {
        if (typeid(*a->obj) == typeid(any::model<T>)) {
			return &static_cast<any::model<T>*>(a->obj)->value;
		} else {
            throw std::bad_any_cast;
        }
	}
	return nullptr;
} 
```

Собственно, `std::function` тоже можно реализовывать через динамический полиморфизм, но это лишняя индирекция.

Базовый класс принято называть `concept`, но это стало ключевым словом в C++20, поэтому назовём его `base_concept`, а производный от него принято называть `model`. 

*Note:* как можно заметить, у функции `clone()` в derived-классе возвращаемый тип не совпадает с тем, который указан в базовом. Так можно делать, если в базовом классе функция возвращает указатель или ссылку на базовый класс, то в производном можно возвращать указатель или ссылку на него же.

Иногда может возникнуть желание, чтобы комплировалось c `-fnortti` (например, чтобы избежать оверхеда на виртуальные таблицы). Можно попытаться сделать так:

```c++
template <typename T>
void noop() {}

struct any {
    struct base_concept {
        // ...
        typedef void (*func_t)();
    	virtual func_t get_tag() = 0;
    }
    template <typename T>
    struct model : base_concept {
        // ...
        func_t get_tag() override {
            return &noop<T>;
        }
    }
    // ...
}
template <typename T>
T* any_cast(any* a) {
	if (a) {
        if (a->obj->get_tag() == &noop<T>) {
			return &static_cast<any::model<T>*>(a->obj)->value;
		} else {
            throw std::bad_any_cast;
        }
	}
	return nullptr;
} 
```

Заводим функцию `noop<T>`, которая для каждого типа `T` в одном экземпляре, так как то, как работает линковщик, гарантирует нам это. 

Можно вместо функции, использовать глобальную шаблонную переменную:

```c++
template <typename T>
char tag;
```

## `any_iterator`.

Часто возникает вопрос, почему у итераторов нет общего базового класса. Обычный ответ на этот вопрос заключается в том, что для итераторов недостаточно интерфейса виртуальных функций (например, для операторов сравнения).

Обычно с итераторами работают по значению, а если бы мы хотели использовать базовый класс, то пришлось бы работать с ними через указатели, что добавляет уровень индирекшна и снижает эффективность.

Тем не менее, бывают случаи, когда эффективность не важна, но нужна полиморфность итераторов. Такая концепция называется [*any_iterator*](http://thbecker.net/free_software_utilities/type_erasure_for_cpp_iterators/any_iterator.html). В стандартной библиотеке его ~~пока ещё~~ нет, но есть в [boost](https://www.boost.org/doc/libs/1_59_0/boost/range/detail/any_iterator.hpp) что-то похожее для ranges.

```c++
int main() {
    std::vector<int> v;
    std::list<int> l;
    int* p;
    any_bidirectional_iterator<int> i = v.begin();
    ++i;
    i = l.begin();
    *i;
    i = p;
}
```

## Глобально про type erasure.

В общем случае такой приём (как в function и any) называется *type erasure*. Иногда это очень похоже на таблицу виртуальных функций, только написанную руками, но у него есть несколько преимуществ:

- Это эффективная модель, когда не нужен полиморфизм.
- Хорошо работает с [value-семантикой](https://isocpp.org/wiki/faq/value-vs-ref-semantics) (перемещения, копирования) — тип ведёт себя так, как будто это обычное значение.
- Можно использовать полиморфно классы, у которых нет общего базового, но общий интерфейс.

Пример третьего пункта: у классов `std::fstream` и `std::stringstream` общий интерфейс, который был продуман заранее. Но это может быть не очевидно на этапе дизайна, поэтому это вполне могли бы быть два разных класса. Тогда, если бы возникло желание использовать их в одном месте, можно было бы прибегнуть к type erasure.

Если вы хотите что-то почитать про него, то [первое](https://files.meetup.com/1455470/Type%20Erasure.pdf) и [второе](https://github.com/boostcon/2010_presentations/blob/master/thu/type_erasure_pattern_boostcon.pdf).

## Type alias.

Иногда возникает желание сделать шаблонный `typedef`. Так как `typedef` пришёл из C, шаблонов у неё не было, поэтому ближайшее, что можно было получить - это сделать шаблонную структуру с `typedef` внутри неё (например, `type_traits ` реализованы таким образом). Поэтому в C++11 появились *type alias* со следующим синтаксисом:

```c++
template <typename Ret>
typedef Ret (*func_t)(); // так нельзя

template <typename Ret>
using func_t = Ret (*)(); // а так можно
```


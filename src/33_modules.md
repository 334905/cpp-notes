# Модули
- [Запись лекции (с 46 минуты)](https://youtu.be/5zszqIm4Cyk)

## Мотивация

Мы помним, что при работе с заголовочными файлами надо соблюдать осторожность.

Например, нам очень надо предотвращение повторного включения. Или ещё мы не можем писать определение функции в заголовочном файле (или можем, но помечая её как `inline`, со всеми вытекающими последствиями). И на крупных проектах текст заголовочного файла проходится в каждом cpp-файле, и какое-то время компиляции отжирает на это. Если у нас *n* cpp-файлов и *m* заголовочных, то в худшем случае у нас время компиляции равно *O(nm)*. Каждая новая версия стандартной библиотеки
увеличивает размер заголовочных файлов STL, а значит увеличивает время компиляции.

Отсутствие такой проблемы — не единственный бонус модулей. Написав какой-то код в заголовочных файлах очень легко получить нарушение ODR:

```c++
// header.h
#pragma once
#include <cassert>
#include <cstdint>

inline int32_t isqrt(int32_t arg) {
    assert(arg >= 0);
    // ...
}
```

Уже даже тут можно получить нарушение ODR, если мы скомпилируем несколько файлов отдельно, и в одном включим `assert`'ы, а в другом — нет. Тут нарушение ODR, конечно, относительно безобидное, но UB есть UB.\
Понятно, что *g++ -flto -Wodr* может нам это найти, но знаете ли, LTO не всегда применимо. А ещё можно получить значительно более жёсткое нарушение ODR, если мы не у себя `assert` будем включать-выключать, а если у нас аналогичная ситуация будет с дебажными версиями контейнеров STL.

Да и вообще: препроцессор — зло.

А ещё подумайте, насколько удобно жить, когда определение и объявление постоянно разделены. Да, иногда это полезно, но всегда ли?..

Ещё в заголовках нельзя писать `using`-директиву (иначе она повлияет на всё, что написано во всех файлах, которые данный заголовок подключают).

Ещё когда у нас есть шаблон, который мы хотим сделать от конкретных параметрах всегда одинаково, нам может захотеться в заголовочном файле подавить инстанцирование, а в cpp-файле явно проинстанцировать. Оно вам надо так заморачиваться?

## Простейший пример.

```c++
// test.ixx
export module test;

export int sum(int a, int b) {
    return a + b;
}

// main.cpp
#include <iostream>
import test;

int main() {
std::cout << sum(2, 3) << std::endl;
}
```

В целом понятно: пишем `export` в модулях, и хорошо. Но давайте обсудим некоторые детали.

Названия модулей могут содержать в себе точки. Эти точки не несут никакого смысла для компилятора, просто являются частью имени.

## Visible vs reachable.

```c++
// test.ixx
export module test;

export struct pair {
int x;
int y;
};

export pair make_pair(int a, int b) {
    return { a, b };
}
```

Тут всё понятно, у нас есть `pair`, и хорошо. Но вот вопрос: а что если у нас не будет экспортироваться `pair`? Ошибка компиляции? Ну, могло бы быть и так, но заметьте вот какой пример: у нас есть `std::bind`. Он возвращает неизвестно какой функциональный объект. И вы не хотите давать пользователю самому создавать объекты такого типа, он вам просто не нужен. И тут вы вынуждены прятать его в пространство имён `__detail` или называть как-нибудь типа `_Binder`.\
И вообще у нас нередко бывает ситуация, когда мы не можем обратиться к классу по имени: у нас есть лямбды, у нас есть локальные классы, объект которого мы можем вернуть из функции. Бывают, короче, ситуации такие.

Поэтому вы вполне можете не экспортировать структуру `pair`, а экспортировать только `make_pair`.\
Надо понимать, что все свойства имени известны. Просто вы не можете по имени на него сослаться.

Научно это называется **visible** и **reachable**. Visible — когда вы можете сослаться по имени. Reachable — когда вы можете сделать какой-то `decltype` или ещё чего, чтобы добраться до типа.

## Поддержка модулей.

Заявляется, что модули полностью поддерживаются в MSVC и частично поддерживаются в GCC и clang. В GCC работают какие-то простые примеры, а комплексные примеры не работают и весь трекер у них завален примерами, которые не работают. В clang'е ещё более интересная ситуация: там были модули ещё до C++20 (потомум что у них один фронтенд для C, C++, Objective-C, CUDA и ещё куча всего) и ещё из Objective-C модули были. Когда появился C++20, стало надо доделать ещё много всего (так как они в C++20 там отличаются от Objective-C), но что конкретно там происходит, не расскажем.

## Как работают модули.

Дальше будет обсуждение внутренностей работы модулей, но терминология будет из MSVC. Так, например, *.obj*-файлы — это то, что мы знали как *.o* (объектные файлы).

У нас были мир с заголовками, а сейчас мир с модулями.\
Что происходит при компиляции модуля? А вот помимо объектного файла создают IFC-файл, в котором хранится публичный интерфейс модуля. И компиляторы умеют из этих файлов тянуть информацию об объявлениях (соответственно, тянут они только те объявления, что нужны).

То есть модуль — это обычный cpp-файл, который просто создаёт не только объктник, а ещё и информацию о публичном интерфейсе. При этом у нас ещё и `inlin`'инг бывает: компилятор может позволить себе в IFC-файл записать само тело функции, чтобы `inlin`'ить.

Вопрос: правда ли, что модули всегда дают нам более быструю компиляцию, чем заголовки? А вот не факт. В старом мире файлы можно было бы компилировать параллельно. А тут у нас могут быть зависимости, так что такой прикол не работает. Может ли это привести к тому, что программа в заголовками будет компилироваться быстрее? Да, может. Представим себе функцию с очень простым интерфейсом и длинным телом. Тогда с заголовками у нас заголовок содержал бы только объявление, и мы бы параллельно компилировали бы два больших файла. А в случае с модулями параллельность умирает.

Что с этим делать? Ну, во-первых, есть вероятность, что ничего: просто с развитием компиляторов, всё хорошо будет. Правда, тут нужно исправить системы сборки, чтобы они могли в разные времена выдавать IFC и OBJ. Но вообще, если вам очень важна параллельность компиляции, есть...

## Разделение модулей на куски.

Для каждого модуля надо написать «главный файл» — **primary module interface unit**. Там надо объявить, что модуль будет экспортировать. А дальше можно написать **implementation unit**'ы.

```c++
// test.ixx
export module test; // Обозначает primary module interface unit.

export int sum(int a, int b);

// test_implementation.ixx
module test;
int sum(int a, int b) {
    return a + b;
}
```

Что ещё нужно бывает нужно иногда — экспортировать структуру как incomplete-тип:

```c++
// test.ixx
export module test;

export struct foo;

// test_impl.ixx
struct foo {
    // implementation.
};
```

### `export import`.

Ещё про разделение модулей на куски: если мы хотим и публичный интерфейс разделить на куски, что делать? А вот смотрите как можно. Представьте, что в модуле `inner` у нас есть кусок модуля. Тогда мы можем написать такое:

```c++
// test.ixx
export module test;

export import inner; // добавить в публичный интерфейс всё, что есть в публичном интерфейсе inneexport int sum(int, int);
```

Но вообще так не надо, потому что если у вас была функция в модуле `test`, а вы перенести её в `inner`,
то у вас сломается ABI-совместимость, потому что декорированное имя этой функции изменится, а значит человек, вызывавший вашу функцию из ассемблера, увидит смену её названия.

Поэтому есть другой механизм:..

### Partition'ы.

```c++
export module test:part1;
```

Подобная штука позволяет вам распилить модуль на несколько кусков и импортировать в одном модуле partition'ы:

```c++
export modute test;
export import :part1;
```

При этом если у нас есть **implementation partition** (он пишется без export перед module), его нельзя пере-`export`'ировать, а если есть **interface partition** (который с **export module**), то его именно что необходимо пере-`export`'ировать.

## Приватный фрагмент модуля.

Помните экспортирование incomplete-типа из модуля? Мы для этого создавали два файла, и в одном писали `export struct foo;` в одном файле, а `struct foo { /* ... */ };` в другом.\
Но можно и не так: можно написать `module :private;`, и всё до конца файла не будет экспортироваться совсем никак. Соответственно, вам поможет что-то такое:

```c++
export struct foo;
module :private;
struct foo {
    // implementation.
};
```

## Transition. Global module fragment и import header unit.

Прекрасные модули будущего — это, конечно, хорошо, но хочется же ещё уже имеющиеся кодовые базы переводить на модули. И не хочется при этом останавливать разработку.\
Так что нам надо сделать что-то, чтобы разработчики boost'а не писали две копии своей библиотеки: для тех, кто на модулях, и для тех, кто нет.

Значит, смотрите. Использовать модули где попало — на здоровье. Но вот использовать заголовочные файлы там, где уже всё переписано на модули — непонятно как. Мы не можем написать

```c++
export module test;
#include <vector>
// sth
```

Это просто не сработает, потому что у нас в каждом модуле будет свой вектор. Это не то, чего мы хотим. Поэтому у нас есть **global module fragment**:

```c++
module; // Начало global module fragment'а.
#include <vector>

export module test; // Конец global module fragment'а.
export std::vector<int> foo();
```

Так можно было бы создать модульную обёртку стандартной библиотеки.

В global module fragment'е можно писать только препроцессорные директивы, если что.

Второе, что есть для переноса — header unit'ы. Вы можете сказать, что у нас есть заголовочный файл и вы хотите импортировать его как модуль:

```c++
import <vector>;
```

При этом если вы хотите сделать так со своими файлами, вы тоже можете так написать, правда у MSVC надо в настройках проекта пометить свой файл как **header unit**. При этом у нас нет никаких проблем с ODR или ещё чем, если мы делаем `import` нескольких header unit'ов, в которых внутри
где-то определено одно и то же.

### Модули в стандартной библиотеке.

В C++23, кстати, даже стандартная библиотека начала пилиться на модули, все ругались на тему, как же её распилить и в итоге решили сделать очень просто — вся стандартная библиотека один модуль — `std`.\
Попутно они решили проблему, что в C++ на самом деле нет `size_t`, а есть только `std::size_t`, но все это игнорируют. Это решено так: есть модуль `std`, а есть модуль `std.compat`, который выдаёт не только имена через `std::`, но и C-шные `typedef`'ы.
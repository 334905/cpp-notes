# Move-семантика, rvalue-ссылки.
- [Запись лекции №1](https://www.youtube.com/watch?v=KcNJbEmbqB4)
- [Запись лекции №2](https://www.youtube.com/watch?v=p4LQfPJb9Q0)
---
## Мотивация.

Пусть у нас есть следующий код:
```c++
#include <string>
#include <vector>

int main()
{
    std::string string = "Some-very-long-string";
    std::vector<std::string> strings;
    strings.push_back(string);
}
```
Как мы знаем, в последней строке происходит копирование. А если строка очень длинная, то это долго. И не всегда нам это надо, иногда исходная строка нам не нужна, хочется просто указатели поперекидывать и всё.

Хуже ситуация обстоит с переаллокациями, потому что там происходят копирования (очень много копирований). Вообще в C++03 компилятор мог знать, что конкретный тип `std::vector<std::string>` можно как-то оптимизировать, но если вместо строки или вместо вектора рукописный тип, то нет.

А есть ещё другая проблема: некопируемые типы. Для переаллокаций вам нужно копировать внутренний тип, а это значит, что `std::vector<std::fstream>` сделать нельзя. Традиционное решение — `std::vector<std::fstream*>`. Но это, понятно, не очень (это indirection и не exception-safe). Можно жить с `std::vector<boost::shared_ptr<std::fstream>>`, но это лишние расходы памяти под счётчик ссылок (который всегда 1 или 2).

## Copy elision.
Rvalue-ссылки — это метод избегания копирований. Поэтому, чтобы правильно их использовать, надо сначала понять, где копирование происходит, а где — нет.

Часто можно услышать, что передавать параметры по значению и возвращать результат из функции по значению дорого. Но это не всегда так.

### Передача параметров в функцию.
Начнём с того, как передаются параметры в функцию. Например, в ABI линукса прописано, что если структура помещается в два регистра, то она передаётся через них. Если структура занимает больше, то есть два варианта:

```c++
void f(mytype x) { // как передаётся параметр?
    x.a = 42; 
}
// псевдокод:
void f(mytype const& x) {
    mytype x_copy = x;
    x_copy.a = 42;
}
// вызывающая сторона делает копию и передаёт ссылку
void f(mytype& x) {
    x.a = 42;
}
```
Можно посмотреть, во что компилируется функция `f` и увидеть, что это похоже на второй вариант. 

Этот вариант даёт возможность соптимизировать и избегать лишних копирований. Например, в таком случае:

```c++
void g() {
    f(mytype(1, 2, 3));
    f(h());
}
```

Если в функцию передаётся `rvalue`, то компилятор не будет делать лишнюю копию. Таким образом, **копия делается, только если функция принимает по значению и в неё передаётся `lvalue`**.

### Return value optimizations (RVO, NRVO).
Что происходит в компиляторах, когда Вы возвращаете какой-то большой объект, который через регистры нельзя вернуть? Ну, можно передать в функцию указатель, по которому записать ответ:

```c++
mytype f() {
	return mytype(1, 2, 3);    
}
// компилируется во что-то, похожее на:
void f(mytype* uninitialized_result) {
    new (uninitialized_result) mytype(1, 2, 3);
}
```

То есть у вас просто вызывается конструктор от неинициализированной памяти. Правда, иногда это может быть конструктор копирования от чего-то. От чего это зависит? Если из функции возвращается prvalue (особый вид rvalue, см. [ниже](#value-category-в-c11)), то копия не создаётся и объект конструируется уже на месте, куда возвращается значение. Это называется *return value optimization* и начиная с C++17 эта оптимизация обязательна для компилятора.

Но также иногда возможно оптимизировать и иной случай

```c++
std::array<int, 100> h() {
    std::array<int, 100> arr;
    arr[2] = 42;
    arr[3] = 43;
    return arr;
}
// Компилируется в
void h(std::array<int, 100>* uninitialized_result) {
    new (uninitialized_result) std::array<int, 100>();
    (*uninitialized_result)[2] = 42;
    (*uninitialized_result)[3] = 43;
}
```

Эта оптимизация называется *named return value optimization* и позволяет избежать копирования при возврате automatic storage duration объекта. На данный момент эта оптимизация необязательная, но уже есть [proposal](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2025r0.html) на внедрение этого в стандарт.

RVO и NRVO в стандарте называются [copy elision](https://en.cppreference.com/w/cpp/language/copy_elision).

Кстати, избегание копирований и перемещений запрещает вам опираться на то, будет ли вызван конструктор копирования/[перемещения](#специальные-функции-члены-класса).
В таком примере не будет:

```c++
    mytype a = f();
```

И в таком тоже

```c++
    mytype a = mytype(mytype(mytype(f())));
```

Применить NRVO можно не во всех случаях. Например:

```c++
std::string g() {
    std::string a("abc");
    std::string b("def");
    if (flag) {
        return a;
    } else {
        return b;
    }
}
```

## Move-семантика.
Давайте сначала обсудим, как эта гипотетическая операция перемещения работала бы, а потом обсудим, как её писать.

### Идеология move-семантики.
Что можно теоретически сделать с копированием? Можно придумать что-то идеологически похожее на копирование, но такое, что оригинальный объект может меняться. Типа такого:

```c++
string(string& other) // "Типа перемещение".
    : data(other.data)
    , size(other.size)
    , capacity(other.capacity)
{
    other.size = other.capacity = 0;
    other.data = nullptr;
}
```
Тогда при помощи этого мы и копирования (в контейнерах, например) избегаем, и с некопируемыми типами жить можем (в случае `std::fstream` скопируем все поля, а для оригинального типа сделаем вид, что это закрытый поток).

Передача объекта в такой конструктор может испортить передаваемый объект, но этот объект должен остаться в таком согласованном состоянии, что у него можно вызвать деструктор. При этом это состояние в общем случае unspecified и полагаться на него не следует. Почему? Например, у нас строка могла использовать small-object оптимизацию, и тогда скопировать проще, чем скопировать и очистить строку. Поэтому, кстати, move в C++ называется "недеструктивным".

Так, чего ещё нам не хватает для хорошей жизни? Нам не хватает возможности в каждый контейнер передать тип, чтобы тот переместился. То есть нам нужна вариация, например, `push_back`'а, которая принимает изменяемую ссылку.

### Rvalue-ссылки.
Всё вышеописанное можно было бы теоретически и с C++03 реализовать. Но это совершенно неудобно, поэтому язык расширили и добавили rvalue-ссылки.

В эти ссылки можно присвоить временные объекты:

```c++
    int a;

    int& l1 = a;   // Успех.
    int& l2 = 42;  // Ошибка.

    int&& r1 = a;  // Ошибка.
    int&& r2 = 42; // Успех.
```

Теперь мы можем написать вот это:

```c++
template <class T>
class vector
{
    void push_back(const T&) { /* Для lvalue. */ }
    void push_back(T&&)      { /* Для rvalue. */ }
};
```

Первый копирует, второй перемещает. В каждом месте, где делается `push_back` от rvalue, будет вызываться перегрузка именно для rvalue-ссылки.

### Специальные функции-члены класса.

Ну, всё это, конечно, очень хорошо, но ведь тот же `vector::push_back` от `T&&` должен перемещать объект на неинициализированную память. А это значит, что у нас должен быть перемещающий конструктор и перемещающий оператор.

```c++
class my_type
{
    my_type(my_type&&);
    my_type& operator=(my_type&&);
};
```

### std::move.
```c++
class person
{
private:
    std::string name;

public:
    person(const std::string& name)
        : name(name)
    {}
    person(std::string&& name)
        : name(name)
    {}
};
```
Корректен ли этот код? А вот нет. Дело тут в том, что `std::string&& name` не считается временным объектом, поэтому тут вызовется копирование. Для того, чтобы это поправить, достаточно написать `static_cast`:

```c++
    person(std::string&& name)
        : name(static_cast<std::string&&>(name))
    {}
```

Разве что такая функция уже есть в стандартной библиотеке и называется `std::move`.

```c++
template <typename T>
T&& move(T& obj) {
    return static_cast<T&&>(obj);
}
```

В стандартной библиотеке у move сигнатура немного отличается. Написанная выше функция не может принимать rvalue (например, `std::move(42)` не скомпилируется), в стандартной библиотеке move устроен таким образом, что он работает и для rvalue тоже, хотя используется редко.

Пользоваться им можно не только для передачи rvalue-ссылок, а ещё чтобы явно переместить объект:

```c++
    std::vector<std::string> strings;

    std::string input;
    std::cin >> input;
    string.push_back(std::move(input));
```

## Best practices.
А что, если мы хотим копировать/перемещать несколько аргументов? Для параметров, переданных как lvalue, мы хотим сделать копию, а rvalue переместить. Так вот же что можно сделать:

```c++
struct person {
    person(std::string name, std::string surname)
        : name(std::move(name)),  surname(std::move(surname)) {}
}
```

Так мы получим нужно поведение за исключением того, что иногда move-конструктор вызовется лишний раз (когда делаем копию и вызываем move). Обычно это оптимизируется и не влияет на производительность, но если вам всё же нужно, сделайте 4 перегрузки.


## Worst practices.
Вот был у нас код:

```c++
std::string foo()
{
    std::string res;
    res += "Hello, ";
    res += "world!";
    return res;
}
```

Но, блин, нам же, кажется, надо перемещать, надо где-нибудь `std::move` написать. И есть два варианта:

```c++
std::string&& foo()
{
    std::string res;
    res += "Hello, ";
    res += "world!";
    return std::move(res);
}
```

```c++
std::string foo()
{
    std::string res;
    res += "Hello, ";
    res += "world!";
    return std::move(res);
}
```

Первое просто некорректно (возвращаем ссылку на локальную переменную), второе — предотвращает NRVO. Правильный вариант — тот, что был изначально. Даже если NRVO не сработает, объект вам всё равно переместят.

Мораль: **не стоит использовать `std::move` там, где он не нужен**.

## Value category в C++11.

Давайте вот на что посмотрим:
```c++
struct mytype {};

mytype rvalue();
mytype& lvalue();

void foo(const mytype&);
void foo(mytype&&);

mytype test()
{
    foo(rvalue());   // Вызов от rvalue-ссылки.
    foo(lvalue());   // Вызов от lvalue-ссылки.

    return rvalue(); // rvalue, есть RVO.
    return lvalue(); // lvalue, нет RVO.
}
```

Но что же будет, если мы будем возвращать `mytype&&`?

```c++
mytype&& unknown();

mytype test()
{
    foo(unknown());   // Вызов от rvalue-ссылки.
    return unknown(); // Нет RVO, видимо, всё-таки lvalue.
```

Вот такая штука называется [xvalue](https://en.cppreference.com/w/cpp/language/value_category#History).

![img](images/09.05_value_category.jpg)

prvalue — самые классические rvalue, которые мы знали раньше.

xvalue — то, что для перегрузок rvalue, а для copy elision lvalue.

## Увеличение времени жизни временных объектов *(since C++03)*.

```c++
    const my_type& ref = my_type();
```
Казалось бы, `ref` ссылается на некорректный объект, потому что он же временный, его удалят в этой же строке. Но это не практично, как оказалось, поэтому есть правило продление жизни. Время жизни объекта, который биндится к `const&`, продлевалось для rvalue.

В C++11 xvalue ведут себя подобно lvalue: время жизни объекта продлить нельзя, так как мы его  никак не контролируем.

```c++
void foo() {
    mytype const& a = prvalue(); // объект живёт столько, сколько эта ссылка
    mytype&& a = prvalue(); // аналогично продлевает время жизни
    
    mytype& a = lvalue(); // не продлевает
    mytype&& a = xvalue(); // не продлевает
}
```

**Когда вы вешаете на временный объект (prvalue) ссылку (`const&` или `&&`), время жизни временного объекта длится до окончания жизни ссылки**.
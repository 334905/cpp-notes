# Идеальная передача и variadic-шаблоны.
- [Запись лекции №1](https://youtu.be/M9h0_xBM7_8?t=1786)
- [Запись лекции №2](https://www.youtube.com/watch?v=ydQD7-XSSt4)
---

Когда мы говорили про `shared_ptr`, у нас была функция `make_shared`, которая принимала какие-то аргументы и передавала их в конструктор. Возникает вопрос: что это за магия?

Чего мы глобально хотим? Пусть у нас (примера ради) будет семейство функций

```c++
void f(int&);
void f(char);
void f(std::string*);
```

И мы хотим сделать функцию `g`, которая вызывает нужную перегрузку `f`. Как это сделать? Ну, посмотрим на 3 способа:

```c++
template<typename T>
void g1(T a){
    f(a);
}
template<typename T>
void g2(T const& a){
    f(a);
}
template<typename T>
void g3(T& a){
    f(a);
}
```

Но тут все 3 случая не подходят:

- Принимать по значению — не то, что нам нужно, мы не хотим создавать лишнюю копию.
- Принимать по `const&` не получится, если на самом деле функция `f` принимает изменяемую ссылку.
- Принимать по `&` нельзя, так как она не привязывается к `rvalue`.

Что в итоге хочется? Хочется, чтобы у нас сохранялись `const`'ы и [value category](./17_move_rvalue.md#value-category-в-c11). Для этого в C++11 есть механизм, который называется **perfect forwarding** (**идеальная передача**), но чтобы его понять, надо сначала познакомиться с некоторыми правилами из C++11.

## Работа с rvalue-ссылками.

### Правило сворачивания ссылок.

В C++ нельзя сделать ссылку на ссылку, однако никто не мешает написать такой код:

```c++
typedef int& type;
mytype1& x;

// ...или...

template <typename T>
void foo(T&);

int main() {
    foo<int&>();
}
```

Есть только один способ логически это определить: ссылка на ссылку — это просто ссылка (это называется **сворачиванием ссылок**/**reference collapsing**).

Но когда в C++11 появились ещё rvalue-ссылки, понадобилось определить сворачивание для них. Так вот его определили так: если сворачивать lvalue ссылку с чем угодно, получится lvalue-ссылка. Если сворачивать rvalue друг с другом, то rvalue-ссылка:

```plain
T& & -> T&
T& && -> T&
T&& & -> T&
T&& && -> T&&
```

Зачем это определено так? Ровно затем, чтобы работал perfect forwarding.

### Правило вывода ссылок. Универсальные ссылки.

Вот есть у вас

```c++
template <class T>
void foo(T x);
```

Как на основе вызова определить, какой тип у нас в качестве `T`? Ну, у компилятора есть какие-то правила для разных вещей. Для вот такого есть какие-то правила, например:

```c++
template <class T>
void foo(std::pair<T, T*> x);
```

Компилятор будет пытаться как-то сопоставить `std::pair<T, T*>` с тем, что было передано. Сейчас не важно, как именно, а важно то, что в C++11 появились rvalue-ссылки, а значит появилась необходимость определить правила вывода шаблонного типа для такого кода:

```c++
template <typename T>
void f(T&& a);
```

А выводится оно так:

```c++
template <class T>
void foo(T&& x);

int main() {
    foo(42); // T -> int.
    foo(static_cast<int const&&>(42)); // T -> int const.

    int u;
    int const v;
    foo(u); // T -> int&.
    foo(v); // T -> int const&
}
```

То есть по `T&&` можно передать как rvalue, так и lvalue. Поэтому такие ссылки (шаблонный параметр + rvalue-ссылка) называются *универсальными*.

## `std::forward`.

Ну, хорошо, так и как с использованием правил выше написать то, что мы изначально хотели? Ну, вот так:

```c++
template <class T>
void g(T&& x) {
    f(static_cast<T&&>(x));
}
```

Разберём, почему это работает.

Если в `g` приходит `42`, то `T` выводится в `int`, и наша функция превращается в

```c++
void g(int&& x) {
    f(static_cast<int&&>(x));
}
```

Это же ровно то, что нам нужно.\
Если Вы передадите переменную типа `int`, `T` выведется в `T&`, а значит, с учётом сворачивания ссылок, `g` превратится в

```c++
void g(int& x) {
    f(static_cast<int&>(x));
}
```

С `const`'ами тоже всё будет хорошо, можете проверить сами.

То есть так всё хорошо, разве что `static_cast` никто писать не любит. Обычно вместо него пишут функцию `std::forward`, которая, по сути, этот `static_cast` и содержит.\
Давайте попробуем сами её написать:

```c++
template <typename T>
T&& forward(T& x) {
    return static_cast<T&&>(x);
}
```

Но тут есть существенная проблема: если мы напишем `forward(x)` вместо `forward<T>(x)`, а это просто `std::move`. Почему? Ну, давайте посмотрим на `T -> int&`:

```c++
void g(int& x) {
    f(forward(x));
}
```

Тут происходит автоматический вывод шаблонного типа в `forward`. Мы передаём `int&`, а `forward` принимает `T&`. Отсюда `T -> int`:

```c++
int&& forward(int& x) {
    return static_cast<int&&>(x);
}
```

Пожалуйста, `move`. А если же мы в `g` явно напишем `forward<T>(x)`, то вспомним, что у нас в функции `g` `T -> int&`, а `forward<int&>` — как раз то, что хочется.

Чтобы такого не было, надо подавить автоматический вывод ссылок в `std::forward` (чтобы всегда явно передавали). Самый простой сделать это вот так:

```c++
template <class T>
struct identity {
    using type = T;
};
template <typename T>
T&& forward(typename identity<T>::type& x) {
    return static_cast<T&&>(x);
}
```

Когда у вас в аргументах подобный dependent-тип, его в общем случае очень сложно вывести, поэтому его и не выводят, и тут это работает.\
Примерно так `std::forward` и выглядит, разве что там решили не заводить отдельную структуру, а использовать `std::remove_reference_t`, который, вообще говоря, полностью эквивалентен `identity`, потому что в `identity` у нас всё равно ссылки коллапсируют в lvalue-ссылку.

## Variadic templates / Шаблоны с переменным количеством аргументов.

Осталось понять, как делать функцию, принимающую произвольное число шаблонных параметров. Для этого в C++ сделали специальный синтаксис variadic шаблонов:

```c++
template <class... T>
class tuple {
    // ?????
}

template <class... T>
void foo(T... args) {
    tuple<T...>(args) t;
    // ...
}
```

Возникает вопрос: а зачем писать `tuple<T...>`, почему не `tuple<T>`? Ну, потому что тогда непонятно, что должно произойти тут: `tuple<tuple<T>>`. Это `tuple<tuple<T1, T2, ...>>` или `tuple<tuple<T1>, tuple<T2>, ...>`? Поэтому вы явно пишете многоточие там, где хотите, чтобы все аргументы перечислились через запятую (хотя вообще есть [другие варианты](https://en.cppreference.com/w/cpp/language/fold)).

На самом деле, вам через запятую перечисляются не сами аргументы, а то, что вы написали слева от многоточия. Это ещё шаблоном распаковки называется. То есть вот пишите вы `tuple<tuple<T>...>`, и `tuple<T>` — шаблон распаковки, и распакуют это в соответствии с ним: `tuple<T1>, tuple<T2>, ...`.

Но ладно, с `tuple` пример немного дурацкий, но вот, смотрите:

```c++
template <class... T>
void foo(T... args) {
    f(g(args...)); // f(g(arg0, arg1, arg2, ...))
    f(g(args)...); // f(g(arg0), g(arg1), g(arg2), ...)
}
```

Более того, многоточие можно использовать несколько раз:

```c++
f(g(args, args...)...);
// Раскрывается в:
f(g(arg0, arg0, arg1, arg2, ...),
  g(arg1, arg0, arg1, arg2, ...),
  g(arg2, arg0, arg1, arg2, ...),
  ...);
```

Или так:

```c++
f(g(args, args)...);
// Раскрывается в:
f(g(arg0, arg0),
  g(arg1, arg1),
  g(arg2, arg2),
  ...);
```

При у нас может даже две разных группы параметров:

```c++
template <class... Ts>
class outer {
    template <class... Us>
    class inner {
        tuple<pair<Ts, Us>...> t;
    };
};
```

И если у нас разной длины `Ts` и `Us`, то произойдёт ошибка компиляции.

И из последнего примера мы можем без проблем реализовать `std::make_unique`:

```c++
template <class T, class... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}
```

Что у нас происходит в строке `std::forward<Args>(args)...`? Ну, у нас есть два пака параметров: `Args` и `args`. И они раскрываются вместо попарно как `std::forward<Arg0>(arg0), std::forward<Arg1>(arg1), ...`. Что нам и надо.

Кстати, в примере выше был использован простой трюк, чтобы передать два пака шаблонов. Всегда ли он нужен? Для первичного шаблона — увы, да, для них пак параметров должен быть последним в списке.

```c++
template <typename... U, typename... V> // COMPILE ERROR
struct x {}; 

template <typename... U, typename V> // COMPILE ERROR
struct y{}; 

template <typename U, typename... V> // OK
struct t {}; 
```

Но вот для частичных специализаций нет, так как они выводятся, а не указываются явно:

```c++
template <typename T, typename U>
struct foo;

template <typename... TArgs, typename... UArgs>
struct foo<tuple<TArgs...>, tuple<UArgs...>>
{};

int main() {
    foo<tuple<int, float>, tuple<double, char>> bar;
}
```

Для функций шаблонные параметры тоже могут выводиться,  поэтому для функций нет ограничений на то, что пак должен быть последним:

```c++
template <typename... U, typename... V>
void baz(tuple<U...>, tuple<V...>) {
    tuple<pair<U, V>...> t3;
}
```

Ещё очень хорошо шаблоны с переменным числом аргументов заходят в комбинации с рекурсивными определениями:

```c++
template <typename... Ts>
void write() {}

template <typename T0, typename... Ts>
void write(T0 const& arg0, Ts const& ...args) {
    std::cout << arg0;
    write(args...);
}
```

Впрочем, конкретно то, что написано тут, можно очень хорошо написать проще, с использованием [свёрточных выражений](https://en.cppreference.com/w/cpp/language/fold):

```c++
template <typename... Args>
void write(Args const&... args) {
    (std::cout << ... << args);
}
```
# Концепты

- [Запись лекции №1](https://youtu.be/KNF4j-lz_Do)
- [Запись лекции №2](https://youtu.be/i6rR_kEBQGc)

## Мотивация.

Пусть у нас есть `vector`. Когда мы пишем `template <typename T>`, мы можем в качестве `T` подставить всё, что угодно (ссылки, типы-функции, хоть `void`). Но нам же не любой тип подходит: нам нужно nothrow destructible или ещё какие хорошие свойства у типа (вообще в случае с вектором ограничения не на тип `T`, а на аллокатор — второй шаблонный параметр `vector`'а, но не суть). И выразить это ограничение явно никак не могли до C++20.

Ну, хорошо, а зачем? Зачем явно уметь указывать ограничения?

- Самый частый ответ выглядит так: пока у нас программа компилируется, всё хорошо. Но давайте попытаемся подставить в вектор то, что подставить нельзя. Например, нет деструктора. Понятно, что мы увидим ошибку. Но какую? Компилятор скажет, что предпринята попытка ссылки на удалённую функцию (деструктор) и покажет цепочку функций, откуда и кто хочет вызвать этот деструктор. У нас ошибка компиляции где-то глубоко в коде зарыта, да ещё и сообщение не очень содержательное сообщение выводится. В случае `vector<int&>` мы получим сообщение «невозможно создать указатель на ссылку». Если мы подставим `vector<void()>`, то у нас совсем будет что-то несодержательное (*arithmetic on pointers to type void ()*, и совсем непонятно, причём тут это вообще). 

  Причём в разных компиляторах будут разные источники ошибок. Хочется более адекватных сообщений об ошибках и не где-то, а при подстановке шаблона.\
  Тут нам может помочь `static_assert`, но поможет не везде. 

- Поэтому давайте посмотрим на второй пример: У `vector`'а есть метод `assign`:

  ```c++
  void assign(size_t n, T const& value);

  template <typename InputIt>
  void assign(InputIt first, InputIt last);
  ```

  Тогда мы проиграем, если сделаем

  ```c++
  vector<int> v;
  v.assign(10, 42);
  ```

  Почему? Потому что первая перегрузка требует преобразования типов, а вторая — нет, там `assign(int, int)`. И мы проиграем во время компиляции. Тут нам не поможет `static_assert`, но поможет SFINAE. То есть тоже в целом решаемо, но тут мы получаем не очень приятный код, да ещё и сложно объяснить новичку, что в этих `enable_if`'ах происходит. К тому же SFINAE сложно понять не только человеку, но и компилятору. Мы в целом абьюзим языковые механизмы, которые изначально не для того сделаны.
  
- И в-третьих, у нас в SFINAE очень страшно выглядят ошибки компиляции: *ошибка подстановки <какая-то страшная хрень>: не найдён `type` у `enable_if<что-то>`*. Поэтому компиляторам пришлось специально проверять, что у нас ошибка подстановки не по какой-то причине, а потому что у нас `enable_if`.

- И есть ещё проблемы SFINAE. Вспомним `std::advance`. Он по-разному работает для разных типов итераторов, там какой-то tag dispatching или `if constexpr`, и с этом опять же можно жить, но нам надо либо какие-то функции создавать, какие-то свои теги, что-то ещё. Причём в обоих этих решениях **мы не можем просто дописать перегрузку к набору**. Ровно как и со SFINAE также не можем просто расширить: если у нас какие-то две сущности, что одна обладает всеми свойствами, что вторая, но ещё какими-то, нам придётся явно выражать условие, что тип обладает одним свойством, но не другим.

  Как это с обычными перегрузками работает?
  
  ```c++
  struct A {};
  struct B : A {};
  struct C : B {};

  void foo(A&);
  void foo(B&);
  void foo(C&);

  int main() {
    C c;
    foo(c);
  }
  ```

  Несмотря на то, что у нас во все три перегрузки c подходит, из этих трёх мы можем выбрать наиболее специализированную перегрузку, и всё будет хорошо. Когда мы сделаем структуру `struct D : C {}`, мы сможем спокойно написать `void foo(D&)`, и всё будет работать хорошо.

  А теперь представьте, что у нас `A`, `B` и `C` — это свойства какие-то, а не типы. Тогда, написав что-то подобное, мы проиграем:

  ```c++
  template <class T>
  std::enable_if<A<T>> foo(T&);
  template <class T>
  std::enable_if<A<T> && B<T>> void foo(T&);
  template <class T>
  std::enable_if<A<T> && B<T> && C<T>> void foo(T&);
  ```

  Тут мы получим, что у нас в случае `C` всё подходит, поэтому ambiguous. Надо так:

  ```c++
  template <class T>
  std::enable_if<A<T> && !B<T>> foo(T&);
  template <class T>
  std::enable_if<A<T> && B<T> && !C<T>> void foo(T&);
  template <class T>
  std::enable_if<A<T> && B<T> && C<T>> void foo(T&);
  ```

  Добавляя новую перегрузку, придётся дописать `&& !D<T>` ко всем уже имеющимся вариантам.\
  А вот концепты умеют в ранжирование компилятором, поэтому с ними нет проблем с расширяемостью.

- И, в конце-концов, когда мы пользуемся SFINAE, нам жизненно необходимо, чтобы всё используемое нами было SFINAE-friendly. Помните, как писать SFINAE-friendly `optional`? Сложно и неприятно.

Итого концепты дают нам:

1) SFINAE-friendly.
2) Расширяемость условий.
3) Сложные предикаты на концептах будут выглядеть проще.
4) Упрощают случаи когда нужно выбирать реализацию в зависимости от свойств типа.
5) Ускорение времени компиляции.
6) Делают сообщения об ошибке читаемыми.

## Исторический контекст и дизайн концептов.

Ещё Александр Степанов в описании STL ввёл термин
«концепт», и ещё тогда, в девяностых, была идея что-то такое сделать. Но тогда и шаблоны были в
новинку, считалось, что это уже очень сложно, и добавлять ещё и концепты было бы очень сложно.
Но в целом работа над концептами началась уже тогда, когда началась работа над C++11. У людей
был прототип компилятора (concept gcc), эти люди концептуализировали STL, и казалось, что всё это
будет уже в C++11, в черновиках стандарта уже были концепты, но прямо перед выпуском C++11
концепты решили удалить из стандарта, потому что не у всех была уверенность в том, что дизайн
концептов в том виде, как они есть, вызывал вопросы, насколько он долговечен и хорош.
На какую тему шли дискусии?

### Explicit vs implicit концепты
Пусть у нас есть класс `my_type`, у которого написан `operator<`. Чтобы наш тип удовлетворял концепту *comparable*, этого достаточно, или надо как в Java написать `implements Comparable<T>`? Аргументы есть и за и против. Первое называется implicit, второе explicit.

Плюсы explicit:
  - Есть некоторые концепты, которые нельзя никак отличить по синтаксическим требованиям (например, `InputIterator` и `ForwardIterator` имеют один и тот же набор операция, но `ForwardIterator` может несколько раз пройти по одному месту, что не выражается никак). Т.е в таких случаях без explicit concepts не обойтись, потому что хочется уметь различать эти два концепта.
  - Вот написали вы метод `add`. Возникает вопрос: а это что значит должно? Это сложение, добавление в контейнер или что вообще? А если вы явно укажете концепт, то станет ясно.

Минусы explicit:
  - При попытке внедрения концептов в стандартную библиотеку explicit concepts казались все большим и большим бойлерплейтом.

В изначальной реализации были и те, и другие концепты, большая часть была явной, но с течением времени разные люди приходили, говорили, что для данного концепта явность — плохо, есть совершенно тупой пример, который не работает.\
И со временем всё больше и больше концептов становились неявными.

Те **концепты, которые вошли в C++20 только неявные**.\
Впрочем, если нам надо, чтобы какой-то концепт был явным, заведите рядом с ним trait. Но вообще в жизни это бывает нужно довольно редко. В STL это только итераторы и диапазоны. В первом есть `iterator_traits`, во втором — есть шаблонная переменная `enable_borrowed_range`.

### Definition checking.

Рассмотрим вот это:

```c++
void advance(std::input_iterator auto& iter, std::integral auto distance) {
  // ...
}
```

Тут можно двояко понимать то, что написано. Либо мы обязуемся использовать только то, что написано в `std::input_iterator`, либо это просто функция, в которую можно подставить только `std::input_iterator`. То есть компилятор либо проверит заранее, что мы внутри функции используем только то, что положено, либо нет. Это называется
**definition checking**.

В изначальном proposal'е definition checking был (ну, потому что хочется иметь его; почему шаблоны порождают такие длинные сообщения об ошибке? потому что компилятор не знает, где ошибка, и выдаёт все возможные места).

Но с Concept GCC была проблема: он существенно замедлял компиляцию программы. Это вызывало беспокойство. Авторы утверждали, что это проблема их реализации, а не самой идеи, но прототипа, который работал хорошо, у них
не было.\
Второй момент — давайте попытаемся залогировать то, что приходит в качестве параметра. Но у нас же definition checking, с чего бы наши типы умели выводиться? Сейчас мы бы просто занесли это под какой-нибудь `if constexpr`, но тогда подобного не было.\
И в-третьих, возникают тонкости со взаимодействием с обычными шаблонами: они же не проверяют ничего. И это ладно, а вот что будет, если вы из концептуального мира вызываете что-то, что делает tag dispatching?

### Как концептуализирована стандартная библиотека.

Мы для `set` требуем, чтобы типы нуждались в `<`. И когда это концептуализируем, можно требовать либо только `<`, либо все операции. Если требовать все, то сломается куча кода. Поэтому концепты типа *ordered* начали дробиться на более гранулярные: типа нам хватит только сравнения на меньше. Или вот у нас есть `std::advance`: может, нам там не нужен именно итератор, а хватит только инкремента? И тогда теряется смысл у каждого конкретного концепта: если раньше мы знали, что итератор — это понятная сущность, то теперь нет. И суммарно для стандартной библиотеки понадобилось 100 концептов. В итоге концепты перестали дробить.

В итоге люди отбросили идею концептов из C++11 и решили разработать что-то, что будет не настолько хорошим, но работающим.

И уже к C++17 концепты были по сути готовы, но у людей были беспокойства на тему, насколько всё продумано. А ещё в STL никакие концепты не добавлялись, что вызывало у людей озабоченность. А ещё в C++17 есть proposal по `auto`, и он там немножко конфликтует с [proposal'ом по концептам](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2013/n3701.pdf) (была конструкция, что читалась двояко). И ещё были люди, которые сомневались, что можно будет потом допилить definition checking.

И вот в C++20 всё (кроме definition checking'а) порешали, и теперь концепты у нас есть.

## Синтаксис.

Вот так создать концепт: 
```c++
template <typename T>
concept destructible = std::is_nothrow_destructible_v<T>;
```

### Requires clause.
Вот так потребовать его выполнения:
- Полная форма

  ```c++
  template <typename T>
  requires destructible<T>
  void f(T&);
  ```

- Форма чуть покороче:

  ```c++
  template <destructible T>
  void f(T&);
  ```

- Самая короткая:

  ```c++
  void f(destructible auto&);
  ```

Формально:

```c++
// Запись...
template <C<A, B, C> X>
// ...эквивалентна
template <typename X>
requires C<X, A, B, C>

// А запись...
f(C<A, B, C> auto);
// ...эквивалентна
template <C<A, B, C> T>
f(T);
```

Выражение вида `requires expr` называется **requires clause**.

### Requires expression.
А ещё есть **requires expression** — позволяет проверить, что тип поддерживает какую-то операцию:

```c++
template <typename T>
bool comparable = requires(T a) { // также можно concept, а не bool
  {a < a} -> std::convertible_to<bool>;
  // В жизни не надо проверять наличие только меньше, проверьте наличие всего.
};
```

Внутри requires expression можно делать 4 вещи:

```c++
template <class T>
concept something = requires(T x) {
  // simple requirement
  x.foo(); // В x есть функция foo без параметров.

  // type requirement
  typename T::value_type; // В T есть тип value_type.

  // compound requirement
  {x < x} noexcept -> std::same_as<bool>;
  // Выражение компилируется и результат удовлетворяет концепту. И noexcept ещё.
  // noexcept и результирующий концепт можно не писать, если не надо.

  // nested requirement
  requires destructible<T>;
  // Выполнены какие-то ещё концепты.
}
```

## Специализации (или как это здесь называется).

Компилятор про концепты знает чуть больше, чем про обычные `constexpr` `bool`-переменные. Он знает, когда один концепт более специализирован, нежели другой. Как это работает?

```c++
template <class T>
concept integral = std::is_integral_v<T>;

template <class T>
concept signed_integral = std::integral<T> && std::is_signed_v<T>;
```

Как компилятор понимает, какой концепт расширяет другой? Для этого в стандарте определяется специальный [алгоритм](https://en.cppreference.com/w/cpp/language/constraints) (см. partial ordering of constraints).

Точно не будет работать такое:

```c++
template <size_t N>
requires (N > 5)
void foo(std::array<int, N>&);

template <size_t N>
requires (N > 7)
void foo(std::array<int, N>&);
```

Компилятор считает эти штуки одинаковыми.

Алгоритм работает так:\
Компилятор строит нормальную форму: он берёт `&&`, `||` и концепты, раскрывает все их, а всё остальное считает **atomic constraint** (т.е. их он не сравнивает). И дальше компилятору надо сравнить, верно ли, что чисто по атомарным constraint'ам из одного следует другое.\
Например, определение `std::random_access_iterator` просто начинается с `std::bidirectional_iterator<T> &&`, и поэтому он более специализирован, нежели `std::bidirectional_iterator`.

Что важно понимать — `requires-expression` считается атомарным
constraint'ом. Не конъюнкцией.

Этот механизм приводи к интересным спецэффектам:

```c++
template <typename T>
requires destructible<T>
void foo(T&) {}

template <typename T>
requires destructible<T> && true
void foo(T&) {}
```

Нижняя функция более специализирована, нежели верхняя.
И такое — ещё половина беды.

```c++
template <typename T>
requires integral<T> && true
void foo(T&) {}

template <typename T>
requires signed_integral<T> && true
void foo(T&) {}
```

Не компилируется, потому что `true` здесь — два разных atomic constraint'а, которые никак не связаны.

## Применение

Жалеющие могут посмотреть [презентацию Андрея Давыдова про концепты](https://www.youtube.com/watch?v=vYzjV0xSqJE).

А мы сейчас рассмотрим один показательный пример. Помните `optional`? И то, как мы там пытались [сохранить тривиальность](./25_optional_variant_tuple_stringview.md#тривиальные-операции) и наличие операций. Там было наследование от 5 баз. Так вот с концептами всё намного проще:

```c++
template<typename T> class optional {
    // ...

    optional(optional const&) = delete;

    optional(optional const&) noexcept(NothrowCopyConstructible<T>)
    requires CopyConstructible<T> {
      // ...
    }

    optional(optional const&) requires TriviallyCopyConstructible<T> = default;

    // ...
}
```

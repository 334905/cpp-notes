# Инициализация, constexpr

- [Запись лекции №1](https://youtu.be/Dp2AIvae27M?t=1377)
- [Запись лекции №2](https://www.youtube.com/watch?v=N7P81pzup6w)

## Мотивация.
Давайте посмотрим на `variant` от двух типов. Как его можно было бы хранить?

```c++
template <class A, class B>
struct either {
    size_t which;
    std::aligned_storage_t<std::max(sizeof(A), sizeof(B)),
                           std::lcm(sizeof(A), sizeof(B))> storage;
};
```

Однако до C++03 была проблема: `std::max` — это обычная функция, а результат её должен был быть известен во время компиляции, поэтому приходилось извращаться:

```c++
template <size_t a, size_t b>
struct max {
    static const size_t value = a < b ? b : a;
};
```

И это чудо не только читается сложно и пишется долго, это и для компилятора не так просто: класс — не самая простая штука.

А во время компиляции считать хочется: иногда (как тут) это жизненно необходимо, а иногда можно и
во время исполнения, но очень хочется при компиляции.

### Статическая и динамическая инициализация

```c++
int f() {
    int result;
    std::cin >> result;
    return result;
}

int a = 42; // инициализируется в момент компиляции
int b = f(); // инициализируется при запуске перед запуском main
```

Переменные `a` и `b` устроены по разному: `a` инициализируется на этапе компиляции, а под `b` просто резевируются 4 байта, а её инициализация происходит в момент старта программы.  Говорят, что переменная `a` **инициализируется статически**, a `b` — **инициализируется динамически**.

Динамическая инициализация глобальных переменных происходит в момент запуска программы до входа в функцию `main`, соответственно, разрушаются они после выхода из `main`.

Есть несколько причин, почему динамическая инициализация может быть нежелательна:

- Тратит время при запуске программы. Просто представьте: вот есть у нас [`std::function`](./22_lambdas_type_erasure.md#type-erasure-stdfunction). В нём есть константные таблицы указателей на функции, которые заводятся при каждом инстанциировании `std::function<F>::operator=`. Вы точно хотите, чтобы все возможные таблицы создавались во время исполнения.
- Гарантируется, что в одной единице трансляции переменные инициализируются сверху вниз, а между разными порядок не гарантирован. Это может стать проблемой, если инициализация переменной в одной трансляции обращается к переменной в другой, а та ещё не инициализирована.
- Исключение в динамической инициализации завершает программу, так как до входа в `main` его негде поймать.

Короче, на этапе компиляции считать хочется. Помимо `std::function` можно много примеров привести: пусть у нас есть парсер, лексер или ещё какой-то разборщик языка. И мы хотим каждое ключевое слово запихнуть в хэш-таблицу. И очень-очень хочется, чтобы хэш-функция была построена с маленьким количеством бакетов, если все ключевые слова мы знаем заранее. В C для этого использовали кодогенераторы (берём слова, наша программа генерирует нам код той хэш-функции, что нам нужна). Но зачем, можно же сделать так, чтобы на нашем родном языке всё было бы хорошо.\
И ещё тысячу разных примеров можно придумать, когда хочется вычисления на этапе компиляции: [регулярные выражения](https://github.com/hanickadot/compile-time-regular-expressions), например.

## `constexpr`-функции.   

В C++11 разрешили делать функции, которые могут исполняться во время компиляции. Если функция со спецификатором `constexpr` принимает аргументы, значения которых - константы времени компиляции, то её значение может быть вычислено в момент компиляции, иначе при исполнении.

```c++
template <typename T>
constexpr T const& max(T const& a, T const& b) {
    return a < b ? b : a;
}
```

В C++11 были жёсткие ограничения для таких функций (их тело должно было содержать в себе только один `return`, например), но потом в каждом стандарте расширялся список того, что внутри `constexpr`-функций можно делать. В C++14, например, разрешили `while`, в C++20 — вызывать виртуальные функции и делать аллокации (правда только в том случае, если вы всё освободите до выхода из `constexpr`), а в C++23 `constexpr`'овой сделали математическую библиотеку.

Кстати. А всегда ли обязана функция вычислиться во время компиляции? Ну, объективно, нет
```c++
int isqrt(int n) {
    if (n < 0)
        throw new runtime_error("Integer square root of negative value.");
    /*
     * Вычисляем целочисленный квадратный корень.
     */
}
int x = isqrt(-1);
```
Тут даже нет ошибки компиляции, тут просто во время исполнения вы получите исключение. Исключения нельзя выкидывать из `constexpr`. Ровно как и нельзя, чтобы `constexpr`-функция делала UB: иначе вашу функцию просто не посчитают во время компиляции (кстати, этим даже пользуются: UB в `constexpr` ловит вам UB и утечки памяти, а значит напишем всё `constexpr` и хороший компилятор сам найдёт обращение вне массива, неверное обращение к `union`'у и кучу всего другого...) В конце концов вы можете вызвать не-`constexpr` функцию в `constexpr`, и тогда, если исполнение дойдёт до этого, во время компиляции вашу функцию считать не будут. Короче, `constexpr` — то, что можно попробовать вычислить во время компиляции.

Так а какой тогда у `constexpr`'а смысл, если это разрешает компилятору считать функции во время компиляции? Не сделать ли все функции `constexpr` по умолчанию? Вон, в GCC есть флаг *-fimplicit-constexpr*, который так делает. Ну, да, но нет. Если Вы знаете, что вашу функцию бессмысленно (но можно) считать во время компиляции, то компиляторы бы тратили кучу времени на то, что пытались.

Кстати, а что точно нельзя писать в `constexpr`? `goto`, например, но это, вероятно, до тех пор, пока никто proposal соответствующий не написал. А вот что делать явно и фундаментально нельзя — это ASM-вставки и вызов функций без тела. Это понятно, почему так. А вот что непонятно, это `reinterpret_cast`. С ним просто непонятно, его фундаментально нельзя или ещё какая причина, но вот можете почитать [тред](https://lists.isocpp.org/std-discussion/2021/10/1442.php) на эту тему. А вообще есть `std::bit_cast`, который в хороших компиляторах даже проверяется, что
объекты не содержат паддинг.

Кстати, про аллокации. Как уже было сказано, мы можем их использовать только если мы всё освободим в конце (такие аллокации называются **transient**). Но это же не удобно, если мы хотим заполнить `vector` заранее и вернуть его. И поэтому есть спрос на non-transient аллокации внутри `constexpr`, но пока совершенно непонятно, как это сделать.

А ещё вот за что поговорим: может ли компилятор проигнорировать `new` и `delete`, если видит их рядом и не видит причин, почему нужну действительно выделять и освобождать память? Ну, может, а почему нет. Но вот что не может, так это вот что:
```c++
delete new int(42); // Можно обойти.
operator delete(operator new(8)); // Нельзя обойти.
```
Почему? Ну, потому что `operator new` и `operator delete` — обычные функции, и их можно подменить. Поэтому лучше использовать вызовы `std::allocator`, их обходить по стандарту можно. К чему это, собственно, всё? А к тому, что в `constexpr` разрешено только то, что можно обходить.

Конструкторы и деструкторы так же, как и обычные функции, могут быть `constexpr`. Например, это позволяет инициализировать объект пользовательского типа статически (например, использовать его в `constexpr`-контексте).

### `variant`.

К сожалению, `placement new` `constexpr`-выражением не является. В C++20 есть [`std::construct_at`](https://en.cppreference.com/w/cpp/memory/construct_at), но `variant` появился в C++17. Как в C++17 сделать `variant` с `constexpr`-конструктором? Можно вместо `std::aligned_storage_t` применить `union`:

```c++
template <typename A, typename B>
union storage_t {
    constexpr storage_t(A a)
        : a(std::move(a)) {}
    A a;
    B b;
};

template <typename A, typename B>
struct either {
    constexpr either(A a)
        : index(0),
          storage_t<A, B>(std::move(a)) {}
    A* get_first() {
        return stg.a;
    }
private:
    size_t index;
    storage_t<A, B> stg;
};
```

## `constexpr`-переменные.

Те самые значения, вычисленные на этапе компиляции. Что важно знать: функция со спецификатором `constexpr` **может** быть посчитана во время компиляции, а `constexpr`-переменная — **обязана**.

Вообще, для того чтобы переменная посчиталась во время компиляции, не необходимо писать ей спецификатор `constexpr` — если у неё есть квалификатор `const` и она инициализируется статически:

```c++
constexpr int f() {
    // ...
}
int const a = 42; // статическая инициализация
int const b = f(); // динамическая инициализация
constexpr int c = f(); // статическая инициализация
```

Но в примере выше вы наверняка хотите, чтобы `b` также была константой времени компиляции, и для этого и есть `constexpr`-переменные.

Что ещё стоит иметь ввиду — так это то, что `constexpr`-переменная всегда `const` (что логично), а `const`-переменная по умолчанию `static` (предположительно, так было сделано, потому что они подразумевались как замена `#define`'ов, которые обычно пишутся в заголовочных файлах). В связи с этим `constexpr`-переменные по умолчанию статические, и если вы не хотите создания нескольких их копий, в ваших интересах добавить к спецификатору `constexpr` ещё один: `inline`.

`constexpr` может быть полезен, чтобы гарантировать, что `static`-переменные внутри функции инициализируются статически. Обычная `static`-переменная инициализируется в тот момент, когда исполнение программы первый раз доходит до её объявления (например, при вызове функции, если переменная не внутри каких-то ветвлений). В таком случае каждый следующий раз происходила бы проверка, инициализирована ли эта переменная. Если же эта переменная объявлена как `constexpr`, то никакие проверки не нужны, так как она инициализируется статически.

```c++
type_descriptor const* empty_type_descriptor {
    static constexpr type_descriptor instance = {
        // ...
    };
}
```

## `constinit`.

А можем ли мы хотеть *изменяемую* переменную, но со статическим инициализатором? Ну, можем, для этого есть `constinit`. Нужно это бывает для многопоточности. Есть такой модификатор: `thread_local` — каждый поток имеет свою копию переменной. Вообще все компиляторы имели свои аналоги `thread_local`, но они требовали ещё и статический инициализатор (так взаимодействие с ОС проще получалось). Поэтому теперь добавили `constinit`, который часто встречается вместе с `thread_local`.

Зачем нам для этого ключевое слово, почему просто не `if`'ать, какой там инициализатор? Потому что Вы можете только объявить переменную где-то, а не определить. И тогда компилятор обязан предполагать худшее. А с `constinit`'ом в объявлении Вам гарантируют, что всё будет хорошо.

## `consteval`.

В C++ есть proposal, связанный с compile-time reflection'ом. Т.е. позволить изнутри программы во время компиляции получать, например, список полей. Понятно, что мы не хотим отправлять это в runtime (иначе нам всю информацию о классах засовывать в бинарник), а во время компиляции — почему нет. Самый простой пример — автоматическая генерация сереализаторов.

И для этого нам нужны функции, которые **обязаны** посчитаться во время компиляции. Для этого есть модификатор `consteval`. Поскольку в данный момент compile-time reflection'а у нас нет, он применяется очень редко, но всё же пара примеров есть. Например, `std::source_location::current()` — функция, являющаяся более хорошим способом во время компиляции указывать кому-нибудь файл и
номер строки (нежели макросы `__FILE__` и `__LINE__`).

## Дедупликация функций

```c++
template <typename X>
struct A {
    template <typename Y>
    struct B {
        template <typename Z>
        void foo();
    }
}
```

Функция `foo` инстанцируется для каждого набора параметров `X, Y, Z`, даже если какой-нибудь из них не используется. Может ли компилятор посмотреть, что она не зависит, например, от `X` и "склеить" их?

Проблема в том, что у функции есть адрес и кажется логичным, что у разных функций должны быть разные адреса.

```c++
assert(&foo<int> != &foo<float>);
```

В стандарте (`7.6.10`) есть следующие слова:  *Otherwise, if the pointers are both null, both point to the same function, or both [represent the same address](https://eel.is/c++draft/basic.compound#def:represents_the_address), they compare equal[.](https://eel.is/c++draft/expr.eq#3.2.sentence-1)* Некоторые люди считают, что слова про *same address* могут относиться и к функциям тоже. В таком случае "склеивание" инстанциаций шаблонной функции валидно.

Некоторые линковщики умеют дедуплицировать функции, например, у `MSVC` функции склеиваются в одну. Линковщик *gold*, например, работает с этим аккуратнее — к примеру, не склеивает конструктор и деструктор, а так же может не склеивать функции, у которых берутся адреса.

Есть возможность уменьшить размер кода после инстанцирования шаблонов без нарушения инварианта на равенство адресов — можно оставить тело одной функции, а из остальных сделать на неё `jmp`. 

В GCC есть оптимизация `-fipa-icf`, которая "склеивает" функции — она работает эффективнее, если включена линк-тайм оптимизация, потому что на этапе линковки больше информации про функции из других единиц трансляции. Кроме того, на этапе компиляции оптимизируется код в каком-то внутреннем представлении компилятора, но машинный код для разных представлений может быть одинаковым, что становится понятно на этапе линковки.

Забавный факт: профилирование и отладка программы усложняются при "склеивании" функций (вызываем `foo`, а исполнение прыгает в функции `bar`).  В *gold* это обошли, анализируя цепочку вызовов и выводя из неё, какая функция была вызвана.

### Дедупликация и `if constexpr`.

Сперва почитайте [раздел про `if constexpr`](./14_templates.md#наивный-способ-делать-type-based-dispatch-if-constexpr).

Рассмотрим реализации [`function`](https://github.com/sorokin/function): там для каждого типа у `empty_type_descriptor` создавалась пустая лямбда-функция деструктора. В реализации `function` у этих лямбд берётся адрес, хоть нам и не важно, чтобы они не совпадали, но компилятор их не склеивает. Как это пофиксить?

Заметим, что вообще в реализации `storage` был шаблонным, но шаблонный параметр использовался только в типе указателя, который он хранит, поэтому можно убрать шаблон и хранить просто `void*`. Тогда можно вынести функцию из пустого дескриптора наружу:

```c++
void destroy_trivial(storage*) {}
```

А в дескрипторе взять адрес этой функции, который будет одинаковый для всех пустых дескрипторов. 

Аналогично можно оптимизировать не только для пустого дескриптора: для всех тривиальных копирований, перемещений и уничтожений, можно объединить функции. Например:

```c++
template <typename T, typename R, typename... Args>
constexpr type_descriptor<R, Args...> compute_type_descriptor() {
    // if constexpr на свойства типа и т.д.
}

template <template typename T, typename R, typename... Args> 
inline constexpr type_descriptor<R, Args...> type_descr_instance = compute_type_descriptor<T, R, Args...>(); 
```

Тогда внутри `compute_type_descriptor` может быть следующая конструкция:

```c++
template <typename T, typename R, typename... Args>
constexpr type_descriptor<R, Args...> compute_type_descriptor() {
    if constexpr (fits_small_storage<T>) {
        type_descriptor<R, Args...> result;
        if constexpr (std::is_trivially_destructible_v<T>) {
            result.destroy = &destroy_trivial;
        } else {
            result.destroy = [](storage* src) noexcept {
                src->template get_static<T>().~T();
            };
        }
        // copy, move, etc
    } else {
        // ...
    }
}
```

Такой код некорректен с точки зрения C++17, но корректен для C++20, потому что в 20-м стандарте разрешили оставлять неинициализированными переменные в constexpr выражениях (в данном случае мемберы `result`). Для C++17 можно сделать костыль и сначала проинициализировать всё нулями, а потом уже нужными значениями.

К чему вообще этот пример? Чтобы продемонстрировать, насколько `if constexpr` помогает упростить и сделать читабельной логику того, как работает функция в зависимости от каких-то компайл-тайм констант (в данном случае, свойств типов) — сделать такое через SFINAE было бы труднее.

## `is_constant_evaluated`. `if consteval`.

На `constexpr`-функции наложены некоторые ограничения: нельзя, например, делать `memcpy`. И в таком случае есть беда: может быть такая функция, что runtime'овый код, который там написан, нельзя посчитать в compile-time'е, а использовав то, что в compile-time посчитать можно, в runtime'е получим что-то неэффективное. Хотим, например использовать секретную инструкцию Вашего процессора. Тогда нам надо написать разный compile-time- и runtime-код.

Поэтому в язык добавили функцию `is_constant_evaluated`. Эта функция вернёт вам `true`, если Вы считаете её во время компиляции, иначе `false`. Но у неё есть две проблемы.
1. Даже если вы уже узнали, что сейчас время компиляции, вы не можете соответствующим образом
жить (засунуть, например, нечто странное в параметр шаблона).
2. Нельзя написать `if constexpr (is_constant_evaluated())`, потому что в таком случае `is_constant_evaluated`
всегда вычислится в `true`.

Отсюда в C++23 появилась такая штука как `if consteval` и `if !consteval`.
